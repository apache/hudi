"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[20491],{91640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>a});const l=JSON.parse('{"id":"schema_evolution","title":"Schema Evolution","description":"Schema evolution is an essential aspect of data management, and Hudi supports schema evolution on write out-of-the-box,","source":"@site/versioned_docs/version-0.14.1/schema_evolution.md","sourceDirName":".","slug":"/schema_evolution","permalink":"/cn/docs/0.14.1/schema_evolution","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-0.14.1/schema_evolution.md","tags":[],"version":"0.14.1","frontMatter":{"title":"Schema Evolution","keywords":["hudi","incremental","batch","stream","processing","schema","evolution"],"summary":"In this page, we will discuss schema evolution support in Hudi.","toc":true,"last_modified_at":"2022-04-27T19:59:57.000Z"},"sidebar":"docs","previous":{"title":"Write Operations","permalink":"/cn/docs/0.14.1/write_operations"},"next":{"title":"Key Generation","permalink":"/cn/docs/0.14.1/key_generation"}}');var i=n(74848),s=n(28453);const r={title:"Schema Evolution",keywords:["hudi","incremental","batch","stream","processing","schema","evolution"],summary:"In this page, we will discuss schema evolution support in Hudi.",toc:!0,last_modified_at:new Date("2022-04-27T19:59:57.000Z")},d=void 0,o={},a=[{value:"Schema Evolution on Write",id:"schema-evolution-on-write",level:2},{value:"Type Promotions",id:"type-promotions",level:3},{value:"Schema Evolution on read",id:"schema-evolution-on-read",level:2},{value:"Adding Columns",id:"adding-columns",level:3},{value:"Altering Columns",id:"altering-columns",level:3},{value:"Deleting Columns",id:"deleting-columns",level:3},{value:"Renaming columns",id:"renaming-columns",level:3},{value:"Schema Evolution in Action",id:"schema-evolution-in-action",level:2},{value:"Related Resources",id:"related-resources",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Schema evolution is an essential aspect of data management, and Hudi supports schema evolution on write out-of-the-box,\nand experimental support for schema evolution on read. This page will discuss the schema evolution support in Hudi."}),"\n",(0,i.jsx)(t.h2,{id:"schema-evolution-on-write",children:"Schema Evolution on Write"}),"\n",(0,i.jsx)(t.p,{children:"Hudi supports backwards-compatible schema evolution scenarios out of the box, such as adding a nullable field or promoting a field's datatype."}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"We recommend employing this approach as much as possible. This is a practical and efficient way to evolve schemas, proven at large-scale\ndata lakes at companies like Uber, Walmart, and LinkedIn. It is also implemented at scale by vendors like Confluent for streaming data.\nGiven the continuous nature of streaming data, there are no boundaries to define a schema change that can be incompatible with\nthe previous schema (e.g., renaming a column)."})}),"\n",(0,i.jsx)(t.p,{children:"Furthermore, the evolved schema is queryable across high-performance engines like Presto and Spark SQL without additional overhead for column ID translations or\ntype reconciliations. The following table summarizes the schema changes compatible with different Hudi table types."}),"\n",(0,i.jsxs)(t.p,{children:["The incoming schema will automatically have missing columns added with null values from the table schema.\nFor this we need to enable the following config\n",(0,i.jsx)(t.code,{children:"hoodie.write.set.null.for.missing.columns"}),", otherwise the pipeline will fail."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Schema Change"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"COW"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"MOR"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Remarks"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new nullable column at root level at the end"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,i.jsx)(t.code,{children:"Yes"})," means that a write with evolved schema succeeds and a read following the write succeeds to read entire dataset."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new nullable column to inner struct (at the end)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new complex type field with default (map and array)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new nullable column and change the ordering of fields"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Write succeeds but read fails if the write with evolved schema updated only some of the base files but not all. Currently, Hudi does not maintain a schema registry with history of changes across base files. Nevertheless, if the upsert touched all base files then the read will succeed."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["Add a custom nullable Hudi meta column, e.g. ",(0,i.jsx)(t.code,{children:"_hoodie_meta_col"})]}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Promote datatype for a field at root level"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Promote datatype for a nested field"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Promote datatype for a complex type (value of map or array)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new non-nullable column at root level at the end"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["In case of MOR table with Spark data source, write succeeds but read fails. As a ",(0,i.jsx)(t.strong,{children:"workaround"}),", you can make the field nullable."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Add a new non-nullable column to inner struct (at the end)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Demote datatype for a field at root level"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Demote datatype for a nested field"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Demote datatype for a complex type (value of map or array)"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"No"}),(0,i.jsx)(t.td,{style:{textAlign:"left"}})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"type-promotions",children:"Type Promotions"}),"\n",(0,i.jsx)(t.p,{children:"This chart shows what the table schema will be when an incoming column type has changed (X means that it is not allowed):"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Incoming Schema \u2193 \\ Table Schema \u2192"}),(0,i.jsx)(t.th,{children:"int"}),(0,i.jsx)(t.th,{children:"long"}),(0,i.jsx)(t.th,{children:"float"}),(0,i.jsx)(t.th,{children:"double"}),(0,i.jsx)(t.th,{children:"string"}),(0,i.jsx)(t.th,{children:"bytes"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"int"}),(0,i.jsx)(t.td,{children:"int"}),(0,i.jsx)(t.td,{children:"long"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"long"}),(0,i.jsx)(t.td,{children:"long"}),(0,i.jsx)(t.td,{children:"long"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"X"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"bytes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"bytes"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"X"}),(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"bytes"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"schema-evolution-on-read",children:"Schema Evolution on read"}),"\n",(0,i.jsx)(t.p,{children:"There are often scenarios where it's desirable to have the ability to evolve the schema more flexibly.\nFor example,"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Columns (including nested columns) can be added, deleted, modified, and moved."}),"\n",(0,i.jsx)(t.li,{children:"Renaming of columns (including nested columns)."}),"\n",(0,i.jsx)(t.li,{children:"Add, delete, or perform operations on nested columns of the Array type."}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Hudi has experimental support for allowing backward incompatible schema evolution scenarios on write while resolving\nit during read time. To enable this feature, ",(0,i.jsx)(t.code,{children:"hoodie.schema.on.read.enable=true"})," needs to be set on the writer config (Datasource) or table property (SQL)."]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["Hudi versions > 0.11 and Spark versions > 3.1.x, and 3.2.1 are required. For Spark 3.2.1 and above,\n",(0,i.jsx)(t.code,{children:"spark.sql.catalog.spark_catalog"})," must also be set. If schema on read is enabled, it cannot be disabled again\nsince the table would have accepted such schema changes already."]})}),"\n",(0,i.jsx)(t.h3,{id:"adding-columns",children:"Adding Columns"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"-- add columns\nALTER TABLE tableName ADD COLUMNS(col_spec[, col_spec ...])\n"})}),"\n",(0,i.jsx)(t.p,{children:"Column specification consists of five field, next to each other."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"col_name"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"name of the new column. To add sub-column col1 to a nested map type column member map<string, struct<n: string, a: int>>, set this field to member.value.col1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"col_type"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"type of the new column."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"nullable"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"whether or not the new column allows null values. (optional)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"comment"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"comment of the new column. (optional)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"col_position"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["The position where the new column is added. The value can be ",(0,i.jsx)(t.em,{children:"FIRST"})," or ",(0,i.jsx)(t.em,{children:"AFTER origin_col"}),". If it is set to ",(0,i.jsx)(t.em,{children:"FIRST"}),", the new column will be added before the first column of the table. If it is set to ",(0,i.jsx)(t.em,{children:"AFTER origin_col"}),", the new column will be added after the original column.  ",(0,i.jsx)(t.em,{children:"FIRST"})," can be used only when new sub-columns are added to nested columns and not in top-level columns. There are no restrictions on the usage of ",(0,i.jsx)(t.em,{children:"AFTER"}),"."]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Examples"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE h0 ADD COLUMNS(ext0 string);\nALTER TABLE h0 ADD COLUMNS(new_col int not null comment 'add new column' AFTER col1);\nALTER TABLE complex_table ADD COLUMNS(col_struct.col_name string comment 'add new column to a struct col' AFTER col_from_col_struct);\n"})}),"\n",(0,i.jsx)(t.h3,{id:"altering-columns",children:"Altering Columns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Syntax"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"-- alter table ... alter column\nALTER TABLE tableName ALTER [COLUMN] col_old_name TYPE column_type [COMMENT] col_comment[FIRST|AFTER] column_name\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Parameter Description"})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"tableName"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Table name."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"col_old_name"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Name of the column to be altered."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"column_type"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Type of the target column."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"col_comment"}),(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"Optional comments on the altered column."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{style:{textAlign:"left"},children:"column_name"}),(0,i.jsxs)(t.td,{style:{textAlign:"left"},children:["The new position to place the altered column. For example, ",(0,i.jsx)(t.em,{children:"AFTER"})," ",(0,i.jsx)(t.strong,{children:"column_name"})," indicates that the target column is placed after ",(0,i.jsx)(t.strong,{children:"column_name"}),"."]})]})]})]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Examples"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"--- Changing the column type\nALTER TABLE table1 ALTER COLUMN a.b.c TYPE bigint\n\n--- Altering other attributes\nALTER TABLE table1 ALTER COLUMN a.b.c COMMENT 'new comment'\nALTER TABLE table1 ALTER COLUMN a.b.c FIRST\nALTER TABLE table1 ALTER COLUMN a.b.c AFTER x\nALTER TABLE table1 ALTER COLUMN a.b.c DROP NOT NULL\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"column type change"})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Source\\Target"}),(0,i.jsx)(t.th,{children:"long"}),(0,i.jsx)(t.th,{children:"float"}),(0,i.jsx)(t.th,{children:"double"}),(0,i.jsx)(t.th,{children:"string"}),(0,i.jsx)(t.th,{children:"decimal"}),(0,i.jsx)(t.th,{children:"date"}),(0,i.jsx)(t.th,{children:"int"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"int"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"long"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"float"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"double"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"decimal"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"string"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"date"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"}),(0,i.jsx)(t.td,{children:"Y"}),(0,i.jsx)(t.td,{children:"N"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"deleting-columns",children:"Deleting Columns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Syntax"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"-- alter table ... drop columns\nALTER TABLE tableName DROP COLUMN|COLUMNS cols\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Examples"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE table1 DROP COLUMN a.b.c\nALTER TABLE table1 DROP COLUMNS a.b.c, x, y\n"})}),"\n",(0,i.jsx)(t.h3,{id:"renaming-columns",children:"Renaming columns"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Syntax"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"-- alter table ... rename column\nALTER TABLE tableName RENAME COLUMN old_columnName TO new_columnName\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Examples"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"ALTER TABLE table1 RENAME COLUMN a.b.c TO x\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["When using hive metastore, please disable  ",(0,i.jsx)(t.code,{children:"hive.metastore.disallow.incompatible.col.type.changes"})," if you encounter this error:\n",(0,i.jsx)(t.code,{children:"The following columns have types incompatible with the existing columns in their respective positions"}),"."]})}),"\n",(0,i.jsx)(t.h2,{id:"schema-evolution-in-action",children:"Schema Evolution in Action"}),"\n",(0,i.jsx)(t.p,{children:"Let us walk through an example to demonstrate the schema evolution support in Hudi. In the below example, we are going to add a new string field and change the datatype of a field from int to long."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-scala",children:'scala> :paste \nimport org.apache.hudi.QuickstartUtils._\nimport scala.collection.JavaConversions._\nimport org.apache.spark.sql.SaveMode._\nimport org.apache.hudi.DataSourceReadOptions._\nimport org.apache.hudi.DataSourceWriteOptions._\nimport org.apache.hudi.config.HoodieWriteConfig._\nimport org.apache.spark.sql.types._\nimport org.apache.spark.sql.Row\n\nval tableName = "hudi_trips_cow"\nval basePath = "file:///tmp/hudi_trips_cow"\nval schema = StructType( Array(\n     StructField("rowId", StringType,true),\n     StructField("partitionId", StringType,true),\n     StructField("preComb", LongType,true),\n     StructField("name", StringType,true),\n     StructField("versionId", StringType,true),\n     StructField("intToLong", IntegerType,true)\n))\n        \n        \nval data1 = Seq(Row("row_1", "part_0", 0L, "bob", "v_0", 0),\n                Row("row_2", "part_0", 0L, "john", "v_0", 0),\n                Row("row_3", "part_0", 0L, "tom", "v_0", 0))\n        \nvar dfFromData1 = spark.createDataFrame(data1, schema)\ndfFromData1.write.format("hudi").\n   options(getQuickstartWriteConfigs).\n   option(PRECOMBINE_FIELD.key, "preComb").\n   option(RECORDKEY_FIELD.key, "rowId").\n   option(PARTITIONPATH_FIELD.key, "partitionId").\n   option("hoodie.index.type","SIMPLE").\n   option(TBL_NAME.key, tableName).\n   mode(Overwrite).\n   save(basePath)\n\nvar tripsSnapshotDF1 = spark.read.format("hudi").load(basePath + "/*/*")\ntripsSnapshotDF1.createOrReplaceTempView("hudi_trips_snapshot")\n\nctrl+D\n\nscala> spark.sql("desc hudi_trips_snapshot").show()\n    +--------------------+---------+-------+\n    |            col_name|data_type|comment|\n    +--------------------+---------+-------+\n    | _hoodie_commit_time|   string|   null|\n    |_hoodie_commit_seqno|   string|   null|\n    |  _hoodie_record_key|   string|   null|\n    |_hoodie_partition...|   string|   null|\n    |   _hoodie_file_name|   string|   null|\n    |               rowId|   string|   null|\n    |         partitionId|   string|   null|\n    |             preComb|   bigint|   null|\n    |                name|   string|   null|\n    |           versionId|   string|   null|\n    |           intToLong|      int|   null|\n    +--------------------+---------+-------+\n    \nscala> spark.sql("select rowId, partitionId, preComb, name, versionId, intToLong from hudi_trips_snapshot").show()\n    +-----+-----------+-------+----+---------+---------+\n    |rowId|partitionId|preComb|name|versionId|intToLong|\n    +-----+-----------+-------+----+---------+---------+\n    |row_3|     part_0|      0| tom|      v_0|        0|\n    |row_2|     part_0|      0|john|      v_0|        0|\n    |row_1|     part_0|      0| bob|      v_0|        0|\n    +-----+-----------+-------+----+---------+---------+\n\n// In the new schema, we are going to add a String field and \n// change the datatype `intToLong` field from  int to long.\nscala> :paste \nval newSchema = StructType( Array(\n    StructField("rowId", StringType,true),\n    StructField("partitionId", StringType,true),\n    StructField("preComb", LongType,true),\n    StructField("name", StringType,true),\n    StructField("versionId", StringType,true),\n    StructField("intToLong", LongType,true),\n    StructField("newField", StringType,true)\n))\n\nval data2 = Seq(Row("row_2", "part_0", 5L, "john", "v_3", 3L, "newField_1"),\n               Row("row_5", "part_0", 5L, "maroon", "v_2", 2L, "newField_1"),\n               Row("row_9", "part_0", 5L, "michael", "v_2", 2L, "newField_1"))\n\nvar dfFromData2 = spark.createDataFrame(data2, newSchema)\ndfFromData2.write.format("hudi").\n    options(getQuickstartWriteConfigs).\n    option(PRECOMBINE_FIELD.key, "preComb").\n    option(RECORDKEY_FIELD.key, "rowId").\n    option(PARTITIONPATH_FIELD.key, "partitionId").\n    option("hoodie.index.type","SIMPLE").\n    option(TBL_NAME.key, tableName).\n    mode(Append).\n    save(basePath)\n\nvar tripsSnapshotDF2 = spark.read.format("hudi").load(basePath + "/*/*")\ntripsSnapshotDF2.createOrReplaceTempView("hudi_trips_snapshot")\n\nCtrl + D\n\nscala> spark.sql("desc hudi_trips_snapshot").show()\n    +--------------------+---------+-------+\n    |            col_name|data_type|comment|\n    +--------------------+---------+-------+\n    | _hoodie_commit_time|   string|   null|\n    |_hoodie_commit_seqno|   string|   null|\n    |  _hoodie_record_key|   string|   null|\n    |_hoodie_partition...|   string|   null|\n    |   _hoodie_file_name|   string|   null|\n    |               rowId|   string|   null|\n    |         partitionId|   string|   null|\n    |             preComb|   bigint|   null|\n    |                name|   string|   null|\n    |           versionId|   string|   null|\n    |           intToLong|   bigint|   null|\n    |            newField|   string|   null|\n    +--------------------+---------+-------+\n\n\nscala> spark.sql("select rowId, partitionId, preComb, name, versionId, intToLong, newField from hudi_trips_snapshot").show()\n    +-----+-----------+-------+-------+---------+---------+----------+\n    |rowId|partitionId|preComb|   name|versionId|intToLong|  newField|\n    +-----+-----------+-------+-------+---------+---------+----------+\n    |row_3|     part_0|      0|    tom|      v_0|        0|      null|\n    |row_2|     part_0|      5|   john|      v_3|        3|newField_1|\n    |row_1|     part_0|      0|    bob|      v_0|        0|      null|\n    |row_5|     part_0|      5| maroon|      v_2|        2|newField_1|\n    |row_9|     part_0|      5|michael|      v_2|        2|newField_1|\n    +-----+-----------+-------+-------+---------+---------+----------+\n\n'})}),"\n",(0,i.jsx)(t.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,i.jsx)("h3",{children:"Videos"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://youtu.be/s1_-zl3sfLE",children:"Learn Schema Evolution in Apache Hudi Transaction Datalake with hands on labs"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=_i5G4ojpwlk",children:"How do I identify Schema Changes in Hudi Tables and Send Email Alert when New Column added/removed"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>d});var l=n(96540);const i={},s=l.createContext(i);function r(e){const t=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),l.createElement(s.Provider,{value:t},e.children)}}}]);