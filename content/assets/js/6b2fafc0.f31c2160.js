"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[247],{28453(e,i,r){r.d(i,{R:()=>s,x:()=>a});var n=r(96540);const t={},o=n.createContext(t);function s(e){const i=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),n.createElement(o.Provider,{value:i},e.children)}},42471(e,i,r){r.r(i),r.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"concurrency_control","title":"Concurrency Control","description":"Concurrency control defines how different writers, readers, and table services coordinate access to a Hudi table. Hudi ensures atomic writes by publishing commits atomically to the timeline, stamped with an instant time that denotes when the action is deemed to have occurred. Unlike general-purpose file version control, Hudi draws a clear distinction between writer processes that issue write operations, table services that (re)write data/metadata to optimize or perform bookkeeping, and readers (that execute queries and read data).","source":"@site/versioned_docs/version-1.1.1/concurrency_control.md","sourceDirName":".","slug":"/concurrency_control","permalink":"/docs/concurrency_control","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-1.1.1/concurrency_control.md","tags":[],"version":"1.1.1","frontMatter":{"title":"Concurrency Control","summary":"On this page, we discuss how to perform concurrent writes to Hudi tables.","toc":true,"toc_min_heading_level":2,"toc_max_heading_level":4,"last_modified_at":"2025-11-23T14:20:00.000Z"},"sidebar":"docs","previous":{"title":"Indexes","permalink":"/docs/indexes"},"next":{"title":"Schema Evolution","permalink":"/docs/schema_evolution"}}');var t=r(74848),o=r(28453);const s={title:"Concurrency Control",summary:"On this page, we discuss how to perform concurrent writes to Hudi tables.",toc:!0,toc_min_heading_level:2,toc_max_heading_level:4,last_modified_at:new Date("2025-11-23T14:20:00.000Z")},a=void 0,c={},l=[{value:"Distributed Locking",id:"distributed-locking",level:2},{value:"Storage-Based Lock Provider",id:"storage-based-lock-provider",level:3},{value:"Zookeeper-Based Lock Provider",id:"zookeeper-based-lock-provider",level:3},{value:"HiveMetastore-Based Lock Provider",id:"hivemetastore-based-lock-provider",level:3},{value:"DynamoDB-Based Lock Provider",id:"dynamodb-based-lock-provider",level:3},{value:"FileSystem based lock provider",id:"filesystem-based-lock-provider",level:3},{value:"Simple Single writer + table services",id:"simple-single-writer--table-services",level:2},{value:"Inline table services",id:"inline-table-services",level:3},{value:"Async table services",id:"async-table-services",level:3},{value:"Full-on Multi-writer + Async table services",id:"full-on-multi-writer--async-table-services",level:2},{value:"Multi-Writer Guarantees",id:"multi-writer-guarantees",level:3},{value:"Non-Blocking Concurrency Control",id:"non-blocking-concurrency-control",level:2},{value:"Early conflict Detection",id:"early-conflict-detection",level:2},{value:"Enabling Multi Writing",id:"enabling-multi-writing",level:2},{value:"Multi Writing via Hudi Streamer",id:"multi-writing-via-hudi-streamer",level:3},{value:"Multi Writing via Spark Datasource Writer",id:"multi-writing-via-spark-datasource-writer",level:3},{value:"Disabling Multi Writing",id:"disabling-multi-writing",level:2},{value:"OCC Best Practices",id:"occ-best-practices",level:2},{value:"Caveats",id:"caveats",level:2},{value:"Related Resources",id:"related-resources",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Concurrency control defines how different writers, readers, and table services coordinate access to a Hudi table. Hudi ensures atomic writes by publishing commits atomically to the timeline, stamped with an instant time that denotes when the action is deemed to have occurred. Unlike general-purpose file version control, Hudi draws a clear distinction between writer processes that issue ",(0,t.jsx)(i.a,{href:"/docs/write_operations",children:"write operations"}),", table services that (re)write data/metadata to optimize or perform bookkeeping, and readers (that execute queries and read data)."]}),"\n",(0,t.jsx)(i.p,{children:"Hudi provides:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Snapshot isolation"})," between all three types of processes, meaning they all operate on a consistent snapshot of the table."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Optimistic Concurrency Control (OCC)"})," between writers to provide standard relational database semantics."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Multiversion Concurrency Control (MVCC)"})," between writers and table services and between different table services."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Non-Blocking Concurrency Control (NBCC)"})," between writers to provide streaming semantics and avoid live-locks/starvation between writers."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"In this section, we discuss the different concurrency controls supported by Hudi and how they enable flexible deployment models for single- and multi-writer scenarios. We also describe ways to ingest data into a Hudi table from multiple writers using components like Hudi Streamer, the Hudi DataSource, Spark Structured Streaming, and Spark SQL."}),"\n",(0,t.jsxs)(i.admonition,{type:"note",children:[(0,t.jsx)(i.p,{children:"If there is only one process performing writing AND async/inline table services on the table, you can avoid the overhead of a distributed lock requirement by configuring the in-process lock provider."}),(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.client.transaction.lock.InProcessLockProvider\n"})})]}),"\n",(0,t.jsx)(i.h2,{id:"distributed-locking",children:"Distributed Locking"}),"\n",(0,t.jsxs)(i.p,{children:["A prerequisite for distributed coordination in Hudi, like many other distributed systems, is a distributed lock provider that processes can use to plan, schedule, and execute actions on the Hudi timeline concurrently. Locks are also used to ",(0,t.jsx)(i.a,{href:"/docs/timeline#truetime-generation",children:"generate TrueTime"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"External locking is typically used with optimistic concurrency control because it prevents conflicts that occur when two or more commits attempt to modify the same resource concurrently. When a transaction attempts to modify a locked resource, it must wait until the lock is released."}),"\n",(0,t.jsx)(i.p,{children:"In multi-writing scenarios, locks are acquired on the Hudi table for very short periods during specific phases (such as just before committing writes or before scheduling table services) instead of for the entire job duration. This approach allows multiple writers to work on the same table simultaneously, increasing concurrency and avoiding conflicts."}),"\n",(0,t.jsxs)(i.p,{children:["Hudi provides multiple lock providers requiring different configurations. Refer to the ",(0,t.jsx)(i.a,{href:"/docs/configurations#LOCK",children:"locking configs"})," for the complete list."]}),"\n",(0,t.jsx)(i.h3,{id:"storage-based-lock-provider",children:"Storage-Based Lock Provider"}),"\n",(0,t.jsxs)(i.p,{children:["The storage-based lock provider eliminates the need for external lock infrastructure by managing concurrency directly using the ",(0,t.jsx)(i.code,{children:".hoodie/"})," directory in your table's storage layer. This removes dependencies on DynamoDB, ZooKeeper, or Hive Metastore, reducing operational complexity and cost."]}),"\n",(0,t.jsx)(i.p,{children:"It uses conditional writes on a single lock file so only one writer holds the lock at a time, with heartbeat-based renewal and automatic expiration for fault tolerance. Basic setup requires only setting the provider class name, though optional parameters allow tuning lock validity and renewal intervals."}),"\n",(0,t.jsx)(i.p,{children:"Add the corresponding cloud bundle to your classpath:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["For S3: ",(0,t.jsx)(i.code,{children:"hudi-aws-bundle"})]}),"\n",(0,t.jsxs)(i.li,{children:["For GCS: ",(0,t.jsx)(i.code,{children:"hudi-gcp-bundle"})]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Set this configuration:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.client.transaction.lock.StorageBasedLockProvider\n"})}),"\n",(0,t.jsx)(i.p,{children:"Supported for S3 and GCS (additional systems planned). This cloud-native design works directly with storage features, simplifying large-scale cloud operations."}),"\n",(0,t.jsx)(i.p,{children:"Optional tuning configurations:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Config Name"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.storage.validity.timeout.secs"}),(0,t.jsx)(i.td,{children:"300 (Optional)"}),(0,t.jsxs)(i.td,{children:["Validity period (seconds) for each new lock. The provider renews its lock until the lease extends or timeout occurs.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: STORAGE_BASED_LOCK_VALIDITY_TIMEOUT_SECS"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 1.0.2"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.storage.renew.interval.secs"}),(0,t.jsx)(i.td,{children:"30 (Optional)"}),(0,t.jsxs)(i.td,{children:["Interval (seconds) between renewal attempts.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: STORAGE_BASED_LOCK_RENEW_INTERVAL_SECS"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 1.0.2"})]})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"zookeeper-based-lock-provider",children:"Zookeeper-Based Lock Provider"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.client.transaction.lock.ZookeeperBasedLockProvider\n"})}),"\n",(0,t.jsx)(i.p,{children:"Basic configuration:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Config Name"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.zookeeper.base_path"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["Base path on ZooKeeper under which to create lock-related ZNodes. Must be the same for all concurrent writers.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: ZK_BASE_PATH"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.zookeeper.port"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["ZooKeeper port.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: ZK_PORT"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.zookeeper.url"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["ZooKeeper connection URL.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: ZK_CONNECT_URL"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"hivemetastore-based-lock-provider",children:"HiveMetastore-Based Lock Provider"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.hive.transaction.lock.HiveMetastoreBasedLockProvider\n"})}),"\n",(0,t.jsx)(i.p,{children:"Basic configuration:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Config Name"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.hivemetastore.database"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["Hive database to acquire lock against.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: HIVE_DATABASE_NAME"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.hivemetastore.table"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["Hive table to acquire lock against.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: HIVE_TABLE_NAME"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"Hive Metastore URIs are picked up from the Hadoop configuration at runtime."}),"\n",(0,t.jsxs)(i.admonition,{type:"note",children:[(0,t.jsx)(i.p,{children:"ZooKeeper is required for the HMS lock provider. Set ZooKeeper configs via Hudi:"}),(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.zookeeper.url\nhoodie.write.lock.zookeeper.port\n"})}),(0,t.jsx)(i.p,{children:"Or via Hive configuration:"}),(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hive.zookeeper.quorum\nhive.zookeeper.client.port\n"})})]}),"\n",(0,t.jsx)(i.h3,{id:"dynamodb-based-lock-provider",children:"DynamoDB-Based Lock Provider"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.aws.transaction.lock.DynamoDBBasedLockProvider\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The Amazon DynamoDB\u2013based lock provider supports multi-writing across clusters. See ",(0,t.jsx)(i.a,{href:"/docs/configurations#DynamoDB-based-Locks-Configurations",children:"DynamoDB-Based Locks Configurations"})," for all options. Basic configuration:"]}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Config Name"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsx)(i.tbody,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.dynamodb.endpoint_url"}),(0,t.jsxs)(i.td,{children:["N/A ",(0,t.jsx)(i.strong,{children:"(Required)"})]}),(0,t.jsxs)(i.td,{children:["Endpoint URL for DynamoDB (useful for local testing).",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: DYNAMODB_ENDPOINT_URL"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.10.1"})]})]})})]}),"\n",(0,t.jsxs)(i.p,{children:["Further configurations: ",(0,t.jsx)(i.a,{href:"/docs/configurations#DynamoDB-based-Locks-Configurations",children:"DynamoDB-Based Locks Configurations"})]}),"\n",(0,t.jsxs)(i.p,{children:["Table creation: Hudi auto-creates the DynamoDB table specified by ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.dynamodb.table"}),". If using an existing table, ensure a ",(0,t.jsx)(i.code,{children:"key"})," attribute (as partition key) exists. ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.dynamodb.partition_key"})," is the value written for the partition key (default: table name), ensuring multiple writers share the same lock."]}),"\n",(0,t.jsx)(i.p,{children:"Credential props (if not using the default provider chain):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.aws.access.key\nhoodie.aws.secret.key\nhoodie.aws.session.token\n"})}),"\n",(0,t.jsxs)(i.p,{children:["If unset, Hudi falls back to the ",(0,t.jsx)(i.a,{href:"https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.html",children:"DefaultAWSCredentialsProviderChain"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Required IAM permissions:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n  "Sid": "DynamoDBLocksTable",\n  "Effect": "Allow",\n  "Action": [\n    "dynamodb:CreateTable",\n    "dynamodb:DeleteItem",\n    "dynamodb:DescribeTable",\n    "dynamodb:GetItem",\n    "dynamodb:PutItem",\n    "dynamodb:Scan",\n    "dynamodb:UpdateItem"\n  ],\n  "Resource": "arn:${Partition}:dynamodb:${Region}:${Account}:table/${TableName}"\n}\n'})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"TableName"})," : same as ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.dynamodb.partition_key"})]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"Region"}),": same as ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.dynamodb.region"})]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"AWS SDK dependencies are not bundled with Hudi from v0.10.x and will need to be added to your classpath.\nAdd the following Maven packages (check the latest versions at time of install):"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-text",children:"com.amazonaws:dynamodb-lock-client\ncom.amazonaws:aws-java-sdk-dynamodb\ncom.amazonaws:aws-java-sdk-core\n"})}),"\n",(0,t.jsx)(i.h3,{id:"filesystem-based-lock-provider",children:"FileSystem based lock provider"}),"\n",(0,t.jsx)(i.p,{children:"FileSystem based lock provider supports multiple writers across different jobs/applications based on atomic create/delete operations of the underlying filesystem."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.provider=org.apache.hudi.client.transaction.lock.FileSystemBasedLockProvider\n"})}),"\n",(0,t.jsxs)(i.p,{children:["When using the FileSystem based lock provider, by default, the lock file will store into ",(0,t.jsx)(i.code,{children:"hoodie.base.path"}),"+",(0,t.jsx)(i.code,{children:"/.hoodie/lock"}),". You may use a custom folder to store the lock file by specifying ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.filesystem.path"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["In case the lock cannot be released during job crash, you can set ",(0,t.jsx)(i.code,{children:"hoodie.write.lock.filesystem.expire"})," (lock will never expire by default) to a desired expire time in minutes. You may also delete the lock file manually in such situation."]}),"\n",(0,t.jsx)(i.admonition,{type:"warning",children:(0,t.jsx)(i.p,{children:"FileSystem based lock provider is not for production use, and it is not supported with cloud storage like S3 or GCS."})}),"\n",(0,t.jsx)(i.h2,{id:"simple-single-writer--table-services",children:"Simple Single writer + table services"}),"\n",(0,t.jsx)(i.p,{children:"Data lakehouse pipelines tend to be predominantly single writer, with the most common need for distributed co-ordination on a table coming from table management. For e.g. a Apache Flink\njob producing fast writes into a table, requiring regular file-size management or cleaning. Hudi's storage engine and platform tools provide a lot of support for such common scenarios."}),"\n",(0,t.jsx)(i.h3,{id:"inline-table-services",children:"Inline table services"}),"\n",(0,t.jsx)(i.p,{children:"This is the simplest form of concurrency, meaning there is no concurrency at all in the write processes. In this model, Hudi eliminates the need for concurrency control and maximizes throughput by supporting these table services out-of-box and running inline after every write to the table. Execution plans are idempotent, persisted to the timeline and auto-recover from failures. For most simple use-cases, this means just writing is sufficient to get a well-managed table that needs no concurrency control."}),"\n",(0,t.jsxs)(i.p,{children:["There is no actual concurrent writing in this model. ",(0,t.jsx)(i.strong,{children:"MVCC"})," is leveraged to provide snapshot isolation guarantees between ingestion writer and multiple readers and also between multiple table service writers and readers. Writes to the table either from ingestion or from table services produce versioned data that are available to readers only after the writes are committed. Until then, readers can access only the previous version of the data."]}),"\n",(0,t.jsx)(i.p,{children:"A single writer with all table services such as cleaning, clustering, compaction, etc can be configured to be inline (such as Hudi Streamer sync-once mode and Spark Datasource with default configs) without any additional configs."}),"\n",(0,t.jsx)(i.h3,{id:"async-table-services",children:"Async table services"}),"\n",(0,t.jsxs)(i.p,{children:["Hudi provides the option of running the table services in an async fashion, where most of the heavy lifting (e.g actually rewriting the columnar data by compaction service) is done asynchronously. In this model, the async deployment eliminates any repeated wasteful retries and optimizes the table using clustering techniques while a single writer consumes the writes to the table without having to be blocked by such table services. This model avoids the need for taking a ",(0,t.jsx)(i.a,{href:"#distributed-locking",children:"lock provider"})," to control concurrency and avoids the need to separately orchestrate and monitor offline table services jobs."]}),"\n",(0,t.jsxs)(i.p,{children:["A single writer along with async table services runs in the same process. For example, you can have a  Hudi Streamer in continuous mode write to a MOR table using async compaction; you can use Spark Streaming (where ",(0,t.jsx)(i.a,{href:"/docs/compaction",children:"compaction"})," is async by default), and you can use Flink streaming or your own job setup and enable async table services inside the same writer."]}),"\n",(0,t.jsxs)(i.p,{children:["Hudi leverages ",(0,t.jsx)(i.strong,{children:"MVCC"})," in this model to support running any number of table service jobs concurrently, without any concurrency conflict.  This is made possible by ensuring Hudi 's ingestion writer and async table services coordinate among themselves to ensure no conflicts and avoid race conditions. The same single write guarantees described in Model A above can be achieved in this model as well.\nWith this model users don't need to spin up different spark jobs and manage the orchestration among it. For larger deployments, this model can ease the operational burden significantly while getting the table services running without blocking the writers."]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Single Writer Guarantees"})}),"\n",(0,t.jsxs)(i.p,{children:["In this model, the following are the guarantees on ",(0,t.jsx)(i.a,{href:"/docs/write_operations",children:"write operations"})," to expect:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"UPSERT Guarantee"}),": The target table will NEVER show duplicates."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"INSERT Guarantee"}),": The target table will NEVER have duplicates if dedup: ",(0,t.jsx)(i.a,{href:"/docs/configurations#hoodiedatasourcewriteinsertdropduplicates",children:(0,t.jsx)(i.code,{children:"hoodie.datasource.write.insert.drop.duplicates"})})," & ",(0,t.jsx)(i.a,{href:"/docs/configurations#hoodiecombinebeforeinsert",children:(0,t.jsx)(i.code,{children:"hoodie.combine.before.insert"})}),", is enabled."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"BULK_INSERT Guarantee"}),": The target table will NEVER have duplicates if dedup: ",(0,t.jsx)(i.a,{href:"/docs/configurations#hoodiedatasourcewriteinsertdropduplicates",children:(0,t.jsx)(i.code,{children:"hoodie.datasource.write.insert.drop.duplicates"})})," & ",(0,t.jsx)(i.a,{href:"/docs/configurations#hoodiecombinebeforeinsert",children:(0,t.jsx)(i.code,{children:"hoodie.combine.before.insert"})}),", is enabled."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"INCREMENTAL QUERY Guarantee"}),": Data consumption and checkpoints are NEVER out of order."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"full-on-multi-writer--async-table-services",children:"Full-on Multi-writer + Async table services"}),"\n",(0,t.jsxs)(i.p,{children:["Hudi supports concurrency mode ",(0,t.jsx)(i.code,{children:"NON_BLOCKING_CONCURRENCY_CONTROL"}),", where unlike OCC, multiple writers can\noperate on the table with non-blocking conflict resolution. The writers can write into the same file group with the conflicts resolved automatically by the query reader and the compactor. You can read more about it under ",(0,t.jsx)(i.a,{href:"#non-blocking-concurrency-control",children:"this section"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"It is not always possible to serialize all write operations to a table (such as UPSERT, INSERT or DELETE) into the same write process and therefore, multi-writing capability may be required.\nIn multi-writing, disparate distributed processes run in parallel or overlapping time windows to write to the same table. In such cases, an external locking mechanism is a must to safely\ncoordinate concurrent accesses. Here are a few different scenarios that would all fall under multi-writing:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Multiple ingestion writers to the same table: For instance, two Spark Datasource writers working on different sets of partitions form a source kafka topic."}),"\n",(0,t.jsx)(i.li,{children:"Multiple ingestion writers to the same table, including one writer with async table services: For example, a Hudi Streamer with async compaction for regular ingestion & a Spark Datasource writer for backfilling."}),"\n",(0,t.jsx)(i.li,{children:"A single ingestion writer and a separate compaction (HoodieCompactor) or clustering (HoodieClusteringJob) job apart from the ingestion writer: This is considered as multi-writing as they are not running in the same process."}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Hudi's concurrency model intelligently differentiates actual writing to the table from table services that manage or optimize the table. Hudi offers similar ",(0,t.jsx)(i.strong,{children:"optimistic concurrency control across multiple writers"}),", but ",(0,t.jsx)(i.strong,{children:"table services can still execute completely lock-free and async"})," as long as they run in the same process as one of the writers.\nFor multi-writing, Hudi leverages file level optimistic concurrency control(OCC). For example, when two writers write to non overlapping files, both writes are allowed to succeed. However, when the writes from different writers overlap (touch the same set of files), only one of them will succeed. Please note that this feature is currently experimental and requires external lock providers to acquire locks briefly at critical sections during the write. More on lock providers below."]}),"\n",(0,t.jsx)(i.h3,{id:"multi-writer-guarantees",children:"Multi-Writer Guarantees"}),"\n",(0,t.jsx)(i.p,{children:"With multiple writers using OCC, these are the write guarantees to expect:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"UPSERT Guarantee"}),": The target table will NEVER show duplicates."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"INSERT Guarantee"}),": The target table MIGHT have duplicates even if dedup is enabled."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"BULK_INSERT Guarantee"}),": The target table MIGHT have duplicates even if dedup is enabled."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"INCREMENTAL PULL Guarantee"}),": Data consumption and checkpoints are NEVER out of order. If there are inflight commits (due to multi-writing), incremental queries will not expose the completed commits following the inflight commits."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"non-blocking-concurrency-control",children:"Non-Blocking Concurrency Control"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"NON_BLOCKING_CONCURRENCY_CONTROL"})," offers the same set of guarantees as mentioned in the case of OCC but without\nexplicit locks for serializing the writes. Lock is only needed for writing the commit metadata to the Hudi timeline. The\ncompletion time for the commits reflects the serialization order and file slicing is done based on completion time.\nMultiple writers can operate on the table with non-blocking conflict resolution. The writers can write into the same\nfile group with the conflicts resolved automatically by the query reader and the compactor. It works for compaction and ingestion, and we can see an example of that with ",(0,t.jsx)(i.a,{href:"/docs/sql_dml#non-blocking-concurrency-control-experimental",children:"Flink writers"}),"."]}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"NON_BLOCKING_CONCURRENCY_CONTROL"})," currently works only for MOR tables using simple bucket index and partition-level bucket index."]})}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"NON_BLOCKING_CONCURRENCY_CONTROL"})," between ingestion writer and table service writer is not yet supported for clustering. Please use ",(0,t.jsx)(i.code,{children:"OPTIMISTIC_CONCURRENCY_CONTROL"})," for clustering."]})}),"\n",(0,t.jsx)(i.h2,{id:"early-conflict-detection",children:"Early conflict Detection"}),"\n",(0,t.jsx)(i.p,{children:"Multi writing using OCC allows multiple writers to concurrently write and atomically commit to the Hudi table if there is no overlapping data file to be written, to guarantee data consistency, integrity and correctness. Prior to 0.13.0 release, as the OCC (optimistic concurrency control) name suggests, each writer will optimistically proceed with ingestion and towards the end, just before committing will go about conflict resolution flow to deduce overlapping writes and abort one if need be. But this could result in lot of compute waste, since the aborted commit will have to retry from beginning. With 0.13.0, Hudi introduced early conflict deduction leveraging markers in hudi to deduce the conflicts eagerly and abort early in the write lifecyle instead of doing it in the end. For large scale deployments, this might avoid wasting lot o compute resources if there could be overlapping concurrent writers."}),"\n",(0,t.jsxs)(i.p,{children:["To improve the concurrency control, the ",(0,t.jsx)(i.a,{href:"https://hudi.apache.org/releases/release-0.13.0#early-conflict-detection-for-multi-writer",children:"0.13.0 release"})," introduced a new feature, early conflict detection in OCC, to detect the conflict during the data writing phase and abort the writing early on once a conflict is detected, using Hudi's marker mechanism. Hudi can now stop a conflicting writer much earlier because of the early conflict detection and release computing resources necessary to cluster, improving resource utilization."]}),"\n",(0,t.jsxs)(i.p,{children:["By default, this feature is turned off. To try this out, a user needs to set ",(0,t.jsx)(i.code,{children:"hoodie.write.concurrency.early.conflict.detection.enable"})," to true, when using OCC for concurrency control (Refer ",(0,t.jsx)(i.a,{href:"/docs/configurations#Write-Configurations-advanced-configs",children:"configs"})," page for all relevant configs)."]}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsxs)(i.p,{children:["Early conflict Detection in OCC is an ",(0,t.jsx)(i.strong,{children:"EXPERIMENTAL"})," feature"]})}),"\n",(0,t.jsx)(i.h2,{id:"enabling-multi-writing",children:"Enabling Multi Writing"}),"\n",(0,t.jsx)(i.p,{children:"The following properties are needed to be set appropriately to turn on optimistic concurrency control to achieve multi writing."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.concurrency.mode=optimistic_concurrency_control\nhoodie.write.lock.provider=<lock-provider-classname>\nhoodie.cleaner.policy.failed.writes=LAZY\n"})}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Config Name"}),(0,t.jsx)(i.th,{children:"Default"}),(0,t.jsx)(i.th,{children:"Description"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.concurrency.mode"}),(0,t.jsx)(i.td,{children:"SINGLE_WRITER (Optional)"}),(0,t.jsxs)(i.td,{children:[(0,t.jsx)("u",{children:(0,t.jsx)(i.a,{href:"https://github.com/apache/hudi/blob/00ece7bce0a4a8d0019721a28049723821e01842/hudi-common/src/main/java/org/apache/hudi/common/model/WriteConcurrencyMode.java",children:"Concurrency modes"})})," for write operations.",(0,t.jsx)("br",{}),"Possible values:",(0,t.jsx)("br",{}),(0,t.jsxs)("ul",{children:[(0,t.jsxs)("li",{children:[(0,t.jsx)(i.code,{children:"SINGLE_WRITER"}),": Only one active writer to the table. Maximizes throughput."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(i.code,{children:"OPTIMISTIC_CONCURRENCY_CONTROL"}),": Multiple writers can operate on the table with lazy conflict resolution using locks. This means that only one writer succeeds if multiple writers write to the same file group."]}),(0,t.jsxs)("li",{children:[(0,t.jsx)(i.code,{children:"NON_BLOCKING_CONCURRENCY_CONTROL"}),": Multiple writers can operate on the table with non-blocking conflict resolution. The writers can write into the same file group with the conflicts resolved automatically by the query reader and the compactor."]})]}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: WRITE_CONCURRENCY_MODE"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.write.lock.provider"}),(0,t.jsx)(i.td,{children:"org.apache.hudi.client.transaction.lock.ZookeeperBasedLockProvider (Optional)"}),(0,t.jsxs)(i.td,{children:["Lock provider class name, user can provide their own implementation of LockProvider which should be subclass of org.apache.hudi.common.lock.LockProvider",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: LOCK_PROVIDER_CLASS_NAME"}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Since Version: 0.8.0"})]})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"hoodie.cleaner.policy.failed.writes"}),(0,t.jsx)(i.td,{children:"EAGER (Optional)"}),(0,t.jsxs)(i.td,{children:["org.apache.hudi.common.model.HoodieFailedWritesCleaningPolicy: Policy that controls how to clean up failed writes. Hudi will delete any files written by failed writes to re-claim space.     EAGER(default): Clean failed writes inline after every write operation.     LAZY: Clean failed writes lazily after heartbeat timeout when the cleaning service runs. This policy is required when multi-writers are enabled.     NEVER: Never clean failed writes.",(0,t.jsx)("br",{}),(0,t.jsx)("br",{}),(0,t.jsx)(i.code,{children:"Config Param: FAILED_WRITES_CLEANER_POLICY"})]})]})]})]}),"\n",(0,t.jsx)(i.h3,{id:"multi-writing-via-hudi-streamer",children:"Multi Writing via Hudi Streamer"}),"\n",(0,t.jsx)(i.p,{children:"The Hudi Streamer (part of hudi-utilities-slim-bundle) provides ways to ingest from different sources such as DFS or Kafka, with the following capabilities."}),"\n",(0,t.jsx)(i.p,{children:"Using optimistic_concurrency_control via Hudi Streamer requires adding the above configs to the properties file that can be passed to the\njob. For example below, adding the configs to kafka-source.properties file and passing them to Hudi Streamer will enable optimistic concurrency.\nA Hudi Streamer job can then be triggered as follows:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'[hoodie]$ spark-submit \\\n  --jars "packaging/hudi-utilities-slim-bundle/target/hudi-utilities-slim-bundle_2.12-1.1.1.jar,packaging/hudi-spark-bundle/target/hudi-spark3.5-bundle_2.12-1.1.1.jar" \\\n  --class org.apache.hudi.utilities.streamer.HoodieStreamer `ls packaging/hudi-utilities-slim-bundle/target/hudi-utilities-slim-bundle-*.jar` \\\n  --props file://${PWD}/hudi-utilities/src/test/resources/streamer-config/kafka-source.properties \\\n  --schemaprovider-class org.apache.hudi.utilities.schema.SchemaRegistryProvider \\\n  --source-class org.apache.hudi.utilities.sources.AvroKafkaSource \\\n  --source-ordering-field impresssiontime \\\n  --target-base-path file:///tmp/hudi-streamer-op \\ \n  --target-table tableName \\\n  --op BULK_INSERT\n'})}),"\n",(0,t.jsx)(i.h3,{id:"multi-writing-via-spark-datasource-writer",children:"Multi Writing via Spark Datasource Writer"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"hudi-spark"})," module offers the DataSource API to write (and read) a Spark DataFrame into a Hudi table."]}),"\n",(0,t.jsx)(i.p,{children:"Following is an example of how to use optimistic_concurrency_control via spark datasource"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:'inputDF.write.format("hudi")\n       .options(getQuickstartWriteConfigs)\n       .option("hoodie.table.ordering.fields", "ts")\n       .option("hoodie.cleaner.policy.failed.writes", "LAZY")\n       .option("hoodie.write.concurrency.mode", "optimistic_concurrency_control")\n       .option("hoodie.write.lock.zookeeper.url", "zookeeper")\n       .option("hoodie.write.lock.zookeeper.port", "2181")\n       .option("hoodie.write.lock.zookeeper.base_path", "/test")\n       .option("hoodie.datasource.write.recordkey.field", "uuid")\n       .option("hoodie.datasource.write.partitionpath.field", "partitionpath")\n       .option("hoodie.table.name", tableName)\n       .mode(Overwrite)\n       .save(basePath)\n'})}),"\n",(0,t.jsx)(i.h2,{id:"disabling-multi-writing",children:"Disabling Multi Writing"}),"\n",(0,t.jsx)(i.p,{children:"Remove the following settings that were used to enable multi-writer or override with default values."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.concurrency.mode=single_writer\nhoodie.cleaner.policy.failed.writes=EAGER\n"})}),"\n",(0,t.jsx)(i.h2,{id:"occ-best-practices",children:"OCC Best Practices"}),"\n",(0,t.jsx)(i.p,{children:"Concurrent Writing to Hudi tables requires acquiring a lock with one of the lock providers mentioned above. Due to several reasons you might want to configure retries to allow your application to acquire the lock."}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Network connectivity or excessive load on servers increasing time for lock acquisition resulting in timeouts"}),"\n",(0,t.jsx)(i.li,{children:"Running a large number of concurrent jobs that are writing to the same hudi table can result in contention during lock acquisition can cause timeouts"}),"\n",(0,t.jsx)(i.li,{children:"In some scenarios of conflict resolution, Hudi commit operations might take upto 10's of seconds while the lock is being held. This can result in timeouts for other jobs waiting to acquire a lock."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Set the correct native lock provider client retries.:::note\nPlease note that sometimes these settings are set on the server once and all clients inherit the same configs. Please check your settings before enabling optimistic concurrency.\n:::"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.wait_time_ms\nhoodie.write.lock.num_retries\n"})}),"\n",(0,t.jsx)(i.p,{children:"Set the correct hudi client retries for Zookeeper & HiveMetastore. This is useful in cases when native client retry settings cannot be changed. Please note that these retries will happen in addition to any native client retries that you may have set."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-properties",children:"hoodie.write.lock.client.wait_time_ms\nhoodie.write.lock.client.num_retries\n"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.em,{children:"Setting the right values for these depends on a case by case basis; some defaults have been provided for general cases."})}),"\n",(0,t.jsx)(i.h2,{id:"caveats",children:"Caveats"}),"\n",(0,t.jsxs)(i.p,{children:["If you are using the ",(0,t.jsx)(i.code,{children:"WriteClient"})," API, please note that multiple writes to the table need to be initiated from 2 different instances of the write client.\nIt is ",(0,t.jsx)(i.strong,{children:"NOT"})," recommended to use the same instance of the write client to perform multi writing."]}),"\n",(0,t.jsx)(i.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,t.jsx)("h3",{children:"Blogs"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://www.onehouse.ai/blog/lakehouse-concurrency-control-are-we-too-optimistic",children:"Data Lakehouse Concurrency Control"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://medium.com/@simpsons/multi-writer-support-with-apache-hudi-e1b75dca29e6",children:"Multi-writer support with Apache Hudi"})}),"\n"]}),"\n",(0,t.jsx)("h3",{children:"Videos"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"https://youtu.be/JP0orl9_0yQ",children:"Hands on Lab with using DynamoDB as lock table for Apache Hudi Data Lakes"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/blog/2024/12/06/non-blocking-concurrency-control",children:"Non Blocking Concurrency Control Flink Demo"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);