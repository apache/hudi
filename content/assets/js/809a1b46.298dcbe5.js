"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[36689],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=d(a),c=i,m=h["".concat(l,".").concat(c)]||h[c]||u[c]||r;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},42665:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=a(87462),i=(a(67294),a(3905));a(26396),a(58215);const r={title:"Release 0.14.0",sidebar_position:4,layout:"releases",toc:!0},o=void 0,s={unversionedId:"release-0.14.0",id:"release-0.14.0",title:"Release 0.14.0",description:"Release 0.14.0 (docs)",source:"@site/releases/release-0.14.0.md",sourceDirName:".",slug:"/release-0.14.0",permalink:"/releases/release-0.14.0",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Release 0.14.0",sidebar_position:4,layout:"releases",toc:!0},sidebar:"releases",previous:{title:"Release 0.13.1",permalink:"/releases/release-0.13.1"},next:{title:"Release 0.12.3",permalink:"/releases/release-0.12.3"}},l=[{value:"Release 0.14.0 (docs)",id:"release-0140-docs",children:[],level:2},{value:"Migration Guide",id:"migration-guide",children:[{value:"Bundle Updates",id:"bundle-updates",children:[{value:"New Spark Bundles",id:"new-spark-bundles",children:[],level:4}],level:3},{value:"Breaking Changes",id:"breaking-changes",children:[{value:"INSERT INTO behavior with Spark SQL",id:"insert-into-behavior-with-spark-sql",children:[],level:4}],level:3},{value:"Behavior changes",id:"behavior-changes",children:[{value:"Simplified duplicates handling with Inserts in Spark SQL",id:"simplified-duplicates-handling-with-inserts-in-spark-sql",children:[],level:4},{value:"Compaction with MOR table",id:"compaction-with-mor-table",children:[],level:4},{value:"HoodieDeltaStreamer renamed to HoodieStreamer",id:"hoodiedeltastreamer-renamed-to-hoodiestreamer",children:[],level:4},{value:"MERGE INTO JOIN condition",id:"merge-into-join-condition",children:[],level:4}],level:3}],level:2},{value:"Release Highlights",id:"release-highlights",children:[{value:"Record Level Index",id:"record-level-index",children:[],level:3},{value:"Support for Hudi tables with Autogenerated keys",id:"support-for-hudi-tables-with-autogenerated-keys",children:[],level:3},{value:"Spark 3.4 version support",id:"spark-34-version-support",children:[],level:3},{value:"Query side improvements:",id:"query-side-improvements",children:[{value:"Metadata table support with Athena",id:"metadata-table-support-with-athena",children:[],level:4},{value:"Leverage Parquet bloom filters w/ read queries",id:"leverage-parquet-bloom-filters-w-read-queries",children:[],level:4},{value:"Incremental queries with multi-writers",id:"incremental-queries-with-multi-writers",children:[],level:4},{value:"Timestamp support with Hive 3.x",id:"timestamp-support-with-hive-3x",children:[],level:4},{value:"Google BigQuery sync enhancements",id:"google-bigquery-sync-enhancements",children:[],level:4}],level:3},{value:"Spark read side improvements",id:"spark-read-side-improvements",children:[{value:"Snapshot read support for MOR Bootstrap tables",id:"snapshot-read-support-for-mor-bootstrap-tables",children:[],level:4},{value:"Table-valued function named hudi_table_changes designed for incremental reading through Spark SQL",id:"table-valued-function-named-hudi_table_changes-designed-for-incremental-reading-through-spark-sql",children:[],level:4},{value:"New MOR file format reader in Spark:",id:"new-mor-file-format-reader-in-spark",children:[],level:4}],level:3},{value:"Spark write side improvements",id:"spark-write-side-improvements",children:[{value:"Bulk_Insert and row writer enhancements",id:"bulk_insert-and-row-writer-enhancements",children:[],level:4}],level:3},{value:"Hoodie Streamer enhancements",id:"hoodie-streamer-enhancements",children:[{value:"Dynamic configuration updates",id:"dynamic-configuration-updates",children:[],level:4},{value:"SQL File based source for HoodieStreamer",id:"sql-file-based-source-for-hoodiestreamer",children:[],level:4}],level:3},{value:"Flink Enhancements",id:"flink-enhancements",children:[{value:"Consistent hashing index support",id:"consistent-hashing-index-support",children:[],level:4},{value:"Dynamic partition pruning for streaming read",id:"dynamic-partition-pruning-for-streaming-read",children:[],level:4},{value:"Simple bucket index table query speed up (with index fields)",id:"simple-bucket-index-table-query-speed-up-with-index-fields",children:[],level:4},{value:"Flink 1.17 support",id:"flink-117-support",children:[],level:4},{value:"Update deletes statement for Flink",id:"update-deletes-statement-for-flink",children:[],level:4}],level:3},{value:"Java Enhancements",id:"java-enhancements",children:[],level:3}],level:2},{value:"Known Regressions",id:"known-regressions",children:[],level:2},{value:"Raw Release Notes",id:"raw-release-notes",children:[],level:2}],d={toc:l},p="wrapper";function h(e){let{components:t,...a}=e;return(0,i.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"release-0140-docs"},(0,i.kt)("a",{parentName:"h2",href:"https://github.com/apache/hudi/releases/tag/release-0.14.0"},"Release 0.14.0")," (",(0,i.kt)("a",{parentName:"h2",href:"/docs/quick-start-guide"},"docs"),")"),(0,i.kt)("p",null,"Apache Hudi 0.14.0 marks a significant milestone with a range of new functionalities and enhancements.\nThese include the introduction of Record Level Index, automatic generation of record keys, the ",(0,i.kt)("inlineCode",{parentName:"p"},"hudi_table_changes"),"\nfunction for incremental reads, and more. Notably, this release also incorporates support for Spark 3.4. On the Flink\nfront, version 0.14.0 brings several exciting features such as consistent hashing index support, Flink 1.17 support, and\nUpdate and Delete statement support. Additionally, this release upgrades the Hudi table version, prompting users to consult\nthe Migration Guide provided below. We encourage users to review the ",(0,i.kt)("a",{parentName:"p",href:"#release-highlights"},"release highlights"),",\n",(0,i.kt)("a",{parentName:"p",href:"#breaking-changes"},"breaking changes"),", and ",(0,i.kt)("a",{parentName:"p",href:"#behavior-changes"},"behavior changes")," before\nadopting the 0.14.0 release."),(0,i.kt)("h2",{id:"migration-guide"},"Migration Guide"),(0,i.kt)("p",null,'In version 0.14.0, we\'ve made changes such as the removal of compaction plans from the ".aux" folder and the introduction\nof a new log block version. As part of this release, the table version is updated to version ',(0,i.kt)("inlineCode",{parentName:"p"},"6"),". When running a Hudi job\nwith version 0.14.0 on a table with an older table version, an automatic upgrade process is triggered to bring the table\nup to version ",(0,i.kt)("inlineCode",{parentName:"p"},"6"),". This upgrade is a one-time occurrence for each Hudi table, as the ",(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.table.version")," is updated in\nthe property file upon completion of the upgrade. Additionally, a command-line tool for downgrading has been included,\nallowing users to move from table version ",(0,i.kt)("inlineCode",{parentName:"p"},"6")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),", or revert from Hudi 0.14.0 to a version prior to 0.14.0. To use this\ntool, execute it from a 0.14.0 environment. For more details, refer to the\n",(0,i.kt)("a",{parentName:"p",href:"/docs/cli/#upgrade-and-downgrade-table"},"hudi-cli"),"."),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"If migrating from an older release (pre 0.14.0), please also check the upgrade instructions from each older release in\nsequence."))),(0,i.kt)("h3",{id:"bundle-updates"},"Bundle Updates"),(0,i.kt)("h4",{id:"new-spark-bundles"},"New Spark Bundles"),(0,i.kt)("p",null,"In this release, we've expanded our support to include bundles for both Spark 3.4\n(",(0,i.kt)("a",{parentName:"p",href:"https://mvnrepository.com/artifact/org.apache.hudi/hudi-spark3.4-bundle_2.12"},"hudi-spark3.4-bundle_2.12"),")\nand Spark 3.0 (",(0,i.kt)("a",{parentName:"p",href:"https://mvnrepository.com/artifact/org.apache.hudi/hudi-spark3.0-bundle_2.12"},"hudi-spark3.0-bundle_2.12"),").\nPlease note that, the support for Spark 3.0 had been discontinued after Hudi version 0.10.1, but due to strong community\ninterest, it has been reinstated in this release."),(0,i.kt)("h3",{id:"breaking-changes"},"Breaking Changes"),(0,i.kt)("h4",{id:"insert-into-behavior-with-spark-sql"},"INSERT INTO behavior with Spark SQL"),(0,i.kt)("p",null,"Before version 0.14.0, data ingested through ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT INTO")," in Spark SQL followed the upsert flow, where multiple versions\nof records would be merged into one version. However, starting from 0.14.0, we've altered the default behavior of\n",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT INTO")," to utilize the ",(0,i.kt)("inlineCode",{parentName:"p"},"insert")," flow internally. This change significantly enhances write performance as it\nbypasses index lookups."),(0,i.kt)("p",null,"If a table is created with a ",(0,i.kt)("em",{parentName:"p"},"preCombine")," key, the default operation for ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT INTO")," remains as ",(0,i.kt)("inlineCode",{parentName:"p"},"upsert"),". Conversely,\nif no ",(0,i.kt)("em",{parentName:"p"},"preCombine")," key is set, the underlying write operation for ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT INTO")," defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"insert"),". Users have the\nflexibility to override this behavior by explicitly setting values for the config\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiesparksqlinsertintooperation"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.spark.sql.insert.into.operation")),"\nas per their requirements. Possible values for this config include ",(0,i.kt)("inlineCode",{parentName:"p"},"insert"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"bulk_insert"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"upsert"),"."),(0,i.kt)("p",null,"Additionally, in version 0.14.0, we have ",(0,i.kt)("strong",{parentName:"p"},"deprecated")," two related older configs:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hoodie.sql.insert.mode")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hoodie.sql.bulk.insert.enable"),".")),(0,i.kt)("h3",{id:"behavior-changes"},"Behavior changes"),(0,i.kt)("h4",{id:"simplified-duplicates-handling-with-inserts-in-spark-sql"},"Simplified duplicates handling with Inserts in Spark SQL"),(0,i.kt)("p",null,"In cases where the operation type is configured as ",(0,i.kt)("inlineCode",{parentName:"p"},"insert")," for the Spark SQL ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT INTO")," flow, users now have the\noption to enforce a duplicate policy using the configuration setting\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiedatasourceinsertduppolicy"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.datasource.insert.dup.policy")),".\nThis policy determines the action taken when incoming records being ingested already exist in storage. The available\nvalues for this configuration are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"none"),": No specific action is taken, allowing duplicates to exist in the Hudi table if the incoming records contain duplicates."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drop"),": Matching records from the incoming writes will be dropped, and the remaining ones will be ingested."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fail"),": The write operation will fail if the same records are re-ingested. In essence, a given record, as determined\nby the key generation policy, can only be ingested once into the target table.")),(0,i.kt)("p",null,"With this addition, an older related configuration setting,\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiedatasourcewriteinsertdropduplicates"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.datasource.write.insert.drop.duplicates")),",\nis now deprecated. The newer configuration will take precedence over the old one when both are specified. If no specific\nconfigurations are provided, the default value for the newer configuration will be assumed. Users are strongly encouraged\nto migrate to the use of these newer configurations. "),(0,i.kt)("h4",{id:"compaction-with-mor-table"},"Compaction with MOR table"),(0,i.kt)("p",null,"For Spark batch writers (both the Spark datasource and Spark SQL), compaction is automatically enabled by default for\nMOR (Merge On Read) tables, unless users explicitly override this behavior. Users have the option to disable compaction\nexplicitly by setting ",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiecompactinline"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.compact.inline"))," to false.\nIn case users do not override this configuration, compaction may be triggered for MOR tables approximately once every\n5 delta commits (the default value for\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiecompactinlinemaxdeltacommits"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.compact.inline.max.delta.commits")),")."),(0,i.kt)("h4",{id:"hoodiedeltastreamer-renamed-to-hoodiestreamer"},"HoodieDeltaStreamer renamed to HoodieStreamer"),(0,i.kt)("p",null,"Starting from version 0.14.0, we have renamed ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/blob/84a80e21b5f0cdc1f4a33957293272431b221aa9/hudi-utilities/src/main/java/org/apache/hudi/utilities/deltastreamer/HoodieDeltaStreamer.java"},"HoodieDeltaStreamer"),"\nto ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/blob/84a80e21b5f0cdc1f4a33957293272431b221aa9/hudi-utilities/src/main/java/org/apache/hudi/utilities/streamer/HoodieStreamer.java"},"HoodieStreamer"),".\nWe have ensured backward compatibility so that existing user jobs remain unaffected. However, in upcoming\nreleases, support for Deltastreamer might be discontinued. Hence, we strongly advise users to transition to using\nHoodieStreamer instead."),(0,i.kt)("h4",{id:"merge-into-join-condition"},"MERGE INTO JOIN condition"),(0,i.kt)("p",null,"Starting from version 0.14.0, Hudi has the capability to automatically generate primary record keys when users do not\nprovide explicit specifications. This enhancement enables the ",(0,i.kt)("inlineCode",{parentName:"p"},"MERGE INTO JOIN")," clause to reference any data column for\nthe join condition in Hudi tables where the primary keys are generated by Hudi itself. However, in cases where users\nconfigure the primary record key, the join condition still expects the primary key fields as specified by the user."),(0,i.kt)("h2",{id:"release-highlights"},"Release Highlights"),(0,i.kt)("h3",{id:"record-level-index"},"Record Level Index"),(0,i.kt)("p",null,"Hudi version 0.14.0, introduces a new index implementation -",(0,i.kt)("br",{parentName:"p"}),"\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/blob/master/rfc/rfc-8/rfc-8.md#rfc-8-metadata-based-record-index"},"Record Level Index"),".\nThe Record level Index significantly enhances write performance for large tables by efficiently storing per-record\nlocations and enabling swift retrieval during index lookup operations. It can effectively replace other\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/next/indexing#global-and-non-global-indexes"},"Global indices")," like Global_bloom,\nGlobal_Simple, or Hbase, commonly used in Hudi."),(0,i.kt)("p",null,"Bloom and Simple Indexes exhibit slower performance for large datasets due to the high costs associated with gathering\nindex data from various data files during lookup. Moreover, these indexes do not preserve a one-to-one record-key to\nrecord file path mapping; instead, they deduce the mapping through an optimized search at lookup time. The per-file\noverhead required by these indexes makes them less effective for datasets with a larger number of files or records."),(0,i.kt)("p",null,"On the other hand, the Hbase Index saves a one-to-one mapping for each record key, resulting in fast performance that\nscales with the dataset size. However, it necessitates a separate HBase cluster for maintenance, which is operationally\nchallenging and resource-intensive, requiring specialized expertise."),(0,i.kt)("p",null,"The Record Index combines the speed and scalability of the HBase Index without its limitations and overhead. Being a\npart of the HUDI Metadata Table, any future performance enhancements in writes and queries will automatically translate\ninto improved performance for the Record Index. Adopting the Record Level Index has the potential to boost index lookup\nperformance by 4 to 10 times, depending on the workload, even for extremely large-scale datasets (e.g., 1TB)."),(0,i.kt)("p",null,"With the Record Level Index, significant performance improvements can be observed for large datasets, as latency is\ndirectly proportional to the amount of data being ingested. This is in contrast to other Global indices where index\nlookup time increases linearly with the table size. The Record Level Index is specifically designed to efficiently\nhandle lookups for such large-scale data without a linear increase in lookup times as the table size grows."),(0,i.kt)("p",null,"To harness the benefits of this lightning-fast index, users need to enable two configurations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://hudi.apache.org/docs/next/configurations#hoodiemetadatarecordindexenable"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.metadata.record.index.enable"))," must be enabled to write the Record Level Index to the metadata table."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hoodie.index.type")," needs to be set to ",(0,i.kt)("inlineCode",{parentName:"li"},"RECORD_INDEX")," for the index lookup to utilize the Record Level Index.")),(0,i.kt)("h3",{id:"support-for-hudi-tables-with-autogenerated-keys"},"Support for Hudi tables with Autogenerated keys"),(0,i.kt)("p",null,"Since the initial official version of Hudi, the primary key was a mandatory field that users needed to configure for any\nHudi table. Starting 0.14.0, we are relaxing this constraint. This enhancement addresses a longstanding need within the\ncommunity, where certain use-cases didn't naturally possess an intrinsic primary key. Version 0.14.0 now offers the\nflexibility for users to create a Hudi table without the need to explicitly configure a primary key (by omitting the\nconfiguration setting -\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiedatasourcewriterecordkeyfield"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.datasource.write.recordkey.field")),").\nHudi will ",(0,i.kt)("strong",{parentName:"p"},"automatically generate the primary keys")," in such cases. This feature is applicable only for new tables and\ncannot be altered for existing ones."),(0,i.kt)("p",null,"This functionality is available in all spark writers with certain limitations. For append only type of use cases, Inserts and\nbulk_inserts are allowed with all four writers - Spark Datasource, Spark SQL, Spark Streaming, Hoodie Streamer. Updates and\nDeletes are supported only using spark-sql ",(0,i.kt)("inlineCode",{parentName:"p"},"MERGE INTO")," , ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DELETE")," statements. With Spark Datasource, ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"DELETE")," are supported only when the source dataframe contains Hudi's meta fields. Please check out our\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/quick-start-guide"},"quick start guide")," for code snippets on Hudi table CRUD operations where\nkeys are autogenerated."),(0,i.kt)("h3",{id:"spark-34-version-support"},"Spark 3.4 version support"),(0,i.kt)("p",null,"Spark 3.4 support is added; users who are on Spark 3.4 can use\n",(0,i.kt)("a",{parentName:"p",href:"https://mvnrepository.com/artifact/org.apache.hudi/hudi-spark3.4-bundle"},"hudi-spark3.4-bundle"),". Spark 3.2, Spark 3.1,\nSpark3.0 and Spark 2.4 will continue to be supported. Please check the migration guide for bundle updates. To quickly get\nstarted with Hudi and Spark 3.4, you can explore our ",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/quick-start-guide"},"quick start guide"),"."),(0,i.kt)("h3",{id:"query-side-improvements"},"Query side improvements:"),(0,i.kt)("h4",{id:"metadata-table-support-with-athena"},"Metadata table support with Athena"),(0,i.kt)("p",null,"Users now have the ability to utilize Hudi\u2019s ",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/metadata/"},"Metadata table"),' seamlessly with Athena.\nThe file listing index removes the need for recursive file system calls like "list files" by retrieving information\nfrom an index that maintains a mapping of partitions to files. This approach proves to be highly efficient, particularly\nwhen dealing with extensive datasets. With Hudi 0.14.0, users can activate file listing based on the metadata table when\nperforming Glue catalog synchronization for their Hudi tables. To enable this functionality, users can configure\n',(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.datasource.meta.sync.glue.metadata_file_listing")," and set it to true during the Glue sync process."),(0,i.kt)("h4",{id:"leverage-parquet-bloom-filters-w-read-queries"},"Leverage Parquet bloom filters w/ read queries"),(0,i.kt)("p",null,"In Hudi 0.14.0, users can now utilize the native\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/parquet-format/blob/1603152f8991809e8ad29659dffa224b4284f31b/BloomFilter.md"},"Parquet bloom filters"),",\nprovided their compute engine supports Apache Parquet 1.12.0 or higher. This support covers both the writing and reading\nof datasets. Hudi facilitates the use of native Parquet bloom filters through Hadoop configuration. Users are required\nto set a Hadoop configuration with a specific key representing the column for which the bloom filter is to be applied.\nFor example, ",(0,i.kt)("inlineCode",{parentName:"p"},"parquet.bloom.filter.enabled#rider=true")," creates a bloom filter for the rider column. Whenever a query\ninvolves a predicate on the rider column, the bloom filter comes into play, enhancing read performance."),(0,i.kt)("h4",{id:"incremental-queries-with-multi-writers"},"Incremental queries with multi-writers"),(0,i.kt)("p",null,"In multi-writer scenarios, there can be instances of gaps in the timeline (requests or inflight instants that are not\nthe latest instant) due to concurrent writing activities. These gaps may result in inconsistent outcomes when\nperforming incremental queries. To address this issue, Hudi 0.14.0 introduces a new configuration setting,\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiereadtimelineholesresolutionpolicy"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.read.timeline.holes.resolution.policy")),",\nspecifically designed for handling these inconsistencies in incremental queries. The configuration provides three possible policies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"FAIL"),": This serves as the default policy and throws an exception when such timeline gaps are identified during an incremental query."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"BLOCK"),": In this policy, the results of an incremental query are limited to the time range between the holes in the\ntimeline. For instance, if a gap is detected at instant t1 within the incremental query range from t0 to t2, the\nquery will only display results between t0 and t1 without failing."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"USE_TRANSITION_TIME"),": This policy is experimental and involves using the state transition time, which is based on the\nfile modification time of commit metadata files in the timeline, during the incremental query.")),(0,i.kt)("h4",{id:"timestamp-support-with-hive-3x"},"Timestamp support with Hive 3.x"),(0,i.kt)("p",null,"For quite some time, Hudi users encountered ",(0,i.kt)("a",{parentName:"p",href:"https://issues.apache.org/jira/browse/HUDI-83"},"challenges")," regarding reading Timestamp type columns written by Spark and\nsubsequently attempting to read them with Hive 3.x. While in Hudi 0.13.x, we introduced a\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/commit/cd314b8cfa58c32f731f7da2aa6377a09df4c6f9#diff-cff4dfc264f7abcac63a5ba5db55b38115177fe279ab35807d345c2b8872475e"},"workaround"),"\nto mitigate this issue, version 0.14.0 now ensures full compatibility of HiveAvroSerializer with Hive 3.x to resolve this."),(0,i.kt)("h4",{id:"google-bigquery-sync-enhancements"},"Google BigQuery sync enhancements"),(0,i.kt)("p",null,"With 0.14.0, the ",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/gcp_bigquery"},"BigQuerySyncTool")," supports syncing table to BigQuery\nusing ",(0,i.kt)("a",{parentName:"p",href:"https://cloud.google.com/blog/products/data-analytics/bigquery-manifest-file-support-for-open-table-format-queries"},"manifests"),".\nThis is expected to have better query performance compared to legacy way. Schema evolution is supported with the manifest approach.\nPartition column no longer needs to be dropped from the files due to new schema handling improvements. To enable this\nfeature, users can set\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiegcpbigquerysyncuse_bq_manifest_file"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.gcp.bigquery.sync.use_bq_manifest_file")),"\nto true."),(0,i.kt)("h3",{id:"spark-read-side-improvements"},"Spark read side improvements"),(0,i.kt)("h4",{id:"snapshot-read-support-for-mor-bootstrap-tables"},"Snapshot read support for MOR Bootstrap tables"),(0,i.kt)("p",null,"With 0.14.0, MOR snapshot read support is added for Bootstrapped tables. The default behavior has been changed in several\nways to match the behavior of non-bootstrapped MOR tables. Snapshot reads will now be the default reading mode. Use\n",(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.datasource.query.type=read_optimized")," for read optimized queries which was previously the default behavior.\nHive sync for such tables will result in both _ro and _rt suffixed to the table name to signify read optimized and snapshot\nreading respectively."),(0,i.kt)("h4",{id:"table-valued-function-named-hudi_table_changes-designed-for-incremental-reading-through-spark-sql"},"Table-valued function named hudi_table_changes designed for incremental reading through Spark SQL"),(0,i.kt)("p",null,"Hudi offers the functionality to fetch a stream of records changed since a specified commit timestamp through the ",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/quick-start-guide#incremental-query"},"incremental query")," type. With the release of Hudi 0.14.0, we've introduced a more straightforward method to access the most recent state or change streams of Hudi datasets. This is achieved using a table-valued function named ",(0,i.kt)("inlineCode",{parentName:"p"},"hudi_table_changes")," in Spark SQL. Here's the syntax and several examples of how to utilize this function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"SYNTAX\nhudi_table_changes(table, queryType, beginTime [, endTime]);\n-- table: table identifier, example: db.tableName, tableName, or path for the table, example: hdfs://path/to/hudiTable.\n-- queryType: incremental query mode, valid values: latest_state, cdc\n(for cdc query, first enable cdc for the table by setting cdc.enabled=true),\n-- beginTime: instantTime to begin query from, example: earliest, 202305150000,\n-- endTime: optional instantTime to end query at, example: 202305160000,\n\nEXAMPLES\n-- incrementally query data by table name\n-- start from earliest available commit, end at latest available commit.\nSELECT * FROM hudi_table_changes('db.table', 'latest_state', 'earliest');\n\n-- start from earliest, end at 202305160000.\nSELECT * FROM hudi_table_changes('table', 'latest_state', 'earliest', '202305160000');\n\n-- incrementally query data by path\n-- start from earliest available commit, end at latest available commit.\nSELECT * FROM hudi_table_changes('path/to/table', 'cdc', 'earliest');\n")),(0,i.kt)("p",null,"Checkout the ",(0,i.kt)("a",{parentName:"p",href:"/docs/quick-start-guide#incremental-query"},"quickstart")," for more examples."),(0,i.kt)("h4",{id:"new-mor-file-format-reader-in-spark"},"New MOR file format reader in Spark:"),(0,i.kt)("p",null,"Based on a proposal from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/pull/9235"},"RFC-72")," aimed at redesigning Hudi-Spark integration,\nwe are introducing an experimental file format reader for MOR (Merge On Read) tables. This reader is expected to\nsignificantly reduce read latencies by 20 to 40% when compared to the older file format, particularly for snapshot and\nbootstrap queries. The goal is to bring the latencies closer to those of the COW (Copy On Write) file format. To utilize\nthis new file format, users need to set ",(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.datasource.read.use.new.parquet.file.format=true"),". It's important to note\nthat this feature is still experimental and comes with a few limitations. For more details and if you're interested in\ncontributing, please refer to ",(0,i.kt)("a",{parentName:"p",href:"https://issues.apache.org/jira/browse/HUDI-6568"},"HUDI-6568"),"."),(0,i.kt)("h3",{id:"spark-write-side-improvements"},"Spark write side improvements"),(0,i.kt)("h4",{id:"bulk_insert-and-row-writer-enhancements"},"Bulk_Insert and row writer enhancements"),(0,i.kt)("p",null,"The 0.14.0 release provides support for using bulk insert operation while performing SQL operations like ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT OVERWRITE TABLE"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT OVERWRITE PARTITION"),". To enable bulk insert, set config\n",(0,i.kt)("a",{parentName:"p",href:"https://hudi.apache.org/docs/configurations#hoodiesparksqlinsertintooperation"},(0,i.kt)("inlineCode",{parentName:"a"},"hoodie.spark.sql.insert.into.operation")),"\nto value ",(0,i.kt)("inlineCode",{parentName:"p"},"bulk_insert"),". Bulk insert has better write performance compared to insert operation. Row writer support is\nalso added for Simple bucket index."),(0,i.kt)("h3",{id:"hoodie-streamer-enhancements"},"Hoodie Streamer enhancements"),(0,i.kt)("h4",{id:"dynamic-configuration-updates"},"Dynamic configuration updates"),(0,i.kt)("p",null,"When Hoodie Streamer is run in continuous mode, the properties can be refreshed/updated before each sync calls.\nInterested users can implement ",(0,i.kt)("inlineCode",{parentName:"p"},"org.apache.hudi.utilities.deltastreamer.ConfigurationHotUpdateStrategy")," to leverage this."),(0,i.kt)("h4",{id:"sql-file-based-source-for-hoodiestreamer"},"SQL File based source for HoodieStreamer"),(0,i.kt)("p",null,"A new source - ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/hudi/blob/30146d61f5544f06e2100234b9bf9c5e4bc2a97f/hudi-utilities/src/main/java/org/apache/hudi/utilities/sources/SqlFileBasedSource.java"},"SqlFileBasedSource"),",\nhas been added to HoodieStreamer designed to facilitate one-time backfill scenarios."),(0,i.kt)("h3",{id:"flink-enhancements"},"Flink Enhancements"),(0,i.kt)("p",null,"Below are the Flink Engine based enhancements in the 0.14.0 release."),(0,i.kt)("h4",{id:"consistent-hashing-index-support"},"Consistent hashing index support"),(0,i.kt)("p",null,"In comparison to the static hashing index (BUCKET index), the consistent hashing index offers dynamic scalability of\ndata buckets for the writer. To utilize this feature, configure the option ",(0,i.kt)("inlineCode",{parentName:"p"},"index.type")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"BUCKET")," and set\n",(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.index.bucket.engine")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"CONSISTENT_HASHING"),"."),(0,i.kt)("p",null,"When enabling the consistent hashing index, it's important to activate asynchronous clustering scheduling within the writer.\nThe clustering plan should be executed through an offline job. During this process, the writer will perform dual writes\nfor both the old and new data buckets while the clustering is pending. Although the dual write does not impact correctness,\nit is strongly recommended to execute clustering as quickly as possible."),(0,i.kt)("h4",{id:"dynamic-partition-pruning-for-streaming-read"},"Dynamic partition pruning for streaming read"),(0,i.kt)("p",null,"Before 0.14.0, the Flink streaming reader can not prune the datetime partitions correctly when the queries have\npredicates with constant datetime filtering. Since this release, the Flink streaming queries have been fixed to support\nany pattern of filtering predicates, including but not limited to the datetime filtering."),(0,i.kt)("h4",{id:"simple-bucket-index-table-query-speed-up-with-index-fields"},"Simple bucket index table query speed up (with index fields)"),(0,i.kt)("p",null,"For a simple bucket index table, if the query takes equality filtering predicates on index key fields, Flink engine\nwould optimize the planning to only include the source data files from a very specific data bucket; such queries expect\nto have nearly ",(0,i.kt)("inlineCode",{parentName:"p"},"hoodie.bucket.index.num.buckets")," times performance improvement in average."),(0,i.kt)("h4",{id:"flink-117-support"},"Flink 1.17 support"),(0,i.kt)("p",null,"Flink 1.17 is supported with a new compile maven profile ",(0,i.kt)("inlineCode",{parentName:"p"},"flink1.17"),", adding profile ",(0,i.kt)("inlineCode",{parentName:"p"},"-Pflink1.17")," in the compile cmd of\nFlink Hudi bundle jar to enable the integration with Flink 1.17."),(0,i.kt)("h4",{id:"update-deletes-statement-for-flink"},"Update deletes statement for Flink"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DELETE")," statements have been integrated since this release for batch queries. Current only table that\ndefines primary keys can handle the statement correctly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"UPDATE hudi_table SET ... WHERE ...\nDELETE FROM hudi_table WHERE ...\n\nEXAMPLES\n-- update the specific records with constant age\nUPDATE hudi_table SET age=19 WHERE UUID in ('id1', 'id2');\n-- delete all the records that with age greater than 23\nDELETE FROM hudi_table WHERE age > 23;\n")),(0,i.kt)("h3",{id:"java-enhancements"},"Java Enhancements"),(0,i.kt)("p",null,"Lot of write operations have been extended to support Java engine to bring it to parity with other engines. For eg,\ncompaction, clustering, and metadata table support has been added to Java Engine with 0.14.0."),(0,i.kt)("h2",{id:"known-regressions"},"Known Regressions"),(0,i.kt)("p",null,"In Hudi 0.14.0, when querying a table that uses ComplexKeyGenerator or CustomKeyGenerator, partition values are returned\nas string. Note that there is no type change on the storage i.e. partition fields are written in the user-defined type\non storage. However, this is a breaking change for the aforementioned key generators and will be fixed in 0.14.1 -\n",(0,i.kt)("a",{parentName:"p",href:"https://issues.apache.org/jira/browse/HUDI-6914"},"HUDI-6914")),(0,i.kt)("h2",{id:"raw-release-notes"},"Raw Release Notes"),(0,i.kt)("p",null,"The raw release notes are available ",(0,i.kt)("a",{parentName:"p",href:"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12322822&version=12352700"},"here"),"."))}h.isMDXComponent=!0},58215:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(67294);const i=function(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",hidden:a,className:i},t)}},26396:(e,t,a)=>{a.d(t,{Z:()=>u});var n=a(87462),i=a(67294),r=a(72389),o=a(79443);const s=function(){const e=(0,i.useContext)(o.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e};var l=a(53810),d=a(86010);const p={tabItem:"tabItem_vU9c"};function h(e){const{lazy:t,block:a,defaultValue:r,values:o,groupId:h,className:u}=e,c=i.Children.map(e.children,(e=>{if((0,i.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),m=o??c.map((e=>{let{props:{value:t,label:a,attributes:n}}=e;return{value:t,label:a,attributes:n}})),f=(0,l.lx)(m,((e,t)=>e.value===t.value));if(f.length>0)throw new Error(`Docusaurus error: Duplicate values "${f.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===r?r:r??c.find((e=>e.props.default))?.props.value??c[0]?.props.value;if(null!==g&&!m.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${m.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:k,setTabGroupChoices:b}=s(),[v,y]=(0,i.useState)(g),w=[],{blockElementScrollPositionUntilNextRender:N}=(0,l.o5)();if(null!=h){const e=k[h];null!=e&&e!==v&&m.some((t=>t.value===e))&&y(e)}const x=e=>{const t=e.currentTarget,a=w.indexOf(t),n=m[a].value;n!==v&&(N(t),y(n),null!=h&&b(h,n))},T=e=>{let t=null;switch(e.key){case"ArrowRight":{const a=w.indexOf(e.currentTarget)+1;t=w[a]||w[0];break}case"ArrowLeft":{const a=w.indexOf(e.currentTarget)-1;t=w[a]||w[w.length-1];break}}t?.focus()};return i.createElement("div",{className:"tabs-container"},i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,d.Z)("tabs",{"tabs--block":a},u)},m.map((e=>{let{value:t,label:a,attributes:r}=e;return i.createElement("li",(0,n.Z)({role:"tab",tabIndex:v===t?0:-1,"aria-selected":v===t,key:t,ref:e=>w.push(e),onKeyDown:T,onFocus:x,onClick:x},r,{className:(0,d.Z)("tabs__item",p.tabItem,r?.className,{"tabs__item--active":v===t})}),a??t)}))),t?(0,i.cloneElement)(c.filter((e=>e.props.value===v))[0],{className:"margin-vert--md"}):i.createElement("div",{className:"margin-vert--md"},c.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==v})))))}function u(e){const t=(0,r.Z)();return i.createElement(h,(0,n.Z)({key:String(t)},e))}}}]);