"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[31536],{2090:e=>{e.exports=JSON.parse('{"permalink":"/blog/2025/10/29/deep-dive-into-hudis-indexing-subsystem-part-1-of-2","editUrl":"https://github.com/apache/hudi/edit/asf-site/website/blog/blog/2025-10-29-deep-dive-into-hudis-indexing-subsystem-part-1-of-2.md","source":"@site/blog/2025-10-29-deep-dive-into-hudis-indexing-subsystem-part-1-of-2.md","title":"Deep Dive Into Hudi\u2019s Indexing Subsystem (Part 1 of 2)","description":"For decades, databases have relied on indexes\u2014specialized data structures\u2014to dramatically improve read and write performance by quickly locating specific records. Apache Hudi extends this fundamental principle to the data lakehouse with a unique and powerful approach. Every Hudi table contains a self-managed metadata table that functions as an indexing subsystem, enabling efficient data skipping and fast record lookups across a wide range of read and write scenarios.","date":"2025-10-29T00:00:00.000Z","tags":[{"inline":true,"label":"hudi","permalink":"/blog/tags/hudi"},{"inline":true,"label":"indexing","permalink":"/blog/tags/indexing"},{"inline":true,"label":"data lakehouse","permalink":"/blog/tags/data-lakehouse"},{"inline":true,"label":"data skipping","permalink":"/blog/tags/data-skipping"}],"readingTime":11.99,"hasTruncateMarker":false,"authors":[{"name":"Shiyan Xu","key":null,"page":null}],"frontMatter":{"title":"Deep Dive Into Hudi\u2019s Indexing Subsystem (Part 1 of 2)","excerpt":"","author":"Shiyan Xu","category":"blog","image":"/assets/images/blog/2025-10-29-deep-dive-into-hudis-indexing-subsystem-part-1-of-2/fig1.png","tags":["hudi","indexing","data lakehouse","data skipping"]},"unlisted":false,"prevItem":{"title":"How FreeWheel Uses Apache Hudi to Power Its Data Lakehouse","permalink":"/blog/2025/11/07/how-freewheel-uses-apache-hudi-to-power-its-data-lakehouse"},"nextItem":{"title":"Partition Stats: Enhancing Column Stats in Hudi 1.0","permalink":"/blog/2025/10/22/Partition_Stats_Enhancing_Column_Stats_in_Hudi_1.0"}}')},19980:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig4-d28ef18dd51d094cfb34e8bae0e65420.png"},20086:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var a=i(2090),n=i(74848),s=i(28453);const o={title:"Deep Dive Into Hudi\u2019s Indexing Subsystem (Part 1 of 2)",excerpt:"",author:"Shiyan Xu",category:"blog",image:"/assets/images/blog/2025-10-29-deep-dive-into-hudis-indexing-subsystem-part-1-of-2/fig1.png",tags:["hudi","indexing","data lakehouse","data skipping"]},r=void 0,l={authorsImageUrls:[void 0]},d=[{value:"The Metadata Table",id:"the-metadata-table",level:2},{value:"Multimodal indexing",id:"multimodal-indexing",level:3},{value:"HFile format",id:"hfile-format",level:3},{value:"Default behaviors",id:"default-behaviors",level:3},{value:"Data Skipping with Files, Column Stats, and Partition Stats",id:"data-skipping-with-files-column-stats-and-partition-stats",level:2},{value:"The data skipping process",id:"the-data-skipping-process",level:3},{value:"SQL examples",id:"sql-examples",level:3},{value:"Only the files index",id:"only-the-files-index",level:4},{value:"Enabling column stats",id:"enabling-column-stats",level:4},{value:"Enabling column stats and partition stats",id:"enabling-column-stats-and-partition-stats",level:4},{value:"Configure relevant columns to be indexed",id:"configure-relevant-columns-to-be-indexed",level:3},{value:"Key Takeaways and What&#39;s Next",id:"key-takeaways-and-whats-next",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"For decades, databases have relied on indexes\u2014specialized data structures\u2014to dramatically improve read and write performance by quickly locating specific records. Apache Hudi extends this fundamental principle to the data lakehouse with a unique and powerful approach. Every Hudi table contains a self-managed metadata table that functions as an indexing subsystem, enabling efficient data skipping and fast record lookups across a wide range of read and write scenarios."}),"\n",(0,n.jsxs)(t.p,{children:["This two-part series dives into Hudi\u2019s indexing subsystem. Part 1 explains the internal layout and data-skipping capabilities. ",(0,n.jsx)(t.a,{href:"https://hudi.apache.org/blog/2025/11/12/deep-dive-into-hudis-indexing-subsystem-part-2-of-2/",children:"Part 2"})," covers advanced features\u2014record, secondary, and expression indexes\u2014and asynchronous index maintenance. By the end, you\u2019ll know how to leverage Hudi\u2019s multimodal index to build more efficient lakehouse tables."]}),"\n",(0,n.jsx)(t.h2,{id:"the-metadata-table",children:"The Metadata Table"}),"\n",(0,n.jsx)(t.p,{children:"Within a Hudi table (the data table), the metadata table itself is a Hudi Merge-on-Read (MOR) table. Unlike a typical data table, it features a specialized layout. The table is physically partitioned by index type, with each partition containing the relevant index entries. For its physical storage, the metadata table uses HFile as the base file format. This choice is deliberate: HFile is exceptionally efficient at handling key lookups\u2014the predominant query pattern for indexing. Let\u2019s explore the partitioned layout and HFile\u2019s internal structure."}),"\n",(0,n.jsx)(t.h3,{id:"multimodal-indexing",children:"Multimodal indexing"}),"\n",(0,n.jsx)(t.p,{children:"The metadata table is often referred to as a multimodal index because it houses a diverse range of index types, providing versatile capabilities to accelerate various query patterns. The following diagram illustrates the layout of the metadata table and its relationship with the main data table."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Metadata table and data table layout",src:i(53233).A+"",width:"956",height:"650"})}),"\n",(0,n.jsxs)(t.p,{children:["The metadata table is located in the ",(0,n.jsx)(t.code,{children:".hoodie/metadata/"})," directory under the data table\u2019s base path. It contains partitions for different indexes, such as the files index (under the ",(0,n.jsx)(t.code,{children:"files/"})," partition) for tracking the data table\u2019s partitions and files, and the column stats index (under the ",(0,n.jsx)(t.code,{children:"column_stats/"})," partition) for tracking file-level statistics (e.g., min/max values) for specific columns. Each index partition stores mapping entries tailored to its specific purpose."]}),"\n",(0,n.jsxs)(t.p,{children:["This partitioned design provides great flexibility, allowing you to enable only the indexes that suit your workload. It also ensures extensibility, making it straightforward to support new index types in the future. For example, the ",(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/rfc/rfc-92/rfc-92.md",children:"bitmap index"})," and the vector search index are on the ",(0,n.jsx)(t.a,{href:"https://hudi.apache.org/roadmap",children:"roadmap"})," and will be maintained in their own dedicated partitions."]}),"\n",(0,n.jsx)(t.p,{children:"When committing to a data table, the metadata table is updated within the same transactional write. This crucial step ensures that index entries are always synchronized with data table records, upholding data integrity across the table. Therefore, choosing Merge-on-Read (MOR) as the table type for the metadata table is an obvious choice. MOR offers the advantage of absorbing high-frequency write operations, preventing the metadata table\u2019s update process from becoming a bottleneck for overall table writes. To ensure efficient reading, Hudi automatically performs compaction on the metadata table based on its compaction configuration. By default, an inline compaction will be executed every 10 writes to the metadata table, merging accumulated log files with base files to produce a new set of read-optimized base files in HFile format."}),"\n",(0,n.jsx)(t.h3,{id:"hfile-format",children:"HFile format"}),"\n",(0,n.jsxs)(t.p,{children:["The HFile format stores key-value pairs in a sorted, immutable, and block-indexed way, modeled after Google\u2019s SSTable introduced by the ",(0,n.jsx)(t.a,{href:"https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf",children:"Bigtable paper"}),". Here is the description of SSTable quoted from the paper:"]}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"An SSTable provides a persistent, ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. Operations are provided to look up the value associated with a specified key, and to iterate over all key/value pairs in a specified key range. Internally, each SSTable contains a sequence of blocks (typically each block is 64KB in size, but this is configurable). A block index (stored at the end of the SSTable) is used to locate blocks; the index is loaded into memory when the SSTable is opened. A lookup can be performed with a single disk seek: we first find the appropriate block by performing a binary search in the in-memory index, and then reading the appropriate block from disk."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"As you can tell, by implementing the SSTable, HFile is especially efficient at performing random access, which is the primary query pattern for indexing\u2014given a specific piece of information, like a record key or a partition value, return matching results, such as the file ID that contains the record key, or the list of files that belong to the partition."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"HFile structure",src:i(32122).A+"",width:"647",height:"594"})}),"\n",(0,n.jsx)(t.p,{children:"Because the keys in an HFile are stored in lexicographic order, a batched lookup with a common key prefix is also highly efficient, requiring only a sequential read of nearby keys."}),"\n",(0,n.jsx)(t.h3,{id:"default-behaviors",children:"Default behaviors"}),"\n",(0,n.jsxs)(t.p,{children:["When a Hudi table is created, the metadata table will be enabled with three partitions by default: ",(0,n.jsx)(t.em,{children:"files"}),", ",(0,n.jsx)(t.em,{children:"column stats"}),", and ",(0,n.jsx)(t.em,{children:"partition stats"}),":"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Files"}),": stores the list of all partitions and the lists of all base files and log files of each partition, located at the ",(0,n.jsx)(t.code,{children:"files/"})," partition of the metadata table."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Column stats"}),": stores file-level statistics like min, max, value count, and null count for specified columns, located at the ",(0,n.jsx)(t.code,{children:"column_stats/"})," partition of the metadata table."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Partition stats"}),": stores partition-level statistics like min, max, value count, and null count for specified columns, located at the ",(0,n.jsx)(t.code,{children:"partition_stats/"})," partition of the metadata table."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["By default, when no column is specified for column_stats and partition_stats, Hudi will index the first 32 columns (controlled by ",(0,n.jsx)(t.code,{children:"hoodie.metadata.index.column.stats.max.columns.to.index"}),") available in the table schema."]}),"\n",(0,n.jsx)(t.p,{children:"Whenever a new write is performed on the data table, the metadata table will be updated accordingly. For any available index, new index entries will be upserted to its corresponding partition. For example, if the new write creates a new partition in the data table with some new base files, the files partition will be updated and contain the latest partition and file lists. Similarly, the column stats and partition stats partitions will receive new entries indicating the updated statistics for the new files and partitions."}),"\n",(0,n.jsxs)(t.p,{children:["Note that by design, you cannot disable the files partition, as it is a fundamental index that serves both read and write processes. You can still, although not recommended, disable the entire metadata table by setting ",(0,n.jsx)(t.code,{children:"hoodie.metadata.enable=false"})," during a write."]}),"\n",(0,n.jsx)(t.p,{children:"We will discuss more details about how the default indexes work to improve read and write performance. We will also introduce more indexes supported by the metadata table with usage examples in the following sections."}),"\n",(0,n.jsx)(t.h2,{id:"data-skipping-with-files-column-stats-and-partition-stats",children:"Data Skipping with Files, Column Stats, and Partition Stats"}),"\n",(0,n.jsxs)(t.p,{children:["Data skipping is a core optimization technique that avoids unnecessary data scanning. Its most basic form is physical partitioning, where data is organized into directories based on columns like ",(0,n.jsx)(t.code,{children:"order_date"})," in a customer order table. When a query filters on a partitioned column, the engine uses ",(0,n.jsx)(t.em,{children:"partition pruning"})," to read only the relevant directories. More advanced techniques store lightweight statistics\u2014such as min/max values\u2014for data within each file. The query engine consults this metadata first; if the stats indicate a file cannot contain the required data, the engine skips reading it entirely. This reduction in I/O is a key strategy for accelerating queries and lowering compute costs."]}),"\n",(0,n.jsx)(t.h3,{id:"the-data-skipping-process",children:"The data skipping process"}),"\n",(0,n.jsx)(t.p,{children:"Hudi\u2019s indexing subsystem implements a multi-level skipping strategy using a combination of indexes. Query engines like Spark or Trino can leverage Hudi\u2019s files, partition stats, and column stats indexes to improve performance dramatically. The process, illustrated in the figure below, unfolds in several stages."}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Data skipping process flow",src:i(79875).A+"",width:"981",height:"706"})}),"\n",(0,n.jsxs)(t.p,{children:["First, the query engine parses the input SQL and extracts relevant filter predicates, such as ",(0,n.jsx)(t.code,{children:"price >= 300"}),". These predicates are pushed down to Hudi\u2019s integration component, which manages the index lookup process."]}),"\n",(0,n.jsx)(t.p,{children:"The component then consults the files index to get an initial list of partitions. It prunes this list using the partition stats index, which holds partition-level statistics like min/max values. For example, any partition with a maximum price below 300 is skipped entirely."}),"\n",(0,n.jsx)(t.p,{children:"After this initial pruning, the component consults the files index again to retrieve the list of data files within the remaining partitions. This file list is pruned further using the column stats index, which provides the same min/max statistics at the file level."}),"\n",(0,n.jsx)(t.p,{children:"This multi-step process ensures that the query engine reads only the minimum set of files required to satisfy the query, significantly reducing the total amount of data processed."}),"\n",(0,n.jsx)(t.h3,{id:"sql-examples",children:"SQL examples"}),"\n",(0,n.jsx)(t.p,{children:"The following examples demonstrate data skipping in action. We will create a Hudi table and execute Spark SQL queries against it, starting with both partition and column stats disabled to establish a baseline."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE orders (\n    order_id STRING,\n    price DECIMAL(12,2),\n    order_status STRING,\n    update_ts BIGINT,\n    shipping_date DATE,\n    shipping_country STRING\n) USING HUDI\nPARTITIONED BY (shipping_country)\nOPTIONS (\n    primaryKey = 'order_id',\n    preCombineField = 'update_ts',\n    hoodie.metadata.index.column.stats.enable = 'false',\n    hoodie.metadata.index.partition.stats.enable = 'false'\n);\n"})}),"\n",(0,n.jsx)(t.p,{children:"And insert some sample data:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"INSERT INTO orders VALUES\n('ORD001', 389.99, 'PENDING',    17495166353, DATE '2023-01-01', 'A'),\n('ORD002', 199.99, 'CONFIRMED',  17495167353, DATE '2023-01-01', 'A'),\n('ORD003', 59.50,  'SHIPPED',    17495168353, DATE '2023-01-11', 'B'),\n('ORD004', 99.00,  'PENDING',    17495169353, DATE '2023-02-09', 'B'),\n('ORD005', 19.99,  'PENDING',    17495170353, DATE '2023-06-12', 'C'),\n('ORD006', 5.99,   'SHIPPED',    17495171353, DATE '2023-07-31', 'C');\n"})}),"\n",(0,n.jsx)(t.h4,{id:"only-the-files-index",children:"Only the files index"}),"\n",(0,n.jsx)(t.p,{children:"With both column stats and partition stats disabled, only the files index is built during the insert operation. We\u2019ll use the SQL below for our test:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"SELECT order_id, price, shipping_country\nFROM orders\nWHERE price > 300;\n"})}),"\n",(0,n.jsx)(t.p,{children:"This query looks for orders with price greater than 300, which only exist in partition 'A' (shipping_country = 'A'). After running the SQL, here's what we see in the Spark UI:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Spark UI: files index only",src:i(19980).A+"",width:"747",height:"504"})}),"\n",(0,n.jsx)(t.p,{children:"Spark read all 3 partitions and 3 files to find potential matches, but only 1 record from partition A actually satisfied the query condition."}),"\n",(0,n.jsx)(t.h4,{id:"enabling-column-stats",children:"Enabling column stats"}),"\n",(0,n.jsx)(t.p,{children:"Now let's enable column stats while keeping partition stats disabled. Note that we can't do it the other way around\u2014partition stats requires column stats to be enabled first."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE orders (\n    order_id STRING,\n    price DECIMAL(12,2),\n    order_status STRING,\n    update_ts BIGINT,\n    shipping_date DATE,\n    shipping_country STRING\n) USING HUDI\nPARTITIONED BY (shipping_country)\nOPTIONS (\n    primaryKey = 'order_id',\n    preCombineField = 'update_ts',\n    hoodie.metadata.index.column.stats.enable = 'true',\n    hoodie.metadata.index.partition.stats.enable = 'false'\n);\n"})}),"\n",(0,n.jsx)(t.p,{children:"Running the same SQL gives us this in the Spark UI:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Spark UI: column stats enabled",src:i(55893).A+"",width:"692",height:"461"})}),"\n",(0,n.jsx)(t.p,{children:"Now it shows all 3 partitions but only 1 file was scanned. Without partition stats, the query engine couldn't prune partitions, but column stats successfully filtered out the non-matching files. The compute cost of examining those 2 irrelevant partitions and their files could have been avoided with partition stats enabled."}),"\n",(0,n.jsx)(t.h4,{id:"enabling-column-stats-and-partition-stats",children:"Enabling column stats and partition stats"}),"\n",(0,n.jsx)(t.p,{children:"Now let's enable partition stats as well. Since both indexes are enabled by default in Hudi 1.x, we can simply omit those additional configs from the CREATE statement:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE orders (\n    order_id STRING,\n    price DECIMAL(12,2),\n    order_status STRING,\n    update_ts BIGINT,\n    shipping_date DATE,\n    shipping_country STRING\n) USING HUDI\nPARTITIONED BY (shipping_country)\nOPTIONS (\n    primaryKey = 'order_id',\n    preCombineField = 'update_ts'\n);\n"})}),"\n",(0,n.jsx)(t.p,{children:"Running the same SQL gives us this in the Spark UI:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Spark UI: column + partition stats enabled",src:i(70142).A+"",width:"685",height:"457"})}),"\n",(0,n.jsxs)(t.p,{children:["Now we see the full pruning effect happened\u2014only 1 relevant partition and 1 relevant file were scanned, thanks to both indexes working together. ",(0,n.jsx)(t.a,{href:"https://hudi.apache.org/blog/2025/10/22/Partition_Stats_Enhancing_Column_Stats_in_Hudi_1.0/",children:"This blog"})," shows a 93% reduction in query time running on a 1 TB dataset."]}),"\n",(0,n.jsx)(t.h3,{id:"configure-relevant-columns-to-be-indexed",children:"Configure relevant columns to be indexed"}),"\n",(0,n.jsx)(t.p,{children:"By default, Hudi indexes the first 32 columns for both partition stats and column stats. This limit prevents excessive metadata overhead\u2014each indexed column requires computing min, max, null-count, and value-count statistics for every partition and data file. In most cases, you only need to index a small subset of columns that are frequently used in query predicates. You can specify which columns to be indexed to reduce the maintenance costs:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE orders (\n    order_id STRING,\n    price DECIMAL(12,2),\n    order_status STRING,\n    update_ts BIGINT,\n    shipping_date DATE,\n    shipping_country STRING\n) USING HUDI\nPARTITIONED BY (shipping_country)\nOPTIONS (\n    primaryKey = 'order_id',\n    preCombineField = 'update_ts',\n    'hoodie.metadata.index.column.stats.column.list' = 'price,shipping_date'\n);\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The config ",(0,n.jsx)(t.code,{children:"hoodie.metadata.index.column.stats.column.list"})," applies to both partition stats and column stats. By indexing just the ",(0,n.jsx)(t.code,{children:"price"})," and ",(0,n.jsx)(t.code,{children:"shipping_date"})," columns, queries filtering on price comparisons or shipping date ranges will already see significant performance improvements."]}),"\n",(0,n.jsx)(t.h2,{id:"key-takeaways-and-whats-next",children:"Key Takeaways and What's Next"}),"\n",(0,n.jsxs)(t.p,{children:["Hudi\u2019s metadata table is itself a Hudi Merge\u2011on\u2011Read (MOR) table that acts as a multimodal indexing subsystem. It is physically partitioned by index type (for example, ",(0,n.jsx)(t.code,{children:"files/"}),", ",(0,n.jsx)(t.code,{children:"column_stats/"}),", ",(0,n.jsx)(t.code,{children:"partition_stats/"}),") and stores base files in the HFile (SSTable\u2011like) format. This layout provides fast point lookups and efficient batched scans by key prefix\u2014exactly the access patterns indexing needs at lakehouse scale."]}),"\n",(0,n.jsx)(t.p,{children:"Index maintenance happens transactionally alongside data writes, keeping index entries consistent with the data table. Periodic compaction merges log files into read\u2011optimized HFile base files to keep point lookups fast and predictable. On the read path, Hudi composes multiple indexes to minimize I/O: the files index enumerates candidates, partition stats prune irrelevant partitions, and column stats prune non\u2011matching files. In effect, the engine scans only the minimum set of files required to satisfy a query."}),"\n",(0,n.jsxs)(t.p,{children:["In practice, the defaults are a strong starting point. Keep the metadata table enabled and explicitly list only the columns you frequently filter on via ",(0,n.jsx)(t.code,{children:"hoodie.metadata.index.column.stats.column.list"})," to control metadata overhead. In ",(0,n.jsx)(t.a,{href:"https://hudi.apache.org/blog/2025/11/12/deep-dive-into-hudis-indexing-subsystem-part-2-of-2/",children:"part 2"}),", we\u2019ll go deeper into accelerating equality\u2011matching and expression\u2011based predicates using the record, secondary, and expression indexes, and discuss how asynchronous index maintenance keeps writers unblocked while indexes build in the background."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>r});var a=i(96540);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}},32122:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig2-686d385820b946c158ab5110d3bcbaf8.png"},53233:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig1-7461f8a910c9f7c87745a4a5e15c3498.png"},55893:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig5-8c6a7e86f7bb1789e91ac4c539fd1b78.png"},70142:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig6-29897046b22cae13ecde0bad971f9544.png"},79875:(e,t,i)=>{i.d(t,{A:()=>a});const a=i.p+"assets/images/fig3-468ec18846bf7194631d838fd9824bcf.png"}}]);