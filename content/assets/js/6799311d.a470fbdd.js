"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[18759],{17141:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>c,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"key_generation","title":"Key Generation","description":"Hudi needs some way to point to records in the table, so that base/log files can be merged efficiently for updates/deletes,","source":"@site/versioned_docs/version-1.1.0/key_generation.md","sourceDirName":".","slug":"/key_generation","permalink":"/docs/key_generation","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-1.1.0/key_generation.md","tags":[],"version":"1.1.0","frontMatter":{"title":"Key Generation","summary":"In this page, we describe key generation in Hudi.","toc":true,"last_modified_at":null},"sidebar":"docs","previous":{"title":"Table & Query Types","permalink":"/docs/table_types"},"next":{"title":"Record Merger","permalink":"/docs/record_merger"}}');var n=i(74848),s=i(28453);const d={title:"Key Generation",summary:"In this page, we describe key generation in Hudi.",toc:!0,last_modified_at:null},a=void 0,o={},l=[{value:"Key Generators",id:"key-generators",level:2},{value:"SIMPLE",id:"simple",level:3},{value:"COMPLEX",id:"complex",level:3},{value:"NON_PARTITION",id:"non_partition",level:3},{value:"CUSTOM",id:"custom",level:3},{value:"TIMESTAMP",id:"timestamp",level:3},{value:"Timestamp is GMT",id:"timestamp-is-gmt",level:4},{value:"Timestamp is DATE_STRING",id:"timestamp-is-date_string",level:4},{value:"Scalar examples",id:"scalar-examples",level:4},{value:"ISO8601WithMsZ with Single Input format",id:"iso8601withmsz-with-single-input-format",level:4},{value:"ISO8601WithMsZ with Multiple Input formats",id:"iso8601withmsz-with-multiple-input-formats",level:4},{value:"ISO8601NoMs with offset using multiple input formats",id:"iso8601noms-with-offset-using-multiple-input-formats",level:4},{value:"Input as short date string and expect date in date format",id:"input-as-short-date-string-and-expect-date-in-date-format",level:4},{value:"Related Resources",id:"related-resources",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Hudi needs some way to point to records in the table, so that base/log files can be merged efficiently for updates/deletes,\nindex entries can reference these rows and records can move around within the table from clustering without side effects.\nIn fact, most databases adopt similar techniques. Every record in Hudi is uniquely identified a pair of record key and an optional\npartition path that can limit the scope of the key's uniqueness (non-global indexing). For tables with a global index, records are\nidentified by just the record key such that uniqueness is applied across partitions."}),"\n",(0,n.jsxs)(t.p,{children:["Using keys, Hudi can impose partition/table level uniqueness integrity constraint as well as enable fast updates and deletes on records. Record keys are materialized in a\nspecial ",(0,n.jsx)(t.code,{children:"_hoodie_record_key"})," field in the table, to ensure key uniqueness is maintained even when the record generation is changed\nduring the table's lifetime. Without materialization, there are no guarantees that the past data written for a new key is unique across the table."]}),"\n",(0,n.jsx)(t.p,{children:"Hudi offers many ways to generate record keys from the input data during writes."}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["For Java client/Spark/Flink writers, Hudi provides built-in key generator classes (described below) as well as an ",(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/java/org/apache/hudi/keygen/KeyGenerator.java",children:"interface"}),"\nto write custom implementations."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["SQL engines offer options to pass in key fields and use ",(0,n.jsx)(t.code,{children:"PARTITIONED BY"})," clauses to control partitioning."]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"By default, Hudi auto-generates keys for INSERT, BULK_INSERT write operations, that are efficient\nfor compute, storage and read to meet the uniqueness requirements of the primary key. Auto generated keys are highly\ncompressible compared to UUIDs costing about $0.023 per GB in cloud storage and 3-10x computationally lighter to generate\nthan base64/uuid encoded keys."}),"\n",(0,n.jsx)(t.h2,{id:"key-generators",children:"Key Generators"}),"\n",(0,n.jsx)(t.p,{children:"Hudi provides several key generators out of the box for JVM users can use based on their need, while having a pluggable\ninterface for users to implement and use their own."}),"\n",(0,n.jsx)(t.p,{children:"Before diving into different types of key generators, let\u2019s go over some of the common configs relevant to key generators."}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Default"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.recordkey.field"}),(0,n.jsx)(t.td,{children:"N/A (Optional)"}),(0,n.jsxs)(t.td,{children:["Record key field. Value to be used as the ",(0,n.jsx)(t.code,{children:"recordKey"})," component of ",(0,n.jsx)(t.code,{children:"HoodieKey"}),". ",(0,n.jsxs)("ul",{children:[(0,n.jsxs)("li",{children:["When configured, actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg: ",(0,n.jsx)(t.code,{children:"a.b.c"}),". "]}),(0,n.jsx)("li",{children:"When not configured record key will be automatically generated by Hudi. This feature is handy for use cases like log ingestion that do not have a naturally present record key."})]})," ",(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: RECORDKEY_FIELD_NAME"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.partitionpath.field"}),(0,n.jsx)(t.td,{children:"N/A (Optional)"}),(0,n.jsxs)(t.td,{children:["Partition path field. Value to be used at the partitionPath component of HoodieKey. This needs to be specified if a partitioned table is desired. Actual value obtained by invoking .toString()",(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: PARTITIONPATH_FIELD_NAME"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.keygenerator.type"}),(0,n.jsx)(t.td,{children:"SIMPLE"}),(0,n.jsxs)(t.td,{children:["String representing key generator type ",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: KEYGENERATOR_TYPE"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.keygenerator.class"}),(0,n.jsx)(t.td,{children:"N/A (Optional)"}),(0,n.jsxs)(t.td,{children:["Key generator class, that implements ",(0,n.jsx)(t.code,{children:"org.apache.hudi.keygen.KeyGenerator"})," extract a key out of incoming records. ",(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"When set, the configured value takes precedence to be in effect and automatic inference is not triggered."}),(0,n.jsxs)("li",{children:["When not configured, if ",(0,n.jsx)(t.code,{children:"hoodie.datasource.write.keygenerator.type"})," is set, the configured value is used else automatic inference is triggered."]}),(0,n.jsx)("li",{children:"In case of auto generated record keys, if neither the key generator class nor type are configured, Hudi will also auto infer the partitioning. for eg, if partition field is not configured, hudi will assume its non-partitioned. "})]})," ",(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: KEYGENERATOR_CLASS_NAME"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.hive_style_partitioning"}),(0,n.jsx)(t.td,{children:"false (Optional)"}),(0,n.jsxs)(t.td,{children:["Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <partition_column_name>=<partition_value> format. By default false (the names of partition folders are only partition values)",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: HIVE_STYLE_PARTITIONING_ENABLE"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.datasource.write.partitionpath.urlencode"}),(0,n.jsx)(t.td,{children:"false (Optional)"}),(0,n.jsxs)(t.td,{children:["Should we url encode the partition path value, before creating the folder structure.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),(0,n.jsx)(t.code,{children:"Config Param: URL_ENCODE_PARTITIONING"})]})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["For all advanced configs refer ",(0,n.jsx)(t.a,{href:"https://hudi.apache.org/docs/next/configurations#KEY_GENERATOR",children:"here"}),"."]}),"\n",(0,n.jsx)(t.h3,{id:"simple",children:(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/SimpleKeyGenerator.java",children:"SIMPLE"})}),"\n",(0,n.jsx)(t.p,{children:"This is the most commonly used option. Record key is generated from two fields from the schema, one for record key and one for partition path.  Values are interpreted as is from dataframe and converted to string."}),"\n",(0,n.jsx)(t.h3,{id:"complex",children:(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java",children:"COMPLEX"})}),"\n",(0,n.jsxs)(t.p,{children:["Both record key and partition paths comprise one or more than one field by name(combination of multiple fields). Fields\nare expected to be comma separated in the config value. For example ",(0,n.jsx)(t.code,{children:'"Hoodie.datasource.write.recordkey.field" : \u201ccol1,col4\u201d'})]}),"\n",(0,n.jsx)(t.h3,{id:"non_partition",children:(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/NonpartitionedKeyGenerator.java",children:"NON_PARTITION"})}),"\n",(0,n.jsx)(t.p,{children:"If your hudi dataset is not partitioned, you could use this \u201cNonpartitionedKeyGenerator\u201d which will return an empty\npartition for all records. In other words, all records go to the same partition (which is empty \u201c\u201d)"}),"\n",(0,n.jsx)(t.h3,{id:"custom",children:(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java",children:"CUSTOM"})}),"\n",(0,n.jsx)(t.p,{children:"This is a generic implementation of KeyGenerator where users are able to leverage the benefits of SimpleKeyGenerator,\nComplexKeyGenerator and TimestampBasedKeyGenerator all at the same time. One can configure record key and partition\npaths as a single field or a combination of fields."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"hoodie.datasource.write.recordkey.field\nhoodie.datasource.write.partitionpath.field\nhoodie.datasource.write.keygenerator.class=org.apache.hudi.keygen.CustomKeyGenerator\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This keyGenerator is particularly useful if you want to define\ncomplex partition paths involving regular fields and timestamp based fields. It expects value for prop ",(0,n.jsx)(t.code,{children:'"hoodie.datasource.write.partitionpath.field"'}),'\nin a specific format. The format should be "field1',":PartitionKeyType1",",field2",":PartitionKeyType2",'..."']}),"\n",(0,n.jsxs)(t.p,{children:["The complete partition path is created as\n",(0,n.jsx)(t.code,{children:"<value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> "}),"\nand so on. Each partition key type could either be SIMPLE or TIMESTAMP."]}),"\n",(0,n.jsxs)(t.p,{children:["Example config value: ",(0,n.jsx)(t.code,{children:"\u201cfield_3:simple,field_5:timestamp\u201d"})]}),"\n",(0,n.jsx)(t.p,{children:"RecordKey config value is either single field incase of SimpleKeyGenerator or a comma separate field names if referring to ComplexKeyGenerator.\nExample:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"hoodie.datasource.write.recordkey.field=field1,field2\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This will create your record key in the format ",(0,n.jsx)(t.code,{children:"field1:value1,field2:value2"})," and so on, otherwise you can specify only one field in case of simple record keys. ",(0,n.jsx)(t.code,{children:"CustomKeyGenerator"})," class defines an enum ",(0,n.jsx)(t.code,{children:"PartitionKeyType"})," for configuring partition paths. It can take two possible values - SIMPLE and TIMESTAMP.\nThe value for ",(0,n.jsx)(t.code,{children:"hoodie.datasource.write.partitionpath.field"})," property in case of partitioned tables needs to be provided in the format ",(0,n.jsx)(t.code,{children:"field1:PartitionKeyType1,field2:PartitionKeyType2"})," and so on. For example, if you want to create partition path using 2 fields ",(0,n.jsx)(t.code,{children:"country"})," and ",(0,n.jsx)(t.code,{children:"date"})," where the latter has timestamp based values and needs to be customised in a given format, you can specify the following"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-java",children:"hoodie.datasource.write.partitionpath.field=country:SIMPLE,date:TIMESTAMP\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This will create the partition path in the format ",(0,n.jsx)(t.code,{children:"<country_name>/<date>"})," or ",(0,n.jsx)(t.code,{children:"country=<country_name>/date=<date>"})," depending on whether you want hive style partitioning or not."]}),"\n",(0,n.jsx)(t.h3,{id:"timestamp",children:(0,n.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/TimestampBasedKeyGenerator.java",children:"TIMESTAMP"})}),"\n",(0,n.jsx)(t.p,{children:"This key generator relies on timestamps for the partition field. The field values are interpreted as timestamps\nand not just converted to string while generating partition path value for records.  Record key is same as before where it is chosen by\nfield name.  Users are expected to set few more configs to use this KeyGenerator."}),"\n",(0,n.jsx)(t.p,{children:"Configs to be set:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Default"}),(0,n.jsx)(t.th,{children:"Description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.keygen.timebased.timestamp.type"}),(0,n.jsxs)(t.td,{children:["N/A ",(0,n.jsx)(t.strong,{children:"(Required)"})]}),(0,n.jsx)(t.td,{children:"Required only when the key generator is TimestampBasedKeyGenerator. One of the timestamp types supported(UNIX_TIMESTAMP, DATE_STRING, MIXED, EPOCHMILLISECONDS, SCALAR)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.keygen.timebased.output.dateformat"}),(0,n.jsx)(t.td,{children:'"" (Optional)'}),(0,n.jsxs)(t.td,{children:["Output date format such as ",(0,n.jsx)(t.code,{children:"yyyy-MM-dd'T'HH:mm:ss.SSSZ"})]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.keygen.timebased.timezone"}),(0,n.jsx)(t.td,{children:'"UTC" (Optional)'}),(0,n.jsxs)(t.td,{children:["Timezone of both input and output timestamp if they are the same, such as ",(0,n.jsx)(t.code,{children:"UTC"}),".  Please use ",(0,n.jsx)(t.code,{children:"hoodie.keygen.timebased.input.timezone"})," and ",(0,n.jsx)(t.code,{children:"hoodie.keygen.timebased.output.timezone"})," instead if the input and output timezones are different."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hoodie.keygen.timebased.input.dateformat"}),(0,n.jsx)(t.td,{children:'"" (Optional)'}),(0,n.jsxs)(t.td,{children:["Input date format such as ",(0,n.jsx)(t.code,{children:"yyyy-MM-dd'T'HH:mm:ss.SSSZ"}),"."]})]})]})]}),"\n",(0,n.jsx)(t.p,{children:"Let's go over some example values for TimestampBasedKeyGenerator."}),"\n",(0,n.jsx)(t.h4,{id:"timestamp-is-gmt",children:"Timestamp is GMT"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"EPOCHMILLISECONDS"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyy-MM-dd hh"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timezone"})}),(0,n.jsx)(t.td,{children:'"GMT+8:00"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Input Field value: \u201c1578283932000L\u201d ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c2020-01-06 12\u201d"]}),"\n",(0,n.jsxs)(t.p,{children:["If input field value is null for some rows. ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c1970-01-01 08\u201d"]}),"\n",(0,n.jsx)(t.h4,{id:"timestamp-is-date_string",children:"Timestamp is DATE_STRING"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"DATE_STRING"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyy-MM-dd hh"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timezone"})}),(0,n.jsx)(t.td,{children:'"GMT+8:00"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat"})}),(0,n.jsxs)(t.td,{children:['"yyyy-MM-dd hh:mm',":ss",'"']})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Input field value: \u201c2020-01-06 12:12:12\u201d ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c2020-01-06 12\u201d"]}),"\n",(0,n.jsxs)(t.p,{children:["If input field value is null for some rows. ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c1970-01-01 12:00:00\u201d"]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(t.h4,{id:"scalar-examples",children:"Scalar examples"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"SCALAR"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyy-MM-dd hh"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timezone"})}),(0,n.jsx)(t.td,{children:'"GMT"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.scalar.time.unit"})}),(0,n.jsx)(t.td,{children:'"days"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:["Input field value: \u201c20000L\u201d ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c2024-10-04 12\u201d"]}),"\n",(0,n.jsxs)(t.p,{children:["If input field value is null. ",(0,n.jsx)("br",{}),"\nPartition path generated from key generator: \u201c1970-01-02 12\u201d"]}),"\n",(0,n.jsx)(t.h4,{id:"iso8601withmsz-with-single-input-format",children:"ISO8601WithMsZ with Single Input format"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"DATE_STRING"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat"})}),(0,n.jsxs)(t.td,{children:["\"yyyy-MM-dd'T'HH:mm",":ss",'.SSSZ"']})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat.list.delimiter.regex"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.timezone"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyyMMddHH"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.timezone"})}),(0,n.jsx)(t.td,{children:'"GMT"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:['Input field value: "2020-04-01T13:01:33.428Z" ',(0,n.jsx)("br",{}),'\nPartition path generated from key generator: "2020040113"']}),"\n",(0,n.jsx)(t.h4,{id:"iso8601withmsz-with-multiple-input-formats",children:"ISO8601WithMsZ with Multiple Input formats"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"DATE_STRING"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat"})}),(0,n.jsxs)(t.td,{children:["\"yyyy-MM-dd'T'HH:mm",":ssZ",",yyyy-MM-dd'T'HH:mm",":ss",'.SSSZ"']})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat.list.delimiter.regex"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.timezone"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyyMMddHH"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.timezone"})}),(0,n.jsx)(t.td,{children:'"UTC"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:['Input field value: "2020-04-01T13:01:33.428Z" ',(0,n.jsx)("br",{}),'\nPartition path generated from key generator: "2020040113"']}),"\n",(0,n.jsx)(t.h4,{id:"iso8601noms-with-offset-using-multiple-input-formats",children:"ISO8601NoMs with offset using multiple input formats"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"DATE_STRING"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat"})}),(0,n.jsxs)(t.td,{children:["\"yyyy-MM-dd'T'HH:mm",":ssZ",",yyyy-MM-dd'T'HH:mm",":ss",'.SSSZ"']})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat.list.delimiter.regex"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.timezone"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"yyyyMMddHH"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.timezone"})}),(0,n.jsx)(t.td,{children:'"UTC"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:['Input field value: "2020-04-01T13:01:33-',(0,n.jsx)(t.strong,{children:"05:00"}),'" ',(0,n.jsx)("br",{}),'\nPartition path generated from key generator: "2020040118"']}),"\n",(0,n.jsx)(t.h4,{id:"input-as-short-date-string-and-expect-date-in-date-format",children:"Input as short date string and expect date in date format"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Config Name"}),(0,n.jsx)(t.th,{children:"Value"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.timestamp.type"})}),(0,n.jsx)(t.td,{children:'"DATE_STRING"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat"})}),(0,n.jsxs)(t.td,{children:["\"yyyy-MM-dd'T'HH:mm",":ssZ",",yyyy-MM-dd'T'HH:mm",":ss",'.SSSZ,yyyyMMdd"']})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.dateformat.list.delimiter.regex"})}),(0,n.jsx)(t.td,{children:'""'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.input.timezone"})}),(0,n.jsx)(t.td,{children:'"UTC"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.dateformat"})}),(0,n.jsx)(t.td,{children:'"MM/dd/yyyy"'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:(0,n.jsx)(t.code,{children:"hoodie.streamer.keygen.timebased.output.timezone"})}),(0,n.jsx)(t.td,{children:'"UTC"'})]})]})]}),"\n",(0,n.jsxs)(t.p,{children:['Input field value: "20200401" ',(0,n.jsx)("br",{}),'\nPartition path generated from key generator: "04/01/2020"']}),"\n",(0,n.jsx)(t.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,n.jsx)("h3",{children:"Blogs"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://www.onehouse.ai/blog/hudi-metafields-demystified",children:"Hudi metafields demystified"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://medium.com/@simpsons/primary-key-and-partition-generators-with-apache-hudi-f0e4d71d9d26",children:"Primary key and Partition Generators with Apache Hudi"})}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},28453:(e,t,i)=>{i.d(t,{R:()=>d,x:()=>a});var r=i(96540);const n={},s=r.createContext(n);function d(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:d(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);