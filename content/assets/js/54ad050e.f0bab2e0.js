"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[28627],{403:e=>{e.exports=JSON.parse('{"permalink":"/blog/2021/06/10/employing-right-configurations-for-hudi-cleaner","editUrl":"https://github.com/apache/hudi/edit/asf-site/website/blog/blog/2021-06-10-employing-right-configurations-for-hudi-cleaner.md","source":"@site/blog/2021-06-10-employing-right-configurations-for-hudi-cleaner.md","title":"Employing correct configurations for Hudi\'s cleaner table service","description":"Apache Hudi provides snapshot isolation between writers and readers. This is made possible by Hudi\u2019s MVCC concurrency model. In this blog, we will explain how to employ the right configurations to manage multiple file versions. Furthermore, we will discuss mechanisms available to users on how to maintain just the required number of old file versions so that long running readers do not fail.","date":"2021-06-10T00:00:00.000Z","tags":[{"inline":true,"label":"how-to","permalink":"/blog/tags/how-to"},{"inline":true,"label":"cleaner","permalink":"/blog/tags/cleaner"},{"inline":true,"label":"apache hudi","permalink":"/blog/tags/apache-hudi"}],"readingTime":6.86,"hasTruncateMarker":true,"authors":[{"name":"pratyakshsharma","key":null,"page":null}],"frontMatter":{"title":"Employing correct configurations for Hudi\'s cleaner table service","excerpt":"Ensuring isolation between Hudi writers and readers using `HoodieCleaner.java`","author":"pratyakshsharma","category":"blog","image":"/assets/images/blog/hoodie-cleaner/Initial_timeline.png","tags":["how-to","cleaner","apache hudi"]},"unlisted":false,"prevItem":{"title":"Part1: Query apache hudi dataset in an amazon S3 data lake with amazon athena : Read optimized queries","permalink":"/blog/2021/07/16/Query-apache-hudi-dataset-in-an-amazon-S3-data-lake-with-amazon-athena-Read-optimized-queries"},"nextItem":{"title":"Apache Hudi: How Uber gets data a ride to its destination","permalink":"/blog/2021/06/04/Apache-Hudi-How-Uber-gets-data-a-ride-to-its-destination"}}')},14127:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/Retain_latest_commits-e387b7c19e4ee4d9cbef7b0bb0466983.png"},23209:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/Initial_timeline-fd0812aa0c22d797d2192745d103bc41.png"},26620:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=n(403),t=n(74848),a=n(28453);const o={title:"Employing correct configurations for Hudi's cleaner table service",excerpt:"Ensuring isolation between Hudi writers and readers using `HoodieCleaner.java`",author:"pratyakshsharma",category:"blog",image:"/assets/images/blog/hoodie-cleaner/Initial_timeline.png",tags:["how-to","cleaner","apache hudi"]},r=void 0,l={authorsImageUrls:[void 0]},c=[{value:"Reclaiming space and keeping your data lake storage costs in check",id:"reclaiming-space-and-keeping-your-data-lake-storage-costs-in-check",level:3},{value:"Problem Statement",id:"problem-statement",level:3},{value:"Deeper dive into Hudi Cleaner",id:"deeper-dive-into-hudi-cleaner",level:3},{value:"Cleaning Policies",id:"cleaning-policies",level:3},{value:"Examples",id:"examples",level:3},{value:"Configurations",id:"configurations",level:3},{value:"Run command",id:"run-command",level:3},{value:"Future Scope",id:"future-scope",level:3}];function d(e){const i={a:"a",code:"code",em:"em",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"Apache Hudi provides snapshot isolation between writers and readers. This is made possible by Hudi\u2019s MVCC concurrency model. In this blog, we will explain how to employ the right configurations to manage multiple file versions. Furthermore, we will discuss mechanisms available to users on how to maintain just the required number of old file versions so that long running readers do not fail."}),"\n",(0,t.jsx)(i.h3,{id:"reclaiming-space-and-keeping-your-data-lake-storage-costs-in-check",children:"Reclaiming space and keeping your data lake storage costs in check"}),"\n",(0,t.jsxs)(i.p,{children:["Hudi provides different table management services to be able to manage your tables on the data lake. One of these services is called the ",(0,t.jsx)(i.strong,{children:"Cleaner"}),". As you write more data to your table, for every batch of updates received, Hudi can either generate a new version of the data file with updates applied to records (COPY_ON_WRITE) or write these delta updates to a log file, avoiding rewriting newer version of an existing file (MERGE_ON_READ). In such situations, depending on the frequency of your updates, the number of file versions of log files can grow indefinitely. If your use-cases do not require keeping an infinite history of these versions, it is imperative to have a process that reclaims older versions of the data. This is Hudi\u2019s cleaner service."]}),"\n",(0,t.jsx)(i.h3,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,t.jsx)(i.p,{children:"In a data lake architecture, it is a very common scenario to have readers and writers concurrently accessing the same table. As the Hudi cleaner service periodically reclaims older file versions, scenarios arise where a long running query might be accessing a file version that is deemed to be reclaimed by the cleaner. Here, we need to employ the correct configs to ensure readers (aka queries) don\u2019t fail."}),"\n",(0,t.jsx)(i.h3,{id:"deeper-dive-into-hudi-cleaner",children:"Deeper dive into Hudi Cleaner"}),"\n",(0,t.jsx)(i.p,{children:"To deal with the mentioned scenario, lets understand the  different cleaning policies that Hudi offers and the corresponding properties that need to be configured. Options are available to schedule cleaning asynchronously or synchronously. Before going into more details, we would like to explain a few underlying concepts:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Hudi base file"}),": Columnar file which consists of final data after compaction. A base file\u2019s name follows the following naming convention: ",(0,t.jsx)(i.code,{children:"<fileId>_<writeToken>_<instantTime>.parquet"}),". In subsequent writes of this file, file id remains the same and commit time gets updated to show the latest version. This also implies any particular version of a record, given its partition path, can be uniquely located using the file id and instant time."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"File slice"}),": A file slice consists of the base file and any log files consisting of the delta, in case of MERGE_ON_READ table type."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Hudi File Group"}),": Any file group in Hudi is uniquely identified by the partition path and the  file id that the files in this group have as part of their name. A file group consists of all the file slices in a particular partition path. Also any partition path can have multiple file groups."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"cleaning-policies",children:"Cleaning Policies"}),"\n",(0,t.jsx)(i.p,{children:"Hudi cleaner currently supports below cleaning policies:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"KEEP_LATEST_COMMITS"}),": This is the default policy. This is a temporal cleaning policy that ensures the effect of having lookback into all the changes that happened in the last X commits. Suppose a writer is ingesting data  into a Hudi dataset every 30 minutes and the longest running query can take 5 hours to finish, then the user should retain atleast the last 10 commits. With such a configuration, we ensure that the oldest version of a file is kept on disk for at least 5 hours, thereby preventing the longest running query from failing at any point in time. Incremental cleaning is also possible using this policy."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"KEEP_LATEST_FILE_VERSIONS"}),": This policy has the effect of keeping N number of file versions irrespective of time. This policy is useful when it is known how many MAX versions of the file does one want to keep at any given time. To achieve the same behaviour as before of preventing long running queries from failing, one should do their calculations based on data patterns. Alternatively, this policy is also useful if a user just wants to maintain 1 latest version of the file."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(i.p,{children:"Suppose a user is ingesting data into a hudi dataset of type COPY_ON_WRITE every 30 minutes as shown below:"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.img,{alt:"Initial timeline",src:n(23209).A+"",width:"1200",height:"600"}),"\n",(0,t.jsx)(i.em,{children:"Figure1: Incoming records getting ingested into a hudi dataset every 30 minutes"})]}),"\n",(0,t.jsx)(i.p,{children:"The figure shows a particular partition on DFS where commits and corresponding file versions are color coded. 4 different file groups are created in this partition as depicted by fileGroup1, fileGroup2, fileGroup3 and fileGroup4. File group corresponding to fileGroup2 has records ingested from all the 5 commits, while the group corresponding to fileGroup4 has records from the latest 2 commits only."}),"\n",(0,t.jsx)(i.p,{children:"Suppose the user uses the below configs for cleaning:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"hoodie.cleaner.policy=KEEP_LATEST_COMMITS\nhoodie.cleaner.commits.retained=2\n"})}),"\n",(0,t.jsx)(i.p,{children:"Cleaner selects the versions of files to be cleaned by taking care of the following:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Latest version of a file should not be cleaned."}),"\n",(0,t.jsxs)(i.li,{children:["The commit times of the last 2 (configured) + 1 commits are determined. In Figure1, ",(0,t.jsx)(i.code,{children:"commit 10:30"})," and ",(0,t.jsx)(i.code,{children:"commit 10:00"})," correspond to the latest 2 commits in the timeline. One extra commit is included because the time window for retaining commits is essentially equal to the longest query run time. So if the longest query takes 1 hour to finish, and ingestion happens every 30 minutes, you need to retain last 2 commits since 2*30 = 60 (1 hour). At this point of time, the longest query can still be using files written in 3rd commit in reverse order. Essentially this means if a query started executing after ",(0,t.jsx)(i.code,{children:"commit 9:30"}),", it will still be running when clean action is triggered right after ",(0,t.jsx)(i.code,{children:"commit 10:30"})," as in Figure2."]}),"\n",(0,t.jsxs)(i.li,{children:["Now for any file group, only those file slices are scheduled for cleaning which are not savepointed (another Hudi table service) and whose commit time is less than the 3rd commit (",(0,t.jsx)(i.code,{children:"commit 9:30"})," in figure below) in reverse order."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.img,{alt:"Retain latest commits",src:n(14127).A+"",width:"1418",height:"1176"}),"\n",(0,t.jsx)(i.em,{children:"Figure2: Files corresponding to latest 3 commits are retained"})]}),"\n",(0,t.jsx)(i.p,{children:"Now, suppose the user uses the below configs for cleaning:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"hoodie.cleaner.policy=KEEP_LATEST_FILE_VERSIONS\nhoodie.cleaner.fileversions.retained=1\n"})}),"\n",(0,t.jsx)(i.p,{children:"Cleaner does the following:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["For any file group, latest version (including any for pending compaction) of file slices are kept and the rest are scheduled for cleaning. Clearly as shown in Figure3, if clean action is triggered right after ",(0,t.jsx)(i.code,{children:"commit 10:30"}),", the cleaner will simply leave the latest version in every file group and delete the rest."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.img,{alt:"Retain latest versions",src:n(31505).A+"",width:"1440",height:"1182"}),"\n",(0,t.jsx)(i.em,{children:"Figure3: Latest file version in every file group is retained"})]}),"\n",(0,t.jsx)(i.h3,{id:"configurations",children:"Configurations"}),"\n",(0,t.jsxs)(i.p,{children:["You can find the details about all the possible configurations along with the default values ",(0,t.jsx)(i.a,{href:"https://hudi.apache.org/docs/configurations#compaction-configs",children:"here"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"run-command",children:"Run command"}),"\n",(0,t.jsxs)(i.p,{children:["Hudi's cleaner table service can be run as a separate process or along with your data ingestion. As mentioned earlier, it basically cleans up any stale/old files lying around. In case you want to run it along with ingesting data, configs are available which enable you to run it ",(0,t.jsx)(i.a,{href:"https://hudi.apache.org/docs/configurations#withAsyncClean",children:"synchronously or asynchronously"}),". You can use the below command for running the cleaner independently:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"[hoodie]$ spark-submit --class org.apache.hudi.utilities.HoodieCleaner \\\n  --props s3:///temp/hudi-ingestion-config/kafka-source.properties \\\n  --target-base-path s3:///temp/hudi \\\n  --spark-master yarn-cluster\n"})}),"\n",(0,t.jsx)(i.p,{children:"In case you wish to run the cleaner service asynchronously with writing, please configure the below:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-java",children:"hoodie.clean.automatic=true\nhoodie.clean.async=true\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Further you can use ",(0,t.jsx)(i.a,{href:"https://hudi.apache.org/docs/deployment#cli",children:"Hudi CLI"})," for managing your Hudi dataset. CLI provides the below commands for cleaner service:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"cleans show"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"clean showpartitions"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.code,{children:"cleans run"})}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["You can find more details and the relevant code for these commands in ",(0,t.jsxs)(i.a,{href:"https://github.com/apache/hudi/blob/master/hudi-cli/src/main/java/org/apache/hudi/cli/commands/CleansCommand.java",children:[(0,t.jsx)(i.code,{children:"org.apache.hudi.cli.commands.CleansCommand"})," class"]}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"future-scope",children:"Future Scope"}),"\n",(0,t.jsxs)(i.p,{children:["Work is currently going on for introducing a new cleaning policy based on time elapsed. This will help in achieving a consistent retention throughout regardless of how frequently ingestion happens. You may track the progress ",(0,t.jsx)(i.a,{href:"https://issues.apache.org/jira/browse/HUDI-349",children:"here"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["We hope this blog gives you an idea about how to configure the Hudi cleaner and the supported cleaning policies. Please visit the ",(0,t.jsx)(i.a,{href:"https://hudi.apache.org/blog",children:"blog section"})," for a deeper understanding of various Hudi concepts. Cheers!"]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var s=n(96540);const t={},a=s.createContext(t);function o(e){const i=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(a.Provider,{value:i},e.children)}},31505:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/Retain_latest_versions-723f83313beb86b46c9cd1fcb8ea0b25.png"}}]);