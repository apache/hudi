"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[34543],{97568:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"metadata","title":"Table Metadata","description":"Hudi tracks metadata about a table to significantly improve read/write performance of the queries by addressing the following key challenges:","source":"@site/docs/metadata.md","sourceDirName":".","slug":"/metadata","permalink":"/docs/next/metadata","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/docs/metadata.md","tags":[],"version":"current","frontMatter":{"title":"Table Metadata","keywords":["hudi","metadata","S3","GCS","file listings","statistics"]},"sidebar":"docs","previous":{"title":"Record Mergers","permalink":"/docs/next/record_merger"},"next":{"title":"Indexes","permalink":"/docs/next/indexes"}}');var a=n(74848),s=n(28453);const r={title:"Table Metadata",keywords:["hudi","metadata","S3","GCS","file listings","statistics"]},l=void 0,d={},o=[{value:"Metadata Table",id:"metadata-table",level:2},{value:"Types of table metadata",id:"types-of-table-metadata",level:2},{value:"Metadata Tracking on Writers",id:"metadata-tracking-on-writers",level:2},{value:"Leveraging metadata during queries",id:"leveraging-metadata-during-queries",level:2},{value:"files index",id:"files-index",level:3},{value:"column_stats index and data skipping",id:"column_stats-index-and-data-skipping",level:3},{value:"Deployment considerations for metadata Table",id:"deployment-considerations-for-metadata-table",level:2},{value:"Deployment Model A: Single writer with inline table services",id:"deployment-model-a-single-writer-with-inline-table-services",level:3},{value:"Deployment Model B: Single writer with async table services",id:"deployment-model-b-single-writer-with-async-table-services",level:3},{value:"Deployment Model C: Multi-writer",id:"deployment-model-c-multi-writer",level:3},{value:"Related Resources",id:"related-resources",level:2}];function c(e){const t={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"Hudi tracks metadata about a table to significantly improve read/write performance of the queries by addressing the following key challenges:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Avoid list operations to obtain set of files in a table"}),": When reading and writing data, file listing operations are performed\nto get the current view of the file system. When tables are large and partitioned multiple levels deep, listing all the files may be a performance bottleneck,\ndut to inefficiencies in cloud storage. More importantly large number of API calls to cloud storage systems like AWS S3 sometimes causes throttling based on pre-defined request limits."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Expose columns statistics for better query planning and faster queries"}),":  Query engines rely on techniques such as partitioning and data skipping\nto cut down on the amount of irrelevant data scanned for query planning and execution. During query planning phase, file footer statistics like column value ranges,\nnull counts are read from all data files to  determine if a particular file needs to be read to satisfy the query. This approach is expensive since it may",(0,a.jsx)(t.br,{}),"\n","read footers from all files and even be subject to similar throttling issues for larger tables. Hudi enables relevant query predicates to\nbe efficiently evaluated on operate on column statistics without incurring these costs."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"metadata-table",children:"Metadata Table"}),"\n",(0,a.jsxs)(t.p,{children:["Hudi employs a special ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.em,{children:"metadata table"})}),", within each table to provide these capabilities. The metadata table implemented as a single\ninternal Hudi Merge-On-Read table that hosts different types of table metadata in each partition. This is similar to common practices in databases where metadata\nis tracked using internal tables. This approach provides the following advantages."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Scalable"}),": The table metadata must scale to large sizes as well (see ",(0,a.jsx)(t.a,{href:"https://vldb.org/pvldb/vol14/p3083-edara.pdf",children:"Big Metadata paper"})," from Google).\nDifferent types of indexes should be easily integrated to support various use cases with consistent management of metadata. By implementing metadata using the\nsame storage format and engine used for data, Hudi is able to scale to even TBs of metadata with built-in table services for managing metadata."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Flexible"}),": The foundational framework for multi-modal indexing is built to enable and disable new indexes as needed. The\n",(0,a.jsx)(t.a,{href:"https://www.onehouse.ai/blog/asynchronous-indexing-using-hudi",children:"async indexing"})," protocol index building alongside regular writers without impacting the write latency."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"transactional updates"}),": Tables data, metadata and indexes must be upto-date and consistent with each other as writes happen or table services are performed. and table metadata must be always up-to-date and in sync with the data table.\nThe data and metadata table's timelines share a parent-child relationship, to ensure they are always in sync with each other. Furthermore, the MoR table storage helps absorb fast changes to metadata from streaming writes without requiring\nrewriting of all table metadata on each write."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Fast lookups"}),": By employing a SSTable like base file format (HFile) in the metadata table, query engines are able to efficiently perform lookup scans for only specific parts of\nmetadata needed. For e.g. query accessing only 10 out of 100 columns in a table can read stats about only the 10 columns it's interested in, during down planning time and costs.\nFurther, these metadata can also be served via a centralized/embedded timeline server which caches the metadata, further reducing the latency of the lookup from executors."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"types-of-table-metadata",children:"Types of table metadata"}),"\n",(0,a.jsx)(t.p,{children:"Following are the different types of metadata currently supported."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/HUDI/RFC+-+15%3A+HUDI+File+Listing+Improvements",children:"files index"})})}),":\nStored as ",(0,a.jsx)(t.em,{children:"files"})," partition in the metadata table. Contains file information such as file name, size, and active state\nfor each partition in the data table. Improves the files listing performance by avoiding direct file system calls such\nas ",(0,a.jsx)(t.em,{children:"exists, listStatus"})," and ",(0,a.jsx)(t.em,{children:"listFiles"})," on the data table."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/rfc/rfc-27/rfc-27.md",children:"column_stats index"})})}),": Stored as ",(0,a.jsx)(t.em,{children:"column_stats"}),"\npartition in the metadata table. Contains the statistics of interested columns, such as min and max values, total values,\nnull counts, size, etc., for all data files and are used while serving queries with predicates matching interested\ncolumns. This index is used along with the ",(0,a.jsx)(t.a,{href:"https://www.onehouse.ai/blog/hudis-column-stats-index-and-data-skipping-feature-help-speed-up-queries-by-an-orders-of-magnitude",children:"data skipping"}),"\nto speed up queries by orders of magnitude."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:"Partition Stats Index"})}),"\nPartition stats index aggregates statistics at the partition level for the columns for which it is enabled. This helps\nin efficient partition pruning even for non-partition fields. The partition stats index is stored in ",(0,a.jsx)(t.em,{children:"partition_stats"}),"\npartition under metadata table. Partition stats index can be enabled using the following configs (note it is required\nto specify the columns for which stats should be aggregated):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-properties",children:"  hoodie.metadata.index.partition.stats.enable=true\n  hoodie.metadata.index.column.stats.columns=<comma-separated-column-names>\n"})}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["To try out these features, refer to the ",(0,a.jsx)(t.a,{href:"/docs/next/sql_ddl#create-partition-stats-and-secondary-index-experimental",children:"SQL guide"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"metadata-tracking-on-writers",children:"Metadata Tracking on Writers"}),"\n",(0,a.jsxs)(t.p,{children:["Following are the Spark based basic configs that are needed to enable metadata tracking. For advanced configs please refer\n",(0,a.jsx)(t.a,{href:"https://hudi.apache.org/docs/next/configurations#Metadata-Configs-advanced-configs",children:"here"}),"."]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Config Name"}),(0,a.jsx)(t.th,{children:"Default"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hoodie.metadata.enable"}),(0,a.jsx)(t.td,{children:"true (Optional) Enabled on the write side"}),(0,a.jsxs)(t.td,{children:["Enable the internal metadata table which serves table metadata like level file listings. For 0.10.1 and prior releases, metadata table is disabled by default and needs to be explicitly enabled.",(0,a.jsx)("br",{}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Config Param: ENABLE"}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Since Version: 0.7.0"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hoodie.metadata.index.bloom.filter.enable"}),(0,a.jsx)(t.td,{children:"false (Optional)"}),(0,a.jsxs)(t.td,{children:["Enable indexing bloom filters of user data files under metadata table. When enabled, metadata table will have a partition to store the bloom filter index and will be used during the index lookups.",(0,a.jsx)("br",{}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Config Param: ENABLE_METADATA_INDEX_BLOOM_FILTER"}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Since Version: 0.11.0"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hoodie.metadata.index.column.stats.enable"}),(0,a.jsx)(t.td,{children:"false (Optional)"}),(0,a.jsxs)(t.td,{children:["Enable indexing column ranges of user data files under metadata table key lookups. When enabled, metadata table will have a partition to store the column ranges and will be used for pruning files during the index lookups.",(0,a.jsx)("br",{}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Config Param: ENABLE_METADATA_INDEX_COLUMN_STATS"}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Since Version: 0.11.0"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hoodie.metadata.record.index.enable"}),(0,a.jsx)(t.td,{children:"false (Optional)"}),(0,a.jsxs)(t.td,{children:["Create the HUDI Record Index within the Metadata Table",(0,a.jsx)("br",{}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Config Param: RECORD_INDEX_ENABLE_PROP"}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Since Version: 0.14.0"})]})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:["The metadata table with synchronous updates and metadata-table-based file listing are enabled by default.\nThere are prerequisite configurations and steps in ",(0,a.jsx)(t.a,{href:"#deployment-considerations-for-metadata-table",children:"Deployment considerations"})," to\nsafely use this feature.  The metadata table and related file listing functionality can still be turned off by setting\n",(0,a.jsx)(t.a,{href:"/docs/configurations#hoodiemetadataenable",children:(0,a.jsx)(t.code,{children:"hoodie.metadata.enable"})})," to ",(0,a.jsx)(t.code,{children:"false"}),". The\n",(0,a.jsx)(t.a,{href:"https://www.onehouse.ai/blog/introducing-multi-modal-index-for-the-lakehouse-in-apache-hudi",children:"multi-modal index"})," are\ndisabled by default and can be enabled in write side explicitly using the above configs."]}),"\n",(0,a.jsxs)(t.p,{children:["For flink, following are the basic configs of interest to enable metadata based indexes. Please refer\n",(0,a.jsx)(t.a,{href:"https://hudi.apache.org/docs/next/configurations#Flink-Options",children:"here"})," for advanced configs"]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Config Name"}),(0,a.jsx)(t.th,{children:"Default"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"metadata.enabled"}),(0,a.jsx)(t.td,{children:"true (Optional)"}),(0,a.jsxs)(t.td,{children:["Enable the internal metadata table which serves table metadata like level file listings, default enabled",(0,a.jsx)("br",{}),(0,a.jsx)("br",{})," ",(0,a.jsx)(t.code,{children:"Config Param: METADATA_ENABLED"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hoodie.metadata.index.column.stats.enable"}),(0,a.jsx)(t.td,{children:"false (Optional)"}),(0,a.jsxs)(t.td,{children:["Enable indexing column ranges of user data files under metadata table key lookups. When enabled, metadata table will have a partition to store the column ranges and will be used for pruning files during the index lookups.",(0,a.jsx)("br",{})]})]})]})]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"If you turn off the metadata table after enabling, be sure to wait for a few commits so that the metadata table is fully\ncleaned up, before re-enabling the metadata table again."})}),"\n",(0,a.jsx)(t.h2,{id:"leveraging-metadata-during-queries",children:"Leveraging metadata during queries"}),"\n",(0,a.jsx)(t.h3,{id:"files-index",children:"files index"}),"\n",(0,a.jsxs)(t.p,{children:["Metadata based listing using ",(0,a.jsx)(t.em,{children:"files_index"})," can be leveraged on the read side by setting appropriate configs/session properties\nfrom different engines as shown below:"]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Readers"}),(0,a.jsx)(t.th,{children:"Config"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Spark DataSource"}),(0,a.jsx)("li",{children:"Spark SQL"}),(0,a.jsx)("li",{children:"Strucured Streaming"})]})}),(0,a.jsx)(t.td,{children:"hoodie.metadata.enable"}),(0,a.jsxs)(t.td,{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," enables use of the spark file index implementation for Hudi, that speeds up listing of large tables.",(0,a.jsx)("br",{})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Presto"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"https://prestodb.io/docs/current/connector/hudi.html",children:"hudi.metadata-table-enabled"})}),(0,a.jsxs)(t.td,{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," fetches the list of file names and sizes from Hudi\u2019s metadata table rather than storage."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Trino"}),(0,a.jsx)(t.td,{children:"N/A"}),(0,a.jsxs)(t.td,{children:["Support for reading from the metadata table ",(0,a.jsx)(t.a,{href:"https://issues.apache.org/jira/browse/HUDI-7020",children:"has been dropped in Trino 419"}),"."]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"Athena"}),(0,a.jsx)(t.td,{children:(0,a.jsx)(t.a,{href:"https://docs.aws.amazon.com/athena/latest/ug/querying-hudi.html",children:"hudi.metadata-listing-enabled"})}),(0,a.jsxs)(t.td,{children:["When this table property is set to ",(0,a.jsx)(t.code,{children:"TRUE"})," enables the Hudi metadata table and the related file listing functionality"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Flink DataStream"}),(0,a.jsx)("li",{children:"Flink SQL"})]})}),(0,a.jsx)(t.td,{children:"metadata.enabled"}),(0,a.jsxs)(t.td,{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," from DDL uses the internal metadata table to serves table metadata like level file listings"]})]})]})]}),"\n",(0,a.jsx)(t.h3,{id:"column_stats-index-and-data-skipping",children:"column_stats index and data skipping"}),"\n",(0,a.jsx)(t.p,{children:"Enabling metadata table and column stats index is a prerequisite to enabling data skipping capabilities. Following are the\ncorresponding configs across Spark and Flink readers."}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"Readers"}),(0,a.jsx)(t.th,{children:"Config"}),(0,a.jsx)(t.th,{children:"Description"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Spark DataSource"}),(0,a.jsx)("li",{children:"Spark SQL"}),(0,a.jsx)("li",{children:"Strucured Streaming"})]})}),(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:(0,a.jsx)(t.code,{children:"hoodie.metadata.enable"})}),(0,a.jsx)("li",{children:(0,a.jsx)(t.code,{children:"hoodie.enable.data.skipping"})})]})}),(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," enables use of the spark file index implementation for Hudi, that speeds up listing of large tables."]}),(0,a.jsxs)("li",{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," enables data-skipping allowing queries to leverage indexes to reduce the search space by skipping over files ",(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Config Param: ENABLE_DATA_SKIPPING"}),(0,a.jsx)("br",{}),(0,a.jsx)(t.code,{children:"Since Version: 0.10.0"})," ",(0,a.jsx)("br",{})]})]})})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:"Flink DataStream"}),(0,a.jsx)("li",{children:"Flink SQL"})]})}),(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsx)("li",{children:(0,a.jsx)(t.code,{children:"metadata.enabled"})}),(0,a.jsx)("li",{children:(0,a.jsx)(t.code,{children:"read.data.skipping.enabled"})})]})}),(0,a.jsx)(t.td,{children:(0,a.jsxs)("ul",{children:[(0,a.jsxs)("li",{children:[" When set to ",(0,a.jsx)(t.code,{children:"true"})," from DDL uses the internal metadata table to serves table metadata like level file listings"]}),(0,a.jsxs)("li",{children:["When set to ",(0,a.jsx)(t.code,{children:"true"})," enables data-skipping allowing queries to leverage indexes to reduce the search space byskipping over files"]})]})})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"deployment-considerations-for-metadata-table",children:"Deployment considerations for metadata Table"}),"\n",(0,a.jsxs)(t.p,{children:["To ensure that metadata table stays up to date, all write operations on the same Hudi table need additional configurations\nbesides the above in different deployment models.  Before enabling metadata table, all writers on the same table must\nbe stopped. Please refer to the different ",(0,a.jsx)(t.a,{href:"/docs/concurrency_control#deployment-models-with-supported-concurrency-controls",children:"deployment models"}),"\nfor more details on each model. This section only highlights how to safely enable metadata table in different deployment models."]}),"\n",(0,a.jsx)(t.h3,{id:"deployment-model-a-single-writer-with-inline-table-services",children:"Deployment Model A: Single writer with inline table services"}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"/docs/concurrency_control#model-a-single-writer-with-inline-table-services",children:"Model A"}),", after setting ",(0,a.jsx)(t.a,{href:"/docs/configurations#hoodiemetadataenable",children:(0,a.jsx)(t.code,{children:"hoodie.metadata.enable"})})," to ",(0,a.jsx)(t.code,{children:"true"}),", restarting\nthe single writer is sufficient to safely enable metadata table."]}),"\n",(0,a.jsx)(t.h3,{id:"deployment-model-b-single-writer-with-async-table-services",children:"Deployment Model B: Single writer with async table services"}),"\n",(0,a.jsxs)(t.p,{children:["If your current deployment model is ",(0,a.jsx)(t.a,{href:"/docs/concurrency_control#model-b-single-writer-with-async-table-services",children:"Model B"}),", enabling metadata\ntable requires adding optimistic concurrency control along with suggested lock provider like below."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-properties",children:"hoodie.write.concurrency.mode=optimistic_concurrency_control\nhoodie.write.lock.provider=org.apache.hudi.client.transaction.lock.InProcessLockProvider\n"})}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsx)(t.p,{children:"These configurations are required only if metadata table is enabled in this deployment model."})}),"\n",(0,a.jsxs)(t.p,{children:["If multiple writers in different processes are present, including one writer with async table services, please refer to\n",(0,a.jsx)(t.a,{href:"#deployment-model-c-multi-writer",children:"Deployment Model C: Multi-writer"})," for configs, with the difference of using a\ndistributed lock provider.  Note that running a separate compaction (",(0,a.jsx)(t.code,{children:"HoodieCompactor"}),") or clustering (",(0,a.jsx)(t.code,{children:"HoodieClusteringJob"}),")\njob apart from the ingestion writer is considered as multi-writer deployment, as they are not running in the same\nprocess which cannot rely on the in-process lock provider."]}),"\n",(0,a.jsx)(t.h3,{id:"deployment-model-c-multi-writer",children:"Deployment Model C: Multi-writer"}),"\n",(0,a.jsxs)(t.p,{children:["If your current deployment model is ",(0,a.jsx)(t.a,{href:"/docs/concurrency_control#model-c-multi-writer",children:"multi-writer"})," along with a lock\nprovider and other required configs set for every writer as follows, there is no additional configuration required. You\ncan bring up the writers sequentially after stopping the writers for enabling metadata table. Applying the proper\nconfigurations to only partial writers leads to loss of data from the inconsistent writer. So, ensure you enable\nmetadata table across all writers."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-properties",children:"hoodie.write.concurrency.mode=optimistic_concurrency_control\nhoodie.write.lock.provider=<distributed-lock-provider-classname>\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Note that there are different external ",(0,a.jsx)(t.a,{href:"/docs/concurrency_control#external-locking-and-lock-providers",children:"lock providers available"}),"\nto choose from."]}),"\n",(0,a.jsx)(t.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,a.jsx)("h3",{children:"Blogs"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://medium.com/@simpsons/table-service-deployment-models-in-apache-hudi-9cfa5a44addf",children:"Table service deployment models in Apache Hudi"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>l});var i=n(96540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);