"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[48501],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var i=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,i,n=function(e,t){if(null==e)return{};var a,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)a=r[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=i.createContext({}),c=function(e){var t=i.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(a),h=n,u=p["".concat(s,".").concat(h)]||p[h]||m[h]||r;return a?i.createElement(u,l(l({ref:t},d),{},{components:a})):i.createElement(u,l({ref:t},d))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,l=new Array(r);l[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,l[1]=o;for(var c=2;c<r;c++)l[c]=a[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,a)}p.displayName="MDXCreateElement"},31077:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var i=a(87462),n=(a(67294),a(3905));const r={},l="Apache Hudi Technical Specification [DRAFT]",o={type:"mdx",permalink:"/tech-specs",source:"@site/src/pages/tech-specs.md"},s=[{value:"Overview",id:"overview",children:[],level:2},{value:"Storage Format",id:"storage-format",children:[{value:"Data Layout",id:"data-layout",children:[],level:3},{value:"Table Types",id:"table-types",children:[],level:3},{value:"Data Model",id:"data-model",children:[{value:"User fields",id:"user-fields",children:[],level:4},{value:"Meta fields",id:"meta-fields",children:[],level:4}],level:3}],level:2},{value:"Transaction Log (Timeline)",id:"transaction-log-timeline",children:[],level:2},{value:"Metadata",id:"metadata",children:[],level:2},{value:"File Layout Hierarchy",id:"file-layout-hierarchy",children:[{value:"<strong>Base file</strong>",id:"base-file",children:[],level:3},{value:"Log File Format",id:"log-file-format",children:[{value:"Log file format block types",id:"log-file-format-block-types",children:[{value:"Command Block (Id: 1)",id:"command-block-id-1",children:[],level:5},{value:"Delete Block (Id: 2)",id:"delete-block-id-2",children:[],level:5},{value:"Corrupted Block (Id: 3)",id:"corrupted-block-id-3",children:[],level:5},{value:"Avro Block (Id: 4)",id:"avro-block-id-4",children:[],level:5},{value:"HFile Block (Id: 5)",id:"hfile-block-id-5",children:[],level:5},{value:"Parquet Block (Id: 6)",id:"parquet-block-id-6",children:[],level:5}],level:4}],level:3}],level:2},{value:"Reader Expectations",id:"reader-expectations",children:[],level:2},{value:"Writer Expectations",id:"writer-expectations",children:[],level:2},{value:"Balancing write and query performance",id:"balancing-write-and-query-performance",children:[{value:"Table types",id:"table-types-1",children:[],level:4},{value:"Record merging",id:"record-merging",children:[],level:4},{value:"File sizing",id:"file-sizing",children:[],level:4}],level:2},{value:"Table Management",id:"table-management",children:[{value:"Compaction",id:"compaction",children:[],level:3},{value:"Clustering",id:"clustering",children:[],level:3},{value:"Cleaning",id:"cleaning",children:[],level:3}],level:2},{value:"Concurrency Control",id:"concurrency-control",children:[{value:"Multiple concurrent readers",id:"multiple-concurrent-readers",children:[],level:3},{value:"Concurrency control with writes",id:"concurrency-control-with-writes",children:[{value:"Optimistic concurrency efficiency",id:"optimistic-concurrency-efficiency",children:[],level:4}],level:3}],level:2}],c={toc:s};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"apache-hudi-technical-specification-draft"},"Apache Hudi Technical Specification ","[DRAFT]"),(0,n.kt)("p",null,"This document is a specification for the Hudi's Storage Format which transforms immutable cloud/file storage systems into transactional data lakes. "),(0,n.kt)("h2",{id:"overview"},"Overview"),(0,n.kt)("p",null,"Hudi Storage Format enables the following features over very large collections of files/objects"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Stream processing primitives like incremental merges, change stream etc"),(0,n.kt)("li",{parentName:"ul"},"Database primitives like tables, transactions, mutability, indexes and query performance optimizations ")),(0,n.kt)("p",null,"Apache Hudi is an open source data lake platform that is built on top of the Hudi Storage Format and it unlocks the following capabilities. "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Unified Computation Model")," - a unified way to combine large batch style operations and frequent near real time streaming operations over large datasets."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Self-Optimized Storage")," - automatically handle all the table storage maintenance such as compaction, clustering, vacuuming asynchronously and in most cases non-blocking to actual data changes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Cloud Native Database")," - abstracts Table/Schema from actual storage and ensures up-to-date metadata and indexes unlocking multi-fold read and write performance optimizations."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Engine Neutrality")," - designed to be neutral and without any assumptions on the preferred computation engine. Apache Hudi will manage metadata, and provide common abstractions and pluggable interfaces to most/all common compute/query engines.")),(0,n.kt)("p",null,"This document is intended as reference guide for any compute engines, that aim to write/read Hudi tables, by interacting with the storage format directly."),(0,n.kt)("h2",{id:"storage-format"},"Storage Format"),(0,n.kt)("h3",{id:"data-layout"},"Data Layout"),(0,n.kt)("p",null,"At a high level, Hudi organizes data into a directory structure under the base path (root directory for the Hudi table). The directory structure can be flat (non-partitioned) or based on coarse-grained partitioning values set for the table. Non-partitioned tables store all the data files under the base path.\nNote that, unlike Hive style partitioning, partition columns are not removed from data files and partitioning is a mere organization of data files. A special reserved ",(0,n.kt)("em",{parentName:"p"},".hoodie")," directory under the base path is used to store transaction logs and metadata."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"/data/hudi_trips/                   <== BASE PATH\n\u251c\u2500\u2500 .hoodie/                        <== META PATH\n\u2502   \u2514\u2500\u2500 metadata/ \n\u251c\u2500\u2500 americas/\n\u2502   \u251c\u2500\u2500 brazil/\n\u2502   \u2502   \u2514\u2500\u2500 sao_paulo/              <== PARTITION PATH \n\u2502   \u2502       \u251c\u2500\u2500 <data_files>\n\u2502   \u2514\u2500\u2500 united_states/\n\u2502       \u2514\u2500\u2500 san_francisco/\n\u2502           \u251c\u2500\u2500 <data_files>\n\u2514\u2500\u2500 asia/\n    \u2514\u2500\u2500 india/\n        \u2514\u2500\u2500 chennai/\n            \u251c\u2500\u2500 <data_files>\n")),(0,n.kt)("h3",{id:"table-types"},"Table Types"),(0,n.kt)("p",null,"Hudi storage format supports two table types offering different trade-offs between ingest and query performance and the data files are stored differently based on the chosen table type.\nBroadly, there can be two types of data files "),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"Base files")," - Files that contain a set of records in columnar file formats like Apache Parquet/Orc or indexed formats like HFile format."),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},"log files")," - Log files contain inserts, updates, deletes issued against a base file, encoded as a series of blocks. More on this ",(0,n.kt)("a",{parentName:"li",href:"#log-file-format"},"below"),".")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Table Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Trade-off"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Copy-on-Write (CoW)"),(0,n.kt)("td",{parentName:"tr",align:null},"Data is stored entirely in base files, optimized for read performance and ideal for slow changing datasets")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Merge-on-read (MoR)"),(0,n.kt)("td",{parentName:"tr",align:null},"Data is stored in a combination of base and log files, optimized to ",(0,n.kt)("a",{parentName:"td",href:"##balancing-write-and-query-performance"},"balance the write and read performance")," and ideal for frequently changing datasets")))),(0,n.kt)("h3",{id:"data-model"},"Data Model"),(0,n.kt)("p",null,"Hudi's data model is designed like an update-able database like a key-value store. Within each partition, data is organized into key-value model, where every record is uniquely identified with a record key. "),(0,n.kt)("h4",{id:"user-fields"},"User fields"),(0,n.kt)("p",null,"To write a record into a Hudi table, each record must specify the following user fields."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"User fields"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Partitioning key ","[Optional]"),(0,n.kt)("td",{parentName:"tr",align:null},"Value of this field defines the directory hierarchy within the table base path. This essentially provides an hierarchy isolation for managing data and related metadata")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Record key(s)"),(0,n.kt)("td",{parentName:"tr",align:null},"Record keys uniquely identify a record within each partition if partitioning is enabled")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Ordering field(s)"),(0,n.kt)("td",{parentName:"tr",align:null},"Hudi guarantees the uniqueness constraint of record key and the conflict resolution configuration manages strategies on how to disambiguate when multiple records with the same keys are to be merged into the table. The resolution logic can be based on an ordering field or can be custom, specific to the table. To ensure consistent behaviour dealing with duplicate records, the resolution logic should be commutative, associative and idempotent. This is also referred to as \u2018precombine field\u2019.")))),(0,n.kt)("h4",{id:"meta-fields"},"Meta fields"),(0,n.kt)("p",null,"In addition to the fields specified by the table's schema, the following meta fields are added to each record, to unlock incremental processing and ease of debugging. These meta fields are part of the table schema and\nstored with the actual record to avoid re-computation. "),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Hudi meta-fields"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"_","hoodie","_","commit","_","time"),(0,n.kt)("td",{parentName:"tr",align:null},"This field contains the commit timestamp in the ",(0,n.kt)("a",{parentName:"td",href:"#transaction-log-timeline"},"timeline")," that created this record. This enables granular, record-level history tracking on the table, much like database change-data-capture.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"_","hoodie","_","commit","_","seqno"),(0,n.kt)("td",{parentName:"tr",align:null},"This field contains a unique sequence number for each record within each transaction. This serves much like offsets in Apache Kafka topics, to enable generating streams out of tables.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"_","hoodie","_","record","_","key"),(0,n.kt)("td",{parentName:"tr",align:null},"Unique record key identifying the record within the partition. Key is materialized to avoid changes to key field(s) resulting in violating unique constraints maintained within a table.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"_","hoodie","_","partition","_","path"),(0,n.kt)("td",{parentName:"tr",align:null},"Partition path under which the record is organized into.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"_","hoodie","_","file","_","name"),(0,n.kt)("td",{parentName:"tr",align:null},"The data file name this record belongs to.")))),(0,n.kt)("p",null,"Within a given file, all records share the same values for ",(0,n.kt)("inlineCode",{parentName:"p"},"_hoodie_partition_path")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"_hoodie_file_name"),", thus easily compressed away without any overheads with columnar file formats. The other fields can also be optional for writers\ndepending on whether protection against key field changes or incremental processing is desired. More on how to populate these fields in the sections below."),(0,n.kt)("h2",{id:"transaction-log-timeline"},"Transaction Log (Timeline)"),(0,n.kt)("p",null,"Hudi serializes all actions performed on a table into an event log - called the ",(0,n.kt)("strong",{parentName:"p"},"Timeline"),". Every transactional action on the Hudi table creates a new entry (instant) in the timeline.\nData consistency in Hudi is provided using Multi-version Concurrency Control (MVCC) and all transactional actions follow the state transitions below, to move each ",(0,n.kt)("a",{parentName:"p",href:"#file-layout-hierarchy"},"file group")," from one consistent state to another."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"requested")," - Action is planned and requested to start on the timeline. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"inflight")," - Action has started running and is currently in-flight. Actions are idempotent, and could fail many times in this state."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"completed")," - Action has completed running")),(0,n.kt)("p",null,"All actions and the state transitions are registered with the timeline using an atomic write of a special meta-file inside the  ",(0,n.kt)("em",{parentName:"p"},".hoodie")," directory. The requirement from the underlying storage system is to support an atomic-put and read-after-write consistency.\nThe meta file naming structure is as follows"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"[Action timestamp].[Action type].[Action state] \n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Action timestamp:"),"\nMonotonically increasing value to denote strict ordering of actions in the timeline. This could be provided by an external token provider or rely on the system epoch time at millisecond granularity."),(0,n.kt)("p",null," ",(0,n.kt)("strong",{parentName:"p"},"Action type:"),"\nType of action. The following are the actions on the Hudi timeline."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Action type"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"commit"),(0,n.kt)("td",{parentName:"tr",align:null},"Commit denotes an ",(0,n.kt)("strong",{parentName:"td"},"atomic write (inserts, updates and deletes)")," of records in a table. A commit in Hudi is an atomic way of updating data, metadata and indexes. The guarantee is that all or none the changes within a commit will be visible to the readers")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"deltacommit"),(0,n.kt)("td",{parentName:"tr",align:null},"Special version of ",(0,n.kt)("inlineCode",{parentName:"td"},"commit")," which is applicable only on a Merge-on-Read storage engine. The writes are accumulated and batched to improve write performance")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"rollback"),(0,n.kt)("td",{parentName:"tr",align:null},"Rollback denotes that the changes made by the corresponding commit/delta commit were unsuccessful & hence rolled back, removing any partial files produced during such a write")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"savepoint"),(0,n.kt)("td",{parentName:"tr",align:null},"Savepoint is a special marker to ensure a particular commit is not automatically cleaned. It helps restore the table to a point on the timeline, in case of disaster/data recovery scenarios")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"restore"),(0,n.kt)("td",{parentName:"tr",align:null},"Restore denotes that the table was restored to a particular savepoint.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"clean"),(0,n.kt)("td",{parentName:"tr",align:null},"Management activity that cleans up versions of data files that no longer will be accessed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"compaction"),(0,n.kt)("td",{parentName:"tr",align:null},"Management activity to optimize the storage for query performance. This action applies the batched up updates from ",(0,n.kt)("inlineCode",{parentName:"td"},"deltacommit")," and re-optimizes data files for query performance")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"replacecommit"),(0,n.kt)("td",{parentName:"tr",align:null},"Management activity to replace a set of data files atomically with another. It can be used to cluster the data for better query performance. This action is different from a ",(0,n.kt)("inlineCode",{parentName:"td"},"commit")," in that the table state before and after are logically equivalent")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"indexing"),(0,n.kt)("td",{parentName:"tr",align:null},"Management activity to update the index with the data. This action does not change data, only updates the index aynchronously to data changes")))),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Action state:"),"\nDenotes the state transition identifier (requested -",">"," inflight -",">"," completed)"),(0,n.kt)("p",null,"Meta-files with requested transaction state contain any planning details, If an action requires generating a plan of execution, this is done before requesting and is persisted in the Meta-file. The data is serialized as Json/Avro, and the schema for each of these actions are as follows"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"replacecommit")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieRequestedReplaceMetadata.avsc"},"HoodieRequestedReplaceMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"restore")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieRestorePlan.avsc"},"HoodieRestorePlan")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"rollback"),"- ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieRollbackPlan.avsc"},"HoodieRollbackPlan")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"clean"),"  - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieCleanerPlan.avsc"},"HoodieCleanerPlan")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"indexing")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieIndexPlan.avsc"},"HoodieIndexPlan"))),(0,n.kt)("p",null,"Meta-files with completed transaction state contain details about the transaction completed such as the number of inserts/updates/deletes per file ID, file size, and some extra metadata such as checkpoint and schema for the batch of records written. Similar to the requested action state, the data is serialized as Json/Avro, and the schema as follows"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"commit")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieCommitMetadata.avsc"},"HoodieCommitMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"deltacommit")," -  ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieCommitMetadata.avsc"},"HoodieCommitMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"rollback"),"- ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieRollbackMetadata.avsc"},"HoodieRollbackMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"savepoint")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieSavePointMetadata.avsc"},"HoodieSavepointMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"restore")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieRestoreMetadata.avsc"},"HoodieRestoreMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"clean"),"  - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieCleanMetadata.avsc"},"HoodieCleanMetadata")," "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"compaction")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieCompactionMetadata.avsc"},"HoodieCompactionMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"replacecommit")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieReplaceCommitMetadata.avsc"},"HoodieReplaceCommitMetadata")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"indexing")," - ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieIndexCommitMetadata.avsc"},"HoodieIndexCommitMetadata"))),(0,n.kt)("p",null,"By reconciling all the actions in the timeline, the state of the Hudi table can be re-created as of any instant of time.  "),(0,n.kt)("p",null,"\u200b\t"),(0,n.kt)("h2",{id:"metadata"},"Metadata"),(0,n.kt)("p",null,"Hudi automatically extracts the physical data statistics and stores the metadata along with the data to improve write and query performance. Hudi Metadata is an internally-managed table which organizes the table metadata under the base path ",(0,n.kt)("em",{parentName:"p"},".hoodie/metadata.")," The metadata is in itself a Hudi table, organized with the Hudi merge-on-read storage format. Every record stored in the metadata table is a Hudi record and hence has partitioning key and record key specified. Following are the metadata table partitions"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"files")," - Partition path to file name index. Key for the Hudi record is the partition path and the actual record is a map of file name to an instance of ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieMetadata.avsc#L34"},"HoodieMetadataFileInfo"),". The files index can be used to do file listing and do filter based pruning of the scanset during query"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"bloom","_","filters")," - Bloom filter index to help map a record key to the actual file. The Hudi key is ",(0,n.kt)("inlineCode",{parentName:"li"},"str_concat(hash(partition name), hash(file name))")," and the actual payload is an instance of ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieMetadata.avsc#L66"},"HudiMetadataBloomFilter"),". Bloom filter is used to accelerate 'presence checks' validating whether particular record is present in the file, which is used during merging, hash-based joins, point-lookup queries, etc."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"column","_","stats")," - contains statistics of columns for all the records in the table. This enables fine grained file pruning for filters and join conditions in the query. The actual payload is an instance of ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/apache/hudi/blob/master/hudi-common/src/main/avro/HoodieMetadata.avsc#L101"},"HoodieMetadataColumnStats"),". ")),(0,n.kt)("p",null,"Apache Hudi platform employs HFile format, to store metadata and indexes, to ensure high performance, though different implementations are free to choose their own. "),(0,n.kt)("h2",{id:"file-layout-hierarchy"},"File Layout Hierarchy"),(0,n.kt)("p",null,"As mentioned in the data model, data is partitioned coarsely through a directory hierarchy based on the partition path configured. Within each partition the data is physically stored as ",(0,n.kt)("strong",{parentName:"p"},"base and log files")," and organized into logical concepts as ",(0,n.kt)("strong",{parentName:"p"},"File groups and File slices"),". These logical concepts will be referred to by the writer / reader requirements. "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"File group")," - Groups multiple versions of a base file. File group is uniquely identified by a File id. Each version corresponds to the commit's timestamp recording updates to records in the file. The base files are stored in open source data formats like  Apache Parquet, Apache ORC, Apache HBase HFile etc."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"File slice")," - A File group can further be split into multiple slices. Each file slice within the file-group is uniquely identified by commit's timestamp that created it. In case of COW, file-slice is simply just another version of the base-file. In case of MOR it's a combination of the base-file along with log-files attached to it. Each log-file corresponds to the delta commit in the timeline. "),(0,n.kt)("h3",{id:"base-file"},(0,n.kt)("strong",{parentName:"h3"},"Base file")),(0,n.kt)("p",null,"The base file name format is:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"[File Id]_[File Write Token]_[Transaction timestamp].[File Extension]\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"File Id")," - Uniquely identify a base file within the table. Multiple versions of the base file share the same file id."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"File Write Token")," - Monotonically increasing token for every attempt to write the base file. This should help uniquely identifying the base file when there are failures and retries. Cleaning can remove partial/uncommitted base files if the write token is not the latest in the file group "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Commit timestamp")," - Timestamp matching the commit instant in the timeline that created this base file"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"File Extension")," - base file extension to denote the open source file format such as .parquet, .orc")),(0,n.kt)("h3",{id:"log-file-format"},"Log File Format"),(0,n.kt)("p",null,"The log file name format is:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"[File Id]_[Base Transaction timestamp].[Log File Extension].[Log File Version]_[File Write Token]\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"File Id")," - File Id of the base file in the slice"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Base Transaction timestamp")," - Commit timestamp on the base file for which the log file is updating the deletes/updates for"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Log File Extension")," - Extension defines the format used for the log file (e.g. Hudi proprietary log format)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Log File Version")," - Current version of the log file format"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"File Write Token")," - Monotonically increasing token for every attempt to write the log file. This should help uniquely identifying the log file when there are failures and retries. Cleaner can clean-up partial log files if the write token is not the latest in the file slice.")),(0,n.kt)("p",null,"The Log file format structure is a Hudi native format. The actual content bytes are serialized into one of Apache Avro, Apache Parquet or Apache HFile file formats based on configuration and the other metadata in the block is serialized using the Java DataOutputStream (DOS) serializer."),(0,n.kt)("p",null,"Hudi Log format specification is as follows. "),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"/assets/images/hudi_log_format_v2.png",alt:"hudi_log_format_v2"})),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Section"),(0,n.kt)("th",{parentName:"tr",align:null},"#","Bytes"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"magic")),(0,n.kt)("td",{parentName:"tr",align:null},"6"),(0,n.kt)("td",{parentName:"tr",align:null},"6 Characters '#HUDI#' stored as a byte array. Sanity check for block corruption to assert start 6 bytes matches the magic byte[].")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"LogBlock length")),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"Length of the block excluding the magic.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"version")),(0,n.kt)("td",{parentName:"tr",align:null},"4"),(0,n.kt)("td",{parentName:"tr",align:null},"Version of the Log file format, monotonically increasing to support backwards compatibility")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"type")),(0,n.kt)("td",{parentName:"tr",align:null},"4"),(0,n.kt)("td",{parentName:"tr",align:null},"Represents the type of the log block. Id of the type is serialized as an Integer.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"header length")),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"Length of the header section to follow")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"header")),(0,n.kt)("td",{parentName:"tr",align:null},"variable"),(0,n.kt)("td",{parentName:"tr",align:null},"Map of header metadata entries. The entries are encoded with key as a metadata Id and the value is the String representation of the metadata value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"content length")),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"Length of the actual content serialized")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"content")),(0,n.kt)("td",{parentName:"tr",align:null},"variable"),(0,n.kt)("td",{parentName:"tr",align:null},"The content contains the serialized records in one of the supported file formats (Apache Avro, Apache Parquet or Apache HFile)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"footer length")),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"Length of the footer section to follow")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"footer")),(0,n.kt)("td",{parentName:"tr",align:null},"variable"),(0,n.kt)("td",{parentName:"tr",align:null},"Similar to Header. Map of footer metadata entries. The entries are encoded with key as a metadata Id and the value is the String representation of the metadata value.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"total block length")),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"Total size of the block including the magic bytes. This is used to determine if a block is corrupt by comparing to the block size in the header. Each log block assumes that the block size will be last data written in a block. Any data if written after is just ignored.")))),(0,n.kt)("p",null,"Metadata key mapping from Integer to actual metadata is as follows"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Instant Time (encoding id: 1)"),(0,n.kt)("li",{parentName:"ol"},"Target Instant Time (encoding id: 2)"),(0,n.kt)("li",{parentName:"ol"},"Command Block Type (encoding id: 3)")),(0,n.kt)("h4",{id:"log-file-format-block-types"},"Log file format block types"),(0,n.kt)("p",null,"The following are the possible block types used in Hudi Log Format:"),(0,n.kt)("h5",{id:"command-block-id-1"},"Command Block (Id: 1)"),(0,n.kt)("p",null,"Encodes a command to the log reader. The Command block must be 0 byte content block which only populates the metadata Command Block Type. Only possible values in the current version of the log format is ROLLBACK","_","PREVIOUS","_","BLOCK, which lets the reader to undo the previous block written in the log file. This denotes that the previous action that wrote the log block was unsuccessful. "),(0,n.kt)("h5",{id:"delete-block-id-2"},"Delete Block (Id: 2)"),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"/assets/images/spec/spec_log_format_delete_block.png",alt:"spec_log_format_delete_block"})),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Section"),(0,n.kt)("th",{parentName:"tr",align:null},"#","bytes"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"format version"),(0,n.kt)("td",{parentName:"tr",align:null},"4"),(0,n.kt)("td",{parentName:"tr",align:null},"version of the log file format")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"length"),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"length of the deleted keys section to follow")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"deleted keys"),(0,n.kt)("td",{parentName:"tr",align:null},"variable"),(0,n.kt)("td",{parentName:"tr",align:null},"Tombstone of the record to encode a delete.  The following 3 fields are serialized using the KryoSerializer.  ",(0,n.kt)("strong",{parentName:"td"},"Record Key")," - Unique record key within the partition to deleted ",(0,n.kt)("strong",{parentName:"td"},"Partition Path")," - Partition path of the record deleted ",(0,n.kt)("strong",{parentName:"td"},"Ordering Value")," - In a particular batch of updates, the delete block is always written after the data (Avro/HFile/Parquet) block. This field would preserve the ordering of deletes and inserts within the same batch.")))),(0,n.kt)("h5",{id:"corrupted-block-id-3"},"Corrupted Block (Id: 3)"),(0,n.kt)("p",null,"This block type is never written to persistent storage. While reading a log block, if the block is corrupted, then the reader gets an instance of the Corrupted Block instead of a Data block. "),(0,n.kt)("h5",{id:"avro-block-id-4"},"Avro Block (Id: 4)"),(0,n.kt)("p",null,"Data block serializes the actual records written into the log file"),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"/assets/images/spec/spec_log_format_avro_block.png",alt:"spec_log_format_avro_block"})),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Section"),(0,n.kt)("th",{parentName:"tr",align:null},"#","bytes"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"format version"),(0,n.kt)("td",{parentName:"tr",align:null},"4"),(0,n.kt)("td",{parentName:"tr",align:null},"version of the log file format")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"record count"),(0,n.kt)("td",{parentName:"tr",align:null},"4"),(0,n.kt)("td",{parentName:"tr",align:null},"total number of records in this block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"record length"),(0,n.kt)("td",{parentName:"tr",align:null},"8"),(0,n.kt)("td",{parentName:"tr",align:null},"length of the record content to follow")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"record content"),(0,n.kt)("td",{parentName:"tr",align:null},"variable"),(0,n.kt)("td",{parentName:"tr",align:null},"Record represented as an Avro record serialized using BinaryEncoder")))),(0,n.kt)("h5",{id:"hfile-block-id-5"},"HFile Block (Id: 5)"),(0,n.kt)("p",null,"The HFile data block serializes the records using the HFile file format. HFile data model is a key value pair and both are encoded as byte arrays. Hudi record key is encoded as Avro string and the Avro record serialized using BinaryEncoder is stored as the value. HFile file format stores the records in sorted order and with index to enable quick point reads and range scans. "),(0,n.kt)("h5",{id:"parquet-block-id-6"},"Parquet Block (Id: 6)"),(0,n.kt)("p",null,"The Parquet Block serializes the records using the Apache Parquet file format. The serialization layout is similar to the Avro block except for the byte array content encoded in columnar Parquet format. This log block type enables efficient columnar scans and better compression. "),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Different data block types offers different trade-offs and picking the right block is based on the workload requirements and is critical for merge and read performance. ")),(0,n.kt)("h2",{id:"reader-expectations"},"Reader Expectations"),(0,n.kt)("p",null,"Readers will use snapshot isolation to query a Hudi table at a consistent point in time in the Hudi timeline.  The reader constructs the snapshot state using the following steps"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Pick an instant in the timeline (last successful commit or a specific commit version explicitly queried) and set that the commit time to compute the list of files to read from. "),(0,n.kt)("li",{parentName:"ol"},"For the picked commit time, compute all the file slices that belong to that specific commit time. For all the partition paths involved in the query, the file slices that belong to a successful commit before the picked commit should be included. The lookup on the filesystem could be slow and inefficient and can be further optimized by caching in memory or using the files (mapping partition path to filenames) index or with the support of an external timeline serving system.  "),(0,n.kt)("li",{parentName:"ol"},"For the MoR table type, ensure the appropriate merging rules are applied to apply the updates queued for the base in the log files.",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"Contents of the log files should be loaded into an effective point lookup data structure (in-memory or persisted)"),(0,n.kt)("li",{parentName:"ol"},"Duplicate record keys should be merged based on the ordering field specified. It is important to order the inserts and deletes in the right order to be consistent and idempotent. "),(0,n.kt)("li",{parentName:"ol"},"When the base file is scanned, for every record block, the reader has to lookup if there is a newer version of the data available for the record keys in the block and merge them into the record iterator. ")))),(0,n.kt)("h2",{id:"writer-expectations"},"Writer Expectations"),(0,n.kt)("p",null,"Writer into Hudi will have to ingest new records, updates to existing records or delete records into the table. All transactional actions follow the same state transition as described in the transaction log (timeline) section. Writers will optimistically create new base and log files and will finally transition the action state to completed to register all the modifications to the table atomically. Writer merges the data using the following steps"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Writer will pick a monotonically increasing instant time from the latest state of the Hudi timeline (",(0,n.kt)("strong",{parentName:"li"},"action commit time"),") and will pick the last successful commit instant (",(0,n.kt)("strong",{parentName:"li"},"merge commit time"),") to merge the changes to. If the merge succeeds, then action commit time will be the next successful commit in the timeline. "),(0,n.kt)("li",{parentName:"ol"},"For all the incoming records, the writer will have to efficiently determine if this is an update or insert. This is done by a process called tagging - which is a batched point lookups of the record key and partition path pairs in the entire table. The efficiency of tagging is critical to the merge performance. This can be optimized with indexes (bloom, global key value based index) and caching. New records will not have a tag. "),(0,n.kt)("li",{parentName:"ol"},"Once records are tagged, the writer can apply them onto the specific file slice. ",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"For CoW, writer will create a new slice (action commit time) of the base file in the file group"),(0,n.kt)("li",{parentName:"ol"},"For MoR, writer will create a new log file with the action commit time on the merge commit time file slice"))),(0,n.kt)("li",{parentName:"ol"},"Deletes are encoded as special form of updates where only the meta fields and the operation is populated. See the delete block type in log format block types. "),(0,n.kt)("li",{parentName:"ol"},"Once all the writes into the file system are complete, concurrency control checks happen to ensure there are no overlapping writes and if that succeeds, the commit action is completed in the timeline atomically making the changes merged visible for the next reader.  "),(0,n.kt)("li",{parentName:"ol"},"Synchronizing Indexes and metadata needs to be done in the same transaction that commits the modifications to the table. ")),(0,n.kt)("h2",{id:"balancing-write-and-query-performance"},"Balancing write and query performance"),(0,n.kt)("p",null,"A critical design choice for any table is to pick the right trade-offs in the data freshness and query performance spectrum. Hudi storage format lets the users decide on this trade-off by picking the table type, record merging and file sizing. "),(0,n.kt)("h4",{id:"table-types-1"},"Table types"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null}),(0,n.kt)("th",{parentName:"tr",align:null},"Merge Efficiency"),(0,n.kt)("th",{parentName:"tr",align:null},"Query Efficiency"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Copy on Write (COW)"),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Tunable")," ",(0,n.kt)("br",null),"COW table type creates a new File slice in the file-group for every batch of updates. Write amplification can be quite high when the update is spread across multiple file groups. The cost involved can be high over a time period especially on tables with low data latency requirements."),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Optimal")," ",(0,n.kt)("br",null),"COW table types create whole readable data files in open source columnar file formats on each merge batch, there is minimal overhead per record in the query engine. Query engines are fairly optimized for accessing files directly in cloud storage.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Merge on Read (MOR)"),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Optimal")," ",(0,n.kt)("br",null),"MOR table type batches the updates to the file slice in a separate optimized Log file, write amplification is amortized over time when sufficient updates are batched. The merge cost involved will be lower than COW since the churn on the records re-written for every update is much lower."),(0,n.kt)("td",{parentName:"tr",align:null},(0,n.kt)("strong",{parentName:"td"},"Tunable"),(0,n.kt)("br",null),"MOR Table type required record level merging during query. Although there are techniques to make this merge as efficient as possible, there is still a record level overhead to apply the updates batched up for the file slice. The merge cost applies on every query until the compaction applies the updates and creates a new file slice.")))),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Interesting observation on the MOR table format is that, by providing a special view of the table which only serves the base files in the file slice (read optimized query of MOR table), query can pick between query efficiency and data freshness dynamically during query time. Compaction frequency determines the data freshness of the read optimized view. With this, the MOR has all the levers required to balance the merge and query performance dynamically. ")),(0,n.kt)("h4",{id:"record-merging"},"Record merging"),(0,n.kt)("p",null,"Hudi data model ensures record key uniqueness constraint, to maintain this constraint every single record merged into the table needs to be checked if the same record key already exists in the table. If it does exist, the conflict resolution strategy is applied to create a new merged record to be persisted. This check is done at the file group level and every record merged needs to be tagged to a single file group. By default, record merging is done during the merge which makes it efficient for queries but for certain real-time streaming requirements, it can also be deferred to the query as long as there is a consistent way to mapping the record key to a certain file group using consistent hashing techniques. "),(0,n.kt)("h4",{id:"file-sizing"},"File sizing"),(0,n.kt)("p",null,"Sizing the file group is extremely critical to balance the merge and query performance. Larger the file size, the more the write amplification when new file slices are being created. So to balance the merge cost, compaction or merge frequency should be tuned accordingly and this has an impact on the query performance or data freshness. "),(0,n.kt)("h2",{id:"table-management"},"Table Management"),(0,n.kt)("p",null,"All table services can be run synchronous with the Table client that merges modifications to the data or can be run asynchronously to the table client. Asynchronous is default mode in the Apache Hudi platform.  Any client can trigger table management by registering a 'requested' state action in the Hudi timeline. Process in charge of running the table management tasks asynchronously looks for the presence of this trigger in the timeline. "),(0,n.kt)("h3",{id:"compaction"},"Compaction"),(0,n.kt)("p",null,"Compaction is the process that efficiently updates a file slice (base and log files) for efficient querying. It applies all the batched up updates in the log files and writes a new file slice. The logic to apply the updates to the base file follows the same set of rules listed in the Reader expectations."),(0,n.kt)("h3",{id:"clustering"},"Clustering"),(0,n.kt)("p",null,"If the natural ingestion ordering does not match the query patterns, then data skipping does not work efficiently. It is important for query efficiency to be able to skip as much data on filter and join predicates with column level statistics. Clustering columns need to be specified on the Hudi table. The goal of the clustering table service, is to group data often accessed together and consolidate small files to the optimum target file size for the table. "),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Identify file groups that are eligible for clustering - this is chosen based on the clustering strategy (file size based, time based etc)"),(0,n.kt)("li",{parentName:"ol"},"Identify clustering groups (file groups that should be clustered together) and each group should expect data sizes in multiples of the target file size. "),(0,n.kt)("li",{parentName:"ol"},"Persist the clustering plan in the Hudi timeline as a replacecommit, when clustering is requested."),(0,n.kt)("li",{parentName:"ol"},"Clustering execution can then read the individual clustering groups, write back new file groups with target size with base files sorted by the specified clustering columns. ")),(0,n.kt)("h3",{id:"cleaning"},"Cleaning"),(0,n.kt)("p",null,"Cleaning is a process to free up storage space. Apache Hudi maintains a timeline and multiple versions of the files written as file slices. It is important to specify a cleaning protocol which deletes older versions and reclaims the storage space. Cleaner cannot delete versions that are currently in use or will be required in future. Snapshot reconstruction on a commit instant which has been cleaned is not possible. "),(0,n.kt)("p",null,"For e.g, there are a couple of retention policies supported in Apache Hudi platform"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"keep","_","latest","_","commits"),": This is a temporal cleaning policy that ensures the effect of having look-back into all the changes that happened in the last X commits. "),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"keep","_","latest","_","file","_","versions"),": This policy has the effect of keeping a maximum of N number of file versions irrespective of time. ")),(0,n.kt)("p",null,"Apache Hudi provides snapshot isolation between writers and readers by managing multiple files with MVCC concurrency. These file versions provide history and enable time travel and rollbacks, but it is important to manage how much history you keep to balance your storage costs."),(0,n.kt)("h2",{id:"concurrency-control"},"Concurrency Control"),(0,n.kt)("p",null,"Apache Hudi storage format enables transactional consistencies for reads and writes. "),(0,n.kt)("h3",{id:"multiple-concurrent-readers"},"Multiple concurrent readers"),(0,n.kt)("p",null,"Hudi storage format supports snapshot isolation for concurrent readers. A reader loads the Hudi timeline and picks the latest commit and constructs the snapshot state as of the picked commit. Two concurrent readers are never in contention even in the presence of concurrent writes happening. "),(0,n.kt)("h3",{id:"concurrency-control-with-writes"},"Concurrency control with writes"),(0,n.kt)("p",null,"If there are only inserts to the table, then there will be no conflicts. To better illustrate scenarios with update conflicts, let's categorize writers are 2 types. "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a ",(0,n.kt)("em",{parentName:"li"},"Table write client")," merges new changes to the table, from external sources or as output another computation. "),(0,n.kt)("li",{parentName:"ul"},"a ",(0,n.kt)("em",{parentName:"li"},"Table service client")," does table management services like clustering, compaction, and cleaning et which does not logically change the state of the table. ")),(0,n.kt)("p",null,"Let us look at the various write conflict scenarios"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Multiple table write client conflicts")),(0,n.kt)("p",null,"Conflicts can occur if two or more writers update the same file group and in that case the first transaction to commit succeeds while the rest will need to be aborted and all changes cleaned up. To be able to detect concurrent updates to the same file group, external locking has to be configured. Conflict detection can be optimistic or pessimistic. "),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Under optimistic locking, the table writer makes all new base and log files and before committing the transaction, a table level lock is acquired and if there is a newer slice (version) on any of the file groups modified by the current transaction, the transaction has conflicts and needs to be retried. This works well for highly concurrent unrelated updates. Bulk changes to the tables may starve in the presence of multiple concurrent smaller updates.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Table clients can also hold pessimistic locks on all the file id groups before they write any new data. They will be required to hold on to the file id locks until the transaction commits. This is not a good fit for highly concurrent workloads, as lock contention may be prohibitively high. Optimistic locking works better for these scenarios."))),(0,n.kt)("p",null,"It is also worth noting that, if multiple writers originate from the same JVM client, a simple locking at the client level would serialize the writes and no external locking needs to be configured. "),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Apache Hudi platform uses optimistic locking and provides a pluggable LockProvider interface and multiple implementations are available out of the box (Apache Zookeeper, DynamoDB, Apache Hive and JVM Level in-process lock).  ")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Table service client and Table write client conflicts")),(0,n.kt)("p",null,"Concurrent updates to the same file group between the Table client and Table Service client can be managed with some additional complexity without the need for external locking. The table service client will be creating a new file slice within the file group and the table client will be creating a new log entry on the current file slice in the file group. Since Hudi maintains a strict ordering of operations in the timeline, When reading a file group, Hudi reader can reconcile all the changes to the previous file slice that are not part of the current file slice. "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Multiple Table service client conflicts")),(0,n.kt)("p",null,"Since Table service client commits are not opaque modifications to the table, concurrency control can be more efficient and intelligent. Concurrent updates to the same file group can be detected early and conflicting table service clients can be aborted.\nPlanning table service actions need to be serialized by short-lived locks."),(0,n.kt)("h4",{id:"optimistic-concurrency-efficiency"},"Optimistic concurrency efficiency"),(0,n.kt)("p",null,"The efficiency of Optimistic concurrency is inversely proportional to the possibility of a conflict, which in turn depends on the running time and the files overlapping between the concurrent writers. Apache Hudi storage format makes design choices that make it possible to configure the system to have a low possibility of conflict with regular workloads"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"All records with the same record key are present in a single file group. In other words, there is a 1-1 mapping between a record key and a file group id, at all times."),(0,n.kt)("li",{parentName:"ul"},"Unit of concurrency is a single file group and this file group size is configurable. If the table needs to be optimized for concurrent updates, the file group size can be smaller than default which could mean lower collision rates. "),(0,n.kt)("li",{parentName:"ul"},"Merge-on-read storage engine has the option to store the contents in record oriented file formats which reduces write latencies (often up to 10 times compared to columnar storage) which results in less collision with other concurrent writers"),(0,n.kt)("li",{parentName:"ul"},"Merge-on-read storage engine combined with scalable metadata table ensures that the system can handle frequent updates efficiently which means ingest jobs can be frequent and quick, reducing the chance of conflicts ")))}d.isMDXComponent=!0}}]);