"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[44939],{11470:(e,n,a)=>{a.d(n,{A:()=>k});var i=a(96540),t=a(34164),r=a(23104),s=a(56347),o=a(205),l=a(57485),d=a(31682),c=a(70679);function u(e){return i.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:a}=e;return(0,i.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:a,default:i}})=>({value:e,label:n,attributes:a,default:i}))}(a);return function(e){const n=(0,d.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,a])}function p({value:e,tabValues:n}){return n.some(n=>n.value===e)}function m({queryString:e=!1,groupId:n}){const a=(0,s.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(t),(0,i.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(a.location.search);n.set(t,e),a.replace({...a.location,search:n.toString()})},[t,a])]}function f(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,r=h(e),[s,l]=(0,i.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=n.find(e=>e.default)??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r})),[d,u]=m({queryString:a,groupId:t}),[f,x]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,t]=(0,c.Dv)(n);return[a,(0,i.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),g=(()=>{const e=d??f;return p({value:e,tabValues:r})?e:null})();(0,o.A)(()=>{g&&l(g)},[g]);return{selectedValue:s,selectValue:(0,i.useCallback)(e=>{if(!p({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),x(e)},[u,x,r]),tabValues:r}}var x=a(92303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=a(74848);function j({className:e,block:n,selectedValue:a,selectValue:i,tabValues:s}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),d=e=>{const n=e.currentTarget,t=o.indexOf(n),r=s[t].value;r!==a&&(l(n),i(r))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=o.indexOf(e.currentTarget)+1;n=o[a]??o[0];break}case"ArrowLeft":{const a=o.indexOf(e.currentTarget)-1;n=o[a]??o[o.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:i})=>(0,b.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{o.push(e)},onKeyDown:c,onClick:d,...i,className:(0,t.A)("tabs__item",g.tabItem,i?.className,{"tabs__item--active":a===e}),children:n??e},e))})}function v({lazy:e,children:n,selectedValue:a}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===a);return e?(0,i.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function y(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,t.A)("tabs-container",g.tabList),children:[(0,b.jsx)(j,{...n,...e}),(0,b.jsx)(v,{...n,...e})]})}function k(e){const n=(0,x.A)();return(0,b.jsx)(y,{...e,children:u(e.children)},String(n))}},14019:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"release-0.11.0","title":"Release 0.11.0","description":"Release 0.11.0 (docs)","source":"@site/releases/release-0.11.0.md","sourceDirName":".","slug":"/release-0.11.0","permalink":"/releases/release-0.11.0","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"title":"Release 0.11.0","sidebar_position":16,"layout":"releases","toc":true,"last_modified_at":"2022-01-27T14:07:00.000Z"},"sidebar":"releases","previous":{"title":"Release 0.11.1","permalink":"/releases/release-0.11.1"},"next":{"title":"Release 0.10.1","permalink":"/releases/release-0.10.1"}}');var t=a(74848),r=a(28453);a(11470),a(19365);const s={title:"Release 0.11.0",sidebar_position:16,layout:"releases",toc:!0,last_modified_at:new Date("2022-01-27T14:07:00.000Z")},o=void 0,l={},d=[{value:"Release 0.11.0 (docs)",id:"release-0110-docs",level:2},{value:"Migration Guide",id:"migration-guide",level:2},{value:"Bundle usage updates",id:"bundle-usage-updates",level:3},{value:"Configuration updates",id:"configuration-updates",level:3},{value:"Release Highlights",id:"release-highlights",level:2},{value:"Multi-Modal Index",id:"multi-modal-index",level:3},{value:"Data Skipping with Metadata Table",id:"data-skipping-with-metadata-table",level:3},{value:"Async Indexer",id:"async-indexer",level:3},{value:"Spark DataSource Improvements",id:"spark-datasource-improvements",level:3},{value:"Schema-on-read for Spark",id:"schema-on-read-for-spark",level:3},{value:"Spark SQL Improvements",id:"spark-sql-improvements",level:3},{value:"Spark Versions and Bundles",id:"spark-versions-and-bundles",level:3},{value:"Slim Utilities Bundle",id:"slim-utilities-bundle",level:3},{value:"Flink Integration Improvements",id:"flink-integration-improvements",level:3},{value:"Google BigQuery Integration",id:"google-bigquery-integration",level:3},{value:"AWS Glue Meta Sync",id:"aws-glue-meta-sync",level:3},{value:"DataHub Meta Sync",id:"datahub-meta-sync",level:3},{value:"Encryption",id:"encryption",level:3},{value:"Bucket Index",id:"bucket-index",level:3},{value:"Savepoint &amp; Restore",id:"savepoint--restore",level:3},{value:"Pulsar Write Commit Callback",id:"pulsar-write-commit-callback",level:3},{value:"HiveSchemaProvider",id:"hiveschemaprovider",level:3},{value:"Known Regression",id:"known-regression",level:2},{value:"Raw Release Notes",id:"raw-release-notes",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h2,{id:"release-0110-docs",children:[(0,t.jsx)(n.a,{href:"https://github.com/apache/hudi/releases/tag/release-0.11.0",children:"Release 0.11.0"})," (",(0,t.jsx)(n.a,{href:"/docs/quick-start-guide",children:"docs"}),")"]}),"\n",(0,t.jsx)(n.h2,{id:"migration-guide",children:"Migration Guide"}),"\n",(0,t.jsxs)(n.p,{children:["With 0.11.0, we have added a checksum mechanism for validating the ",(0,t.jsx)(n.code,{children:"hoodie.proerties"}),", which introduces a new table version, ",(0,t.jsx)(n.code,{children:"4"}),".\nWhenever a Hudi job is launched with this release on a table with older table version, an upgrade step is executed automatically to upgrade the table to table version ",(0,t.jsx)(n.code,{children:"4"}),".\nThis automatic upgrade step happens just once per Hudi table as the hoodie.table.version will be updated in property file after upgrade is completed.\nSimilarly, a command line tool for Downgrading (command - downgrade) is added if in case some users want to downgrade Hudi\nfrom table version ",(0,t.jsx)(n.code,{children:"4"})," to ",(0,t.jsx)(n.code,{children:"3"})," or move from Hudi 0.11.0 to pre 0.11.0. This needs to be executed from a 0.11.0 hudi-cli binary/script."]}),"\n",(0,t.jsx)(n.h3,{id:"bundle-usage-updates",children:"Bundle usage updates"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Spark bundle for 3.0.x is no longer officially supported. Users are encouraged to upgrade to Spark 3.2 or 3.1."}),"\n",(0,t.jsxs)(n.li,{children:["Users are encouraged to use bundles with specific Spark version in the name (",(0,t.jsx)(n.code,{children:"hudi-sparkX.Y-bundle"}),") and move away\nfrom the legacy bundles (",(0,t.jsx)(n.code,{children:"hudi-spark-bundle"})," and ",(0,t.jsx)(n.code,{children:"hudi-spark3-bundle"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Spark or Utilities bundle no longer requires additional ",(0,t.jsx)(n.code,{children:"spark-avro"})," package at runtime; the\noption ",(0,t.jsx)(n.code,{children:"--package org.apache.spark:spark-avro_2.1*:*"})," can be dropped."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration-updates",children:"Configuration updates"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For MOR tables, ",(0,t.jsx)(n.code,{children:"hoodie.datasource.write.precombine.field"})," is required for both write and read."]}),"\n",(0,t.jsxs)(n.li,{children:["Only set ",(0,t.jsx)(n.code,{children:"hoodie.datasource.write.drop.partition.columns=true"})," when work\nwith ",(0,t.jsx)(n.a,{href:"/docs/gcp_bigquery",children:"BigQuery integration"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For Spark readers that rely on extracting physical partition path,\nset ",(0,t.jsx)(n.code,{children:"hoodie.datasource.read.extract.partition.values.from.path=true"})," to stay compatible with existing behaviors."]}),"\n",(0,t.jsxs)(n.li,{children:["Default index type for Spark was changed from ",(0,t.jsx)(n.code,{children:"BLOOM"}),"\nto ",(0,t.jsx)(n.code,{children:"SIMPLE"})," (",(0,t.jsx)(n.a,{href:"https://issues.apache.org/jira/browse/HUDI-3091",children:"HUDI-3091"}),"). If you currently rely on the default ",(0,t.jsx)(n.code,{children:"BLOOM"}),"\nindex type, please update your configuration accordingly."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"release-highlights",children:"Release Highlights"}),"\n",(0,t.jsx)(n.h3,{id:"multi-modal-index",children:"Multi-Modal Index"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, we enable the ",(0,t.jsx)(n.a,{href:"/docs/metadata",children:"metadata table"})," with synchronous updates and metadata-table-based file listing\nby default for Spark writers, to improve the performance of partition and file listing on large Hudi tables. On the\nreader side, users need to set it to ",(0,t.jsx)(n.code,{children:"true"})," benefit from it. The metadata table and related file listing functionality\ncan still be turned off by setting ",(0,t.jsx)(n.code,{children:"hoodie.metadata.enable=false"}),". Due to this, users deploying Hudi with async table\nservices need to configure a locking service. If this feature is not relevant for you, you can set\n",(0,t.jsx)(n.code,{children:"hoodie.metadata.enable=false"})," additionally and use Hudi as before."]}),"\n",(0,t.jsx)(n.p,{children:"We introduce a multi-modal index in metadata table to drastically improve the lookup performance in file index and query\nlatency with data skipping. Two new indices are added to the metadata table"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"bloom filter index containing the file-level bloom filter to facilitate key lookup and file pruning as a part of\nbloom index during upserts by the writers"}),"\n",(0,t.jsx)(n.li,{children:"column stats index containing the statistics of all/interested columns to improve file pruning based on key and\ncolumn value range in both the writer and the reader, in query planning in Spark for example."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["They are disabled by default. You can enable them by setting ",(0,t.jsx)(n.code,{children:"hoodie.metadata.index.bloom.filter.enable"}),"\nand ",(0,t.jsx)(n.code,{children:"hoodie.metadata.index.column.stats.enable"})," to ",(0,t.jsx)(n.code,{children:"true"}),", respectively."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"/docs/metadata#deployment-considerations-for-metadata-table",children:"metadata table guide"})," for detailed instructions on upgrade and\ndeployment."]})}),"\n",(0,t.jsx)(n.h3,{id:"data-skipping-with-metadata-table",children:"Data Skipping with Metadata Table"}),"\n",(0,t.jsxs)(n.p,{children:["With the added support for Column Statistics in metadata table, Data Skipping is now relying on the metadata table's\nColumn Stats Index (CSI) instead of its own bespoke index implementation (comparing to Spatial Curves added in 0.10.0),\nallowing to leverage Data Skipping for all datasets regardless of whether they execute layout optimization procedures (\nlike clustering) or not. To benefit from Data Skipping, make sure to set ",(0,t.jsx)(n.code,{children:"hoodie.enable.data.skipping=true"})," on both\nwriter and reader, as well as enable metadata table and Column Stats Index in the metadata table."]}),"\n",(0,t.jsxs)(n.p,{children:['Data Skipping supports standard functions (as well as some common expressions) allowing you to apply common standard\ntransformations onto the raw data in your columns within your query\'s filters. For example, if you have column "ts" that\nstores timestamp as string, you can now query it using human-readable dates in your predicate like\nfollowing: ',(0,t.jsx)(n.code,{children:'date_format(ts, "MM/dd/yyyy" ) < "04/01/2022"'}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Note: Currently Data Skipping is only supported in COW tables and MOR tables in read-optimized mode. The work of full\nsupport for MOR tables is tracked in ",(0,t.jsx)(n.a,{href:"https://issues.apache.org/jira/browse/HUDI-3866",children:"HUDI-3866"})]})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Refer to the ",(0,t.jsx)(n.a,{href:"/docs/performance#read-path",children:"performance"})," guide for more info."]})}),"\n",(0,t.jsx)(n.h3,{id:"async-indexer",children:"Async Indexer"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, we added a new asynchronous service for indexing to our rich set of table services. It allows users to create\ndifferent kinds of indices (e.g., files, bloom filters, and column stats) in the metadata table without blocking\ningestion. The indexer adds a new action ",(0,t.jsx)(n.code,{children:"indexing"})," on the timeline. While the indexing process itself is asynchronous\nand non-blocking to writers, a lock provider needs to be configured to safely co-ordinate the process with the inflight\nwriters."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["See the ",(0,t.jsx)(n.a,{href:"/docs/metadata_indexing",children:"indexing guide"})," for more details."]})}),"\n",(0,t.jsx)(n.h3,{id:"spark-datasource-improvements",children:"Spark DataSource Improvements"}),"\n",(0,t.jsx)(n.p,{children:"Hudi's Spark low-level integration got considerable overhaul consolidating common flows to share the infrastructure and\nbring both compute and data throughput efficiencies when querying the data."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"MOR queries with no log files (except for incremental queries) tables are now leveraging Vectorized Parquet reader while reading\nthe data, meaning that Parquet reader is now able to leverage modern processors vectorized instructions to further\nspeed up decoding of the data. Enabled by default."}),"\n",(0,t.jsxs)(n.li,{children:["When standard Record Payload implementation is used (e.g., ",(0,t.jsx)(n.code,{children:"OverwriteWithLatestAvroPayload"}),"), MOR table will only\nfetch ",(0,t.jsx)(n.em,{children:"strictly necessary"}),' columns (primary key, pre-combine key) on top of those referenced by the query,\nsubstantially reducing wasted data throughput as well as compute spent on decompressing and decoding the data. This is\nsignificantly beneficial to "wide" MOR tables with 1000s of columns, for example.']}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["See the ",(0,t.jsx)(n.a,{href:"#migration-guide",children:"migration guide"})," for the relevant configuration updates."]})}),"\n",(0,t.jsx)(n.h3,{id:"schema-on-read-for-spark",children:"Schema-on-read for Spark"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, users can now easily change the current schema of a Hudi table to adapt to the evolving data schema over\ntime. Spark SQL DDL support (experimental) was added for Spark 3.1.x and Spark 3.2.1 via ",(0,t.jsx)(n.code,{children:"ALTER TABLE"})," syntax."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Please refer to the ",(0,t.jsx)(n.a,{href:"/docs/schema_evolution",children:"schema evolution guide"})," for more details."]})}),"\n",(0,t.jsx)(n.h3,{id:"spark-sql-improvements",children:"Spark SQL Improvements"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Users can update or delete records in Hudi tables using non-primary-key fields."}),"\n",(0,t.jsxs)(n.li,{children:["Time travel query is now supported via ",(0,t.jsx)(n.code,{children:"timestamp as of"})," syntax. (Spark 3.2+ only)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"CALL"})," command is added to support invoking more actions on Hudi tables."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["Please refer to the ",(0,t.jsx)(n.a,{href:"/docs/quick-start-guide",children:"Quick Start - Spark Guide"})," for more details and examples."]})}),"\n",(0,t.jsx)(n.h3,{id:"spark-versions-and-bundles",children:"Spark Versions and Bundles"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Spark 3.2 support is added; users who are on Spark 3.2 can use ",(0,t.jsx)(n.code,{children:"hudi-spark3.2-bundle"})," or ",(0,t.jsx)(n.code,{children:"hudi-spark3-bundle"})," (legacy bundle name)."]}),"\n",(0,t.jsxs)(n.li,{children:["Spark 3.1 will continue to be supported via ",(0,t.jsx)(n.code,{children:"hudi-spark3.1-bundle"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Spark 2.4 will continue to be supported via ",(0,t.jsx)(n.code,{children:"hudi-spark2.4-bundle"})," or ",(0,t.jsx)(n.code,{children:"hudi-spark-bundle"})," (legacy bundle name)."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["See the ",(0,t.jsx)(n.a,{href:"#migration-guide",children:"migration guide"})," for usage updates."]})}),"\n",(0,t.jsx)(n.h3,{id:"slim-utilities-bundle",children:"Slim Utilities Bundle"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, a new ",(0,t.jsx)(n.code,{children:"hudi-utilities-slim-bundle"})," is added to exclude dependencies that could cause conflicts and\ncompatibility issues with other frameworks such as Spark. ",(0,t.jsx)(n.code,{children:"hudi-utilities-slim-bundle"})," is to work with a chosen Spark\nbundle:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hudi-utilities-slim-bundle"})," works with Spark 3.1 and 2.4."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"hudi-utilities-bundle"})," continues to work with Spark 3.1 as it does in Hudi 0.10.x."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"flink-integration-improvements",children:"Flink Integration Improvements"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"In 0.11.0, both Flink 1.13.x and 1.14.x are supported."}),"\n",(0,t.jsxs)(n.li,{children:["Complex data types such as ",(0,t.jsx)(n.code,{children:"Map"})," and ",(0,t.jsx)(n.code,{children:"Array"})," are supported. Complex data types can be nested in another component data\ntype."]}),"\n",(0,t.jsxs)(n.li,{children:["A DFS-based Flink catalog is added with catalog identifier as ",(0,t.jsx)(n.code,{children:"hudi"}),". You can instantiate the catalog through API\ndirectly or use the ",(0,t.jsx)(n.code,{children:"CREATE CATALOG"})," syntax to create it."]}),"\n",(0,t.jsxs)(n.li,{children:["Flink supports ",(0,t.jsx)(n.a,{href:"#bucket-index",children:"Bucket Index"})," in normal ",(0,t.jsx)(n.code,{children:"UPSERT"})," and ",(0,t.jsx)(n.code,{children:"BULK_INSERT"})," operations. Different from the\ndefault Flink state-based index, bucket index is in constant number of buckets. Specify SQL option ",(0,t.jsx)(n.code,{children:"index.type"}),"\nas ",(0,t.jsx)(n.code,{children:"BUCKET"})," to enable it."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"google-bigquery-integration",children:"Google BigQuery Integration"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, Hudi tables can be queried from BigQuery as external tables. Users can\nset ",(0,t.jsx)(n.code,{children:"org.apache.hudi.gcp.bigquery.BigQuerySyncTool"})," as the sync tool implementation for ",(0,t.jsx)(n.code,{children:"HoodieDeltaStreamer"})," and make\nthe target Hudi table discoverable in BigQuery. Please refer to the ",(0,t.jsx)(n.a,{href:"/docs/gcp_bigquery",children:"BigQuery integration"})," guide\npage for more details."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Note: this is an experimental feature and only works with hive-style partitioned Copy-On-Write tables."})}),"\n",(0,t.jsx)(n.h3,{id:"aws-glue-meta-sync",children:"AWS Glue Meta Sync"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, Hudi tables can be sync'ed to AWS Glue Data Catalog via AWS SDK directly. Users can\nset ",(0,t.jsx)(n.code,{children:"org.apache.hudi.aws.sync.AwsGlueCatalogSyncTool"})," as the sync tool implementation for ",(0,t.jsx)(n.code,{children:"HoodieDeltaStreamer"})," and make\nthe target Hudi table discoverable in Glue catalog. Please refer\nto ",(0,t.jsx)(n.a,{href:"/docs/syncing_aws_glue_data_catalog",children:"Sync to AWS Glue Data Catalog"})," guide page for more details."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Note: this is an experimental feature."})}),"\n",(0,t.jsx)(n.h3,{id:"datahub-meta-sync",children:"DataHub Meta Sync"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, Hudi table's metadata (specifically, schema and last sync commit time) can be sync'ed\nto ",(0,t.jsx)(n.a,{href:"https://datahubproject.io/",children:"DataHub"}),". Users can set ",(0,t.jsx)(n.code,{children:"org.apache.hudi.sync.datahub.DataHubSyncTool"})," as the sync tool\nimplementation for ",(0,t.jsx)(n.code,{children:"HoodieDeltaStreamer"})," and sync the target table as a Dataset in DataHub. Please refer\nto ",(0,t.jsx)(n.a,{href:"/docs/syncing_datahub",children:"Sync to DataHub"})," guide page for more details."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Note: this is an experimental feature."})}),"\n",(0,t.jsx)(n.h3,{id:"encryption",children:"Encryption"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, Spark 3.2 support has been added and accompanying that, Parquet 1.12 has been included, which brings\nencryption feature to Hudi (Copy-on-Write tables). Please refer to ",(0,t.jsx)(n.a,{href:"/docs/encryption",children:"Encryption"})," guide page for more\ndetails."]}),"\n",(0,t.jsx)(n.h3,{id:"bucket-index",children:"Bucket Index"}),"\n",(0,t.jsxs)(n.p,{children:["Bucket index, an efficient and light-weight index type, is added in 0.11.0. It distributes records to buckets using a\nhash function based on the record keys, where each bucket corresponds to a single file group. To use this index, set the\nindex type to ",(0,t.jsx)(n.code,{children:"BUCKET"})," and set ",(0,t.jsx)(n.code,{children:"hoodie.storage.layout.partitioner.class"})," to ",(0,t.jsx)(n.code,{children:"org.apache.hudi.table.action.commit.SparkBucketIndexPartitioner"}),".\nFor Flink, set ",(0,t.jsx)(n.code,{children:"index.type=BUCKET"}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["For more details, please refer to hoodie.bucket.index.* in the ",(0,t.jsx)(n.a,{href:"/docs/configurations",children:"configurations page"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"savepoint--restore",children:"Savepoint & Restore"}),"\n",(0,t.jsx)(n.p,{children:"Disaster recovery is a mission critical feature in any production deployment. Especially when it comes to systems that\nstore data. Hudi had savepoint and restore functionality right from the beginning for COW tables. In 0.11.0, we have\nadded support for MOR tables."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["More info about this feature can be found in ",(0,t.jsx)(n.a,{href:"/docs/disaster_recovery",children:"Disaster Recovery"}),"."]})}),"\n",(0,t.jsx)(n.h3,{id:"pulsar-write-commit-callback",children:"Pulsar Write Commit Callback"}),"\n",(0,t.jsxs)(n.p,{children:["Hudi users can use ",(0,t.jsx)(n.code,{children:"org.apache.hudi.callback.HoodieWriteCommitCallback"})," to invoke callback function upon successful\ncommits. In 0.11.0, we add ",(0,t.jsx)(n.code,{children:"HoodieWriteCommitPulsarCallback"})," in addition to the existing HTTP callback and Kafka\ncallback. Please refer to the ",(0,t.jsx)(n.a,{href:"/docs/configurations#Write-commit-pulsar-callback-configs",children:"configurations page"})," for\ndetailed settings."]}),"\n",(0,t.jsx)(n.h3,{id:"hiveschemaprovider",children:"HiveSchemaProvider"}),"\n",(0,t.jsxs)(n.p,{children:["In 0.11.0, ",(0,t.jsx)(n.code,{children:"org.apache.hudi.utilities.schema.HiveSchemaProvider"})," is added for getting schema from user-defined hive\ntables. This is useful when tailing Hive tables in ",(0,t.jsx)(n.code,{children:"HoodieDeltaStreamer"})," instead of having to provide avro schema files."]}),"\n",(0,t.jsx)(n.h2,{id:"known-regression",children:"Known Regression"}),"\n",(0,t.jsx)(n.p,{children:"In 0.11.0 release, with the newly added support for Spark SQL features, the following performance regressions were\ninadvertently introduced:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Partition pruning for some of the COW tables is not applied properly"}),"\n",(0,t.jsx)(n.li,{children:"Spark SQL query caching (which caches parsed and resolved queries) was not working correctly resulting in additional"}),"\n",(0,t.jsx)(n.li,{children:"overhead to re-analyze the query every time when it's executed (listing the table contents, etc.)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"All of these issues have been addressed in 0.11.1 and are validated to be resolved by benchmarking the set of changes\non TPC-DS against 0.10.1."}),"\n",(0,t.jsx)(n.h2,{id:"raw-release-notes",children:"Raw Release Notes"}),"\n",(0,t.jsxs)(n.p,{children:["The raw release notes are available ",(0,t.jsx)(n.a,{href:"https://issues.apache.org/jira/secure/ReleaseNote.jspa?projectId=12322822&version=12350673",children:"here"})]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},19365:(e,n,a)=>{a.d(n,{A:()=>s});a(96540);var i=a(34164);const t={tabItem:"tabItem_Ymn6"};var r=a(74848);function s({children:e,hidden:n,className:a}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,i.A)(t.tabItem,a),hidden:n,children:e})}},28453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>o});var i=a(96540);const t={},r=i.createContext(t);function s(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);