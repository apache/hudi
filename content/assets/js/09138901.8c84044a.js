"use strict";(globalThis.webpackChunkhudi=globalThis.webpackChunkhudi||[]).push([[71858],{28453:(e,t,i)=>{i.d(t,{R:()=>r,x:()=>l});var s=i(96540);const a={},n=s.createContext(a);function r(e){const t=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(n.Provider,{value:t},e.children)}},28956:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"querying_data","title":"Querying Hudi Datasets","description":"Conceptually, Hudi stores data physically once on DFS, while providing 3 logical views on top, as explained before.","source":"@site/versioned_docs/version-0.5.0/querying_data.md","sourceDirName":".","slug":"/querying_data","permalink":"/docs/0.5.0/querying_data","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-0.5.0/querying_data.md","tags":[],"version":"0.5.0","frontMatter":{"version":"0.5.0","title":"Querying Hudi Datasets","keywords":["hudi","hive","spark","sql","presto"],"summary":"In this page, we go over how to enable SQL queries on Hudi built tables.","toc":true,"last_modified_at":"2019-12-30T19:59:57.000Z"},"sidebar":"docs","previous":{"title":"Writing Hudi Datasets","permalink":"/docs/0.5.0/writing_data"},"next":{"title":"Configurations","permalink":"/docs/0.5.0/configurations"}}');var a=i(74848),n=i(28453);const r={version:"0.5.0",title:"Querying Hudi Datasets",keywords:["hudi","hive","spark","sql","presto"],summary:"In this page, we go over how to enable SQL queries on Hudi built tables.",toc:!0,last_modified_at:new Date("2019-12-30T19:59:57.000Z")},l=void 0,d={},o=[{value:"Hive",id:"hive",level:2},{value:"Read Optimized table",id:"read-optimized-table",level:3},{value:"Real time table",id:"real-time-table",level:3},{value:"Incremental Pulling",id:"incremental-pulling",level:3},{value:"Spark",id:"spark",level:2},{value:"Read Optimized table",id:"read-optimized-table-1",level:3},{value:"Real time table",id:"spark-rt-view",level:3},{value:"Incremental Pulling",id:"spark-incr-pull",level:3},{value:"Presto",id:"presto",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Conceptually, Hudi stores data physically once on DFS, while providing 3 logical views on top, as explained ",(0,a.jsx)(t.a,{href:"/docs/concepts#views",children:"before"}),".\nOnce the dataset is synced to the Hive metastore, it provides external Hive tables backed by Hudi's custom inputformats. Once the proper hudi\nbundle has been provided, the dataset can be queried by popular query engines like Hive, Spark and Presto."]}),"\n",(0,a.jsxs)(t.p,{children:["Specifically, there are two Hive tables named off ",(0,a.jsx)(t.a,{href:"/docs/configurations#TABLE_NAME_OPT_KEY",children:"table name"})," passed during write.\nFor e.g, if ",(0,a.jsx)(t.code,{children:"table name = hudi_tbl"}),", then we get"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"hudi_tbl"})," realizes the read optimized view of the dataset backed by ",(0,a.jsx)(t.code,{children:"HoodieParquetInputFormat"}),", exposing purely columnar data."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"hudi_tbl_rt"})," realizes the real time view of the dataset  backed by ",(0,a.jsx)(t.code,{children:"HoodieParquetRealtimeInputFormat"}),", exposing merged view of base and log data."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["As discussed in the concepts section, the one key primitive needed for ",(0,a.jsx)(t.a,{href:"https://www.oreilly.com/ideas/ubers-case-for-incremental-processing-on-hadoop",children:"incrementally processing"}),",\nis ",(0,a.jsx)(t.code,{children:"incremental pulls"})," (to obtain a change stream/log from a dataset). Hudi datasets can be pulled incrementally, which means you can get ALL and ONLY the updated & new rows\nsince a specified instant time. This, together with upserts, are particularly useful for building data pipelines where 1 or more source Hudi tables are incrementally pulled (streams/facts),\njoined with other tables (datasets/dimensions), to ",(0,a.jsx)(t.a,{href:"/docs/writing_data",children:"write out deltas"})," to a target Hudi dataset. Incremental view is realized by querying one of the tables above,\nwith special configurations that indicates to query planning that only incremental data needs to be fetched out of the dataset."]}),"\n",(0,a.jsx)(t.p,{children:"In sections, below we will discuss in detail how to access all the 3 views on each query engine."}),"\n",(0,a.jsx)(t.h2,{id:"hive",children:"Hive"}),"\n",(0,a.jsxs)(t.p,{children:["In order for Hive to recognize Hudi datasets and query correctly, the HiveServer2 needs to be provided with the ",(0,a.jsx)(t.code,{children:"hudi-hadoop-mr-bundle-x.y.z-SNAPSHOT.jar"}),"\nin its ",(0,a.jsx)(t.a,{href:"https://www.cloudera.com/documentation/enterprise/5-6-x/topics/cm_mc_hive_udf#concept_nc3_mms_lr",children:"aux jars path"}),". This will ensure the input format\nclasses with its dependencies are available for query planning & execution."]}),"\n",(0,a.jsx)(t.h3,{id:"read-optimized-table",children:"Read Optimized table"}),"\n",(0,a.jsxs)(t.p,{children:["In addition to setup above, for beeline cli access, the ",(0,a.jsx)(t.code,{children:"hive.input.format"})," variable needs to be set to the  fully qualified path name of the\ninputformat ",(0,a.jsx)(t.code,{children:"org.apache.hudi.hadoop.HoodieParquetInputFormat"}),". For Tez, additionally the ",(0,a.jsx)(t.code,{children:"hive.tez.input.format"})," needs to be set\nto ",(0,a.jsx)(t.code,{children:"org.apache.hadoop.hive.ql.io.HiveInputFormat"})]}),"\n",(0,a.jsx)(t.h3,{id:"real-time-table",children:"Real time table"}),"\n",(0,a.jsx)(t.p,{children:"In addition to installing the hive bundle jar on the HiveServer2, it needs to be put on the hadoop/hive installation across the cluster, so that\nqueries can pick up the custom RecordReader as well."}),"\n",(0,a.jsx)(t.h3,{id:"incremental-pulling",children:"Incremental Pulling"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"HiveIncrementalPuller"})," allows incrementally extracting changes from large fact/dimension tables via HiveQL, combining the benefits of Hive (reliably process complex SQL queries) and\nincremental primitives (speed up query by pulling tables incrementally instead of scanning fully). The tool uses Hive JDBC to run the hive query and saves its results in a temp table.\nthat can later be upserted. Upsert utility (",(0,a.jsx)(t.code,{children:"HoodieDeltaStreamer"}),") has all the state it needs from the directory structure to know what should be the commit time on the target table.\ne.g: ",(0,a.jsx)(t.code,{children:"/app/incremental-hql/intermediate/{source_table_name}_temp/{last_commit_included}"}),".The Delta Hive table registered will be of the form ",(0,a.jsx)(t.code,{children:"{tmpdb}.{source_table}_{last_commit_included}"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The following are the configuration options for HiveIncrementalPuller"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:(0,a.jsx)(t.strong,{children:"Config"})}),(0,a.jsx)(t.th,{children:(0,a.jsx)(t.strong,{children:"Description"})}),(0,a.jsx)(t.th,{children:(0,a.jsx)(t.strong,{children:"Default"})})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hiveUrl"}),(0,a.jsx)(t.td,{children:"Hive Server 2 URL to connect to"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hiveUser"}),(0,a.jsx)(t.td,{children:"Hive Server 2 Username"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"hivePass"}),(0,a.jsx)(t.td,{children:"Hive Server 2 Password"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"queue"}),(0,a.jsx)(t.td,{children:"YARN Queue name"}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"tmp"}),(0,a.jsx)(t.td,{children:"Directory where the temporary delta data is stored in DFS. The directory structure will follow conventions. Please see the below section."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"extractSQLFile"}),(0,a.jsx)(t.td,{children:"The SQL to execute on the source table to extract the data. The data extracted will be all the rows that changed since a particular point in time."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"sourceTable"}),(0,a.jsx)(t.td,{children:"Source Table Name. Needed to set hive environment properties."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"targetTable"}),(0,a.jsx)(t.td,{children:"Target Table Name. Needed for the intermediate storage directory structure."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"sourceDataPath"}),(0,a.jsx)(t.td,{children:"Source DFS Base Path. This is where the Hudi metadata will be read."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"targetDataPath"}),(0,a.jsx)(t.td,{children:"Target DFS Base path. This is needed to compute the fromCommitTime. This is not needed if fromCommitTime is specified explicitly."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"tmpdb"}),(0,a.jsx)(t.td,{children:"The database to which the intermediate temp delta table will be created"}),(0,a.jsx)(t.td,{children:"hoodie_temp"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"fromCommitTime"}),(0,a.jsx)(t.td,{children:"This is the most important parameter. This is the point in time from which the changed records are pulled from."}),(0,a.jsx)(t.td,{})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"maxCommits"}),(0,a.jsx)(t.td,{children:"Number of commits to include in the pull. Setting this to -1 will include all the commits from fromCommitTime. Setting this to a value > 0, will include records that ONLY changed in the specified number of commits after fromCommitTime. This may be needed if you need to catch up say 2 commits at a time."}),(0,a.jsx)(t.td,{children:"3"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"help"}),(0,a.jsx)(t.td,{children:"Utility Help"}),(0,a.jsx)(t.td,{})]})]})]}),"\n",(0,a.jsx)(t.p,{children:"Setting fromCommitTime=0 and maxCommits=-1 will pull in the entire source dataset and can be used to initiate backfills. If the target dataset is a Hudi dataset,\nthen the utility can determine if the target dataset has no commits or is behind more than 24 hour (this is configurable),\nit will automatically use the backfill configuration, since applying the last 24 hours incrementally could take more time than doing a backfill. The current limitation of the tool\nis the lack of support for self-joining the same table in mixed mode (normal and incremental modes)."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"NOTE on Hive queries that are executed using Fetch task:"}),"\nSince Fetch tasks invoke InputFormat.listStatus() per partition, Hoodie metadata can be listed in\nevery such listStatus() call. In order to avoid this, it might be useful to disable fetch tasks\nusing the hive session property for incremental queries: ",(0,a.jsx)(t.code,{children:"set hive.fetch.task.conversion=none;"})," This\nwould ensure Map Reduce execution is chosen for a Hive query, which combines partitions (comma\nseparated) and calls InputFormat.listStatus() only once with all those partitions."]}),"\n",(0,a.jsx)(t.h2,{id:"spark",children:"Spark"}),"\n",(0,a.jsx)(t.p,{children:"Spark provides much easier deployment & management of Hudi jars and bundles into jobs/notebooks. At a high level, there are two ways to access Hudi datasets in Spark."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Hudi DataSource"})," : Supports Read Optimized, Incremental Pulls similar to how standard datasources (e.g: ",(0,a.jsx)(t.code,{children:"spark.read.parquet"}),") work."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Read as Hive tables"})," : Supports all three views, including the real time view, relying on the custom Hudi input formats again like Hive."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In general, your spark job needs a dependency to ",(0,a.jsx)(t.code,{children:"hudi-spark"})," or ",(0,a.jsx)(t.code,{children:"hudi-spark-bundle-x.y.z.jar"})," needs to be on the class path of driver & executors (hint: use ",(0,a.jsx)(t.code,{children:"--jars"})," argument)"]}),"\n",(0,a.jsx)(t.h3,{id:"read-optimized-table-1",children:"Read Optimized table"}),"\n",(0,a.jsx)(t.p,{children:"To read RO table as a Hive table using SparkSQL, simply push a path filter into sparkContext as follows.\nThis method retains Spark built-in optimizations for reading Parquet files like vectorized reading on Hudi tables."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-scala",children:'spark.sparkContext.hadoopConfiguration.setClass("mapreduce.input.pathFilter.class", classOf[org.apache.hudi.hadoop.HoodieROTablePathFilter], classOf[org.apache.hadoop.fs.PathFilter]);\n'})}),"\n",(0,a.jsx)(t.p,{children:"If you prefer to glob paths on DFS via the datasource, you can simply do something like below to get a Spark dataframe to work with."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:'Dataset<Row> hoodieROViewDF = spark.read().format("org.apache.hudi")\n// pass any path glob, can include hudi & non-hudi datasets\n.load("/glob/path/pattern");\n'})}),"\n",(0,a.jsx)(t.h3,{id:"spark-rt-view",children:"Real time table"}),"\n",(0,a.jsxs)(t.p,{children:["Currently, real time table can only be queried as a Hive table in Spark. In order to do this, set ",(0,a.jsx)(t.code,{children:"spark.sql.hive.convertMetastoreParquet=false"}),", forcing Spark to fallback\nto using the Hive Serde to read the data (planning/executions is still Spark)."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:"$ spark-shell --jars hudi-spark-bundle-x.y.z-SNAPSHOT.jar --driver-class-path /etc/hive/conf  --packages com.databricks:spark-avro_2.11:4.0.0 --conf spark.sql.hive.convertMetastoreParquet=false --num-executors 10 --driver-memory 7g --executor-memory 2g  --master yarn-client\n\nscala> sqlContext.sql(\"select count(*) from hudi_rt where datestr = '2016-10-02'\").show()\n"})}),"\n",(0,a.jsx)(t.h3,{id:"spark-incr-pull",children:"Incremental Pulling"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"hudi-spark"})," module offers the DataSource API, a more elegant way to pull data from Hudi dataset and process it via Spark.\nA sample incremental pull, that will obtain all records written since ",(0,a.jsx)(t.code,{children:"beginInstantTime"}),", looks like below."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-java",children:' Dataset<Row> hoodieIncViewDF = spark.read()\n     .format("org.apache.hudi")\n     .option(DataSourceReadOptions.VIEW_TYPE_OPT_KEY(),\n             DataSourceReadOptions.VIEW_TYPE_INCREMENTAL_OPT_VAL())\n     .option(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY(),\n            <beginInstantTime>)\n     .load(tablePath); // For incremental view, pass in the root/base path of dataset\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Please refer to ",(0,a.jsx)(t.a,{href:"/docs/configurations#spark-datasource-configs",children:"configurations"})," section, to view all datasource options."]}),"\n",(0,a.jsxs)(t.p,{children:["Additionally, ",(0,a.jsx)(t.code,{children:"HoodieReadClient"})," offers the following functionality using Hudi's implicit indexing."]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:(0,a.jsx)(t.strong,{children:"API"})}),(0,a.jsx)(t.th,{children:(0,a.jsx)(t.strong,{children:"Description"})})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"read(keys)"}),(0,a.jsx)(t.td,{children:"Read out the data corresponding to the keys as a DataFrame, using Hudi's own index for faster lookup"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"filterExists()"}),(0,a.jsx)(t.td,{children:"Filter out already existing records from the provided RDD[HoodieRecord]. Useful for de-duplication"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"checkExists(keys)"}),(0,a.jsx)(t.td,{children:"Check if the provided keys exist in a Hudi dataset"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"presto",children:"Presto"}),"\n",(0,a.jsxs)(t.p,{children:["Presto is a popular query engine, providing interactive query performance. Hudi RO tables can be queries seamlessly in Presto.\nThis requires the ",(0,a.jsx)(t.code,{children:"hudi-presto-bundle"})," jar to be placed into ",(0,a.jsx)(t.code,{children:"<presto_install>/plugin/hive-hadoop2/"}),", across the installation."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);