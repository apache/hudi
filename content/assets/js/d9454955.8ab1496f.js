"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[35379],{41562:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"flink-quick-start-guide","title":"Flink Guide","description":"This guide provides a document at Hudi\'s capabilities using Flink SQL. We can feel the unique charm of Flink stream computing engine on Hudi.","source":"@site/versioned_docs/version-0.9.0/flink-quick-start-guide.md","sourceDirName":".","slug":"/flink-quick-start-guide","permalink":"/docs/0.9.0/flink-quick-start-guide","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-0.9.0/flink-quick-start-guide.md","tags":[],"version":"0.9.0","frontMatter":{"title":"Flink Guide","toc":true,"last_modified_at":"2020-08-12T07:19:57.000Z"},"sidebar":"docs","previous":{"title":"Spark Guide","permalink":"/docs/0.9.0/quick-start-guide"},"next":{"title":"Use Cases","permalink":"/docs/0.9.0/use_cases"}}');var s=i(74848),r=i(28453);const d={title:"Flink Guide",toc:!0,last_modified_at:new Date("2020-08-12T07:19:57.000Z")},o=void 0,l={},c=[{value:"Quick Start",id:"quick-start",level:2},{value:"Setup",id:"setup",level:3},{value:"Step.1 download Flink jar",id:"step1-download-flink-jar",level:4},{value:"Step.2 start Flink cluster",id:"step2-start-flink-cluster",level:4},{value:"Step.3 start Flink SQL client",id:"step3-start-flink-sql-client",level:4},{value:"Insert Data",id:"insert-data",level:3},{value:"Query Data",id:"query-data",level:3},{value:"Update Data",id:"update-data",level:3},{value:"Streaming Query",id:"streaming-query",level:3},{value:"Delete Data",id:"deletes",level:3},{value:"Flink Configuration",id:"flink-configuration",level:2},{value:"Parallelism",id:"parallelism",level:3},{value:"Memory",id:"memory",level:3},{value:"Checkpoint",id:"checkpoint",level:3},{value:"Table Option",id:"table-option",level:2},{value:"Memory",id:"memory-1",level:3},{value:"Parallelism",id:"parallelism-1",level:3},{value:"Compaction",id:"compaction",level:3},{value:"Memory Optimization",id:"memory-optimization",level:2},{value:"MOR",id:"mor",level:3},{value:"COW",id:"cow",level:3},{value:"Bulk Insert",id:"bulk-insert",level:2},{value:"Options",id:"options",level:3},{value:"Index Bootstrap",id:"index-bootstrap",level:2},{value:"Options",id:"options-1",level:3},{value:"How To Use",id:"how-to-use",level:3},{value:"Changelog Mode",id:"changelog-mode",level:2},{value:"Options",id:"options-2",level:3},{value:"Insert Mode",id:"insert-mode",level:2},{value:"Options",id:"options-3",level:3},{value:"Hive Query",id:"hive-query",level:2},{value:"Install",id:"install",level:3},{value:"Hive Environment",id:"hive-environment",level:3},{value:"Sync Template",id:"sync-template",level:3},{value:"Query",id:"query",level:3},{value:"Conflict",id:"conflict",level:3},{value:"Presto Query",id:"presto-query",level:2},{value:"Hive Sync",id:"hive-sync",level:3},{value:"Presto Environment",id:"presto-environment",level:3},{value:"Query",id:"query-1",level:3},{value:"Offline Compaction",id:"offline-compaction",level:2},{value:"Options",id:"options-4",level:3},{value:"Write Rate Limit",id:"write-rate-limit",level:2},{value:"Options",id:"options-5",level:3},{value:"Where To Go From Here?",id:"where-to-go-from-here",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"This guide provides a document at Hudi's capabilities using Flink SQL. We can feel the unique charm of Flink stream computing engine on Hudi.\nReading this guide, you can quickly start using Flink to write to(read from) Hudi, have a deeper understanding of configuration and optimization:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Quick Start"})," : Read ",(0,s.jsx)(n.a,{href:"#quick-start",children:"Quick Start"})," to get started quickly Flink sql client to write to(read from) Hudi."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Configuration"})," : For ",(0,s.jsx)(n.a,{href:"#flink-configuration",children:"Flink Configuration"}),", sets up through ",(0,s.jsx)(n.code,{children:"$FLINK_HOME/conf/flink-conf.yaml"}),". For per job configuration, sets up through ",(0,s.jsx)(n.a,{href:"#table-option",children:"Table Option"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Writing Data"})," : Flink supports different writing data use cases, such as ",(0,s.jsx)(n.a,{href:"#bulk-insert",children:"Bulk Insert"}),", ",(0,s.jsx)(n.a,{href:"#index-bootstrap",children:"Index Bootstrap"}),", ",(0,s.jsx)(n.a,{href:"#changelog-mode",children:"Changelog Mode"}),", ",(0,s.jsx)(n.a,{href:"#insert-mode",children:"Insert Mode"}),"  and ",(0,s.jsx)(n.a,{href:"#offline-compaction",children:"Offline Compaction"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Querying Data"})," : Flink supports different querying data use cases, such as ",(0,s.jsx)(n.a,{href:"#hive-query",children:"Hive Query"}),", ",(0,s.jsx)(n.a,{href:"#presto-query",children:"Presto Query"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimization"})," : For write/read tasks, this guide gives some optimization suggestions, such as ",(0,s.jsx)(n.a,{href:"#memory-optimization",children:"Memory Optimization"})," and ",(0,s.jsx)(n.a,{href:"#write-rate-limit",children:"Write Rate Limit"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"quick-start",children:"Quick Start"}),"\n",(0,s.jsx)(n.h3,{id:"setup",children:"Setup"}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.a,{href:"https://ci.apache.org/projects/flink/flink-docs-release-1.13/docs/dev/table/sqlclient/",children:"Flink Sql Client"})," because it's a good\nquick start tool for SQL users."]}),"\n",(0,s.jsx)(n.h4,{id:"step1-download-flink-jar",children:"Step.1 download Flink jar"}),"\n",(0,s.jsxs)(n.p,{children:["Hudi works with Flink-1.11.2 version. You can follow instructions ",(0,s.jsx)(n.a,{href:"https://flink.apache.org/downloads",children:"here"})," for setting up Flink.\nThe hudi-flink-bundle jar is archived with scala 2.11, so it\u2019s recommended to use flink 1.12.2 bundled with scala 2.11."]}),"\n",(0,s.jsx)(n.h4,{id:"step2-start-flink-cluster",children:"Step.2 start Flink cluster"}),"\n",(0,s.jsx)(n.p,{children:"Start a standalone Flink cluster within hadoop environment.\nBefore you start up the cluster, we suggest to config the cluster as follows:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"$FLINK_HOME/conf/flink-conf.yaml"}),", add config option ",(0,s.jsx)(n.code,{children:"taskmanager.numberOfTaskSlots: 4"})]}),"\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"$FLINK_HOME/conf/flink-conf.yaml"}),", ",(0,s.jsx)(n.a,{href:"#flink-configuration",children:"add other global configurations according to the characteristics of your task"})]}),"\n",(0,s.jsxs)(n.li,{children:["in ",(0,s.jsx)(n.code,{children:"$FLINK_HOME/conf/workers"}),", add item ",(0,s.jsx)(n.code,{children:"localhost"})," as 4 lines so that there are 4 workers on the local cluster"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Now starts the cluster:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# HADOOP_HOME is your hadoop root directory after unpack the binary package.\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`\n\n# Start the Flink standalone cluster\n./bin/start-cluster.sh\n"})}),"\n",(0,s.jsx)(n.h4,{id:"step3-start-flink-sql-client",children:"Step.3 start Flink SQL client"}),"\n",(0,s.jsxs)(n.p,{children:["Hudi has a prepared bundle jar for Flink, which should be loaded in the Flink SQL Client when it starts up.\nYou can build the jar manually under path ",(0,s.jsx)(n.code,{children:"hudi-source-dir/packaging/hudi-flink-bundle"}),", or download it from the\n",(0,s.jsx)(n.a,{href:"https://repo.maven.apache.org/maven2/org/apache/hudi/hudi-flink-bundle_2.11/",children:"Apache Official Repository"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Now starts the SQL CLI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# HADOOP_HOME is your hadoop root directory after unpack the binary package.\nexport HADOOP_CLASSPATH=`$HADOOP_HOME/bin/hadoop classpath`\n\n./bin/sql-client.sh embedded -j .../hudi-flink-bundle_2.1?-*.*.*.jar shell\n"})}),"\n",(0,s.jsxs)("div",{className:"notice--info",children:[(0,s.jsx)("h4",{children:"Please note the following: "}),(0,s.jsxs)("ul",{children:[(0,s.jsx)("li",{children:"We suggest hadoop 2.9.x+ version because some of the object storage has filesystem implementation only after that"}),(0,s.jsx)("li",{children:"The flink-parquet and flink-avro formats are already packaged into the hudi-flink-bundle jar"})]})]}),"\n",(0,s.jsx)(n.p,{children:"Setup table name, base path and operate using SQL for this guide.\nThe SQL CLI only executes the SQL line by line."}),"\n",(0,s.jsx)(n.h3,{id:"insert-data",children:"Insert Data"}),"\n",(0,s.jsxs)(n.p,{children:["Creates a Flink Hudi table first and insert data into the Hudi table using SQL ",(0,s.jsx)(n.code,{children:"VALUES"})," as below."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- sets up the result mode to tableau to show the results directly in the CLI\nset execution.result-mode=tableau;\n\nCREATE TABLE t1(\n  uuid VARCHAR(20),\n  name VARCHAR(10),\n  age INT,\n  ts TIMESTAMP(3),\n  `partition` VARCHAR(20)\n)\nPARTITIONED BY (`partition`)\nWITH (\n  'connector' = 'hudi',\n  'path' = 'schema://base-path',\n  'table.type' = 'MERGE_ON_READ' -- this creates a MERGE_ON_READ table, by default is COPY_ON_WRITE\n);\n\n-- insert data using values\nINSERT INTO t1 VALUES\n  ('id1','Danny',23,TIMESTAMP '1970-01-01 00:00:01','par1'),\n  ('id2','Stephen',33,TIMESTAMP '1970-01-01 00:00:02','par1'),\n  ('id3','Julian',53,TIMESTAMP '1970-01-01 00:00:03','par2'),\n  ('id4','Fabian',31,TIMESTAMP '1970-01-01 00:00:04','par2'),\n  ('id5','Sophia',18,TIMESTAMP '1970-01-01 00:00:05','par3'),\n  ('id6','Emma',20,TIMESTAMP '1970-01-01 00:00:06','par3'),\n  ('id7','Bob',44,TIMESTAMP '1970-01-01 00:00:07','par4'),\n  ('id8','Han',56,TIMESTAMP '1970-01-01 00:00:08','par4');\n"})}),"\n",(0,s.jsx)(n.h3,{id:"query-data",children:"Query Data"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- query from the Hudi table\nselect * from t1;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This query provides snapshot querying of the ingested data.\nRefer to ",(0,s.jsx)(n.a,{href:"/docs/concepts#table-types--queries",children:"Table types and queries"})," for more info on all table types and query types supported.\n{: .notice--info}"]}),"\n",(0,s.jsx)(n.h3,{id:"update-data",children:"Update Data"}),"\n",(0,s.jsx)(n.p,{children:"This is similar to inserting new data."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- this would update the record with key 'id1'\ninsert into t1 values\n  ('id1','Danny',27,TIMESTAMP '1970-01-01 00:00:01','par1');\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that the save mode is now ",(0,s.jsx)(n.code,{children:"Append"}),". In general, always use append mode unless you are trying to create the table for the first time.\n",(0,s.jsx)(n.a,{href:"#query-data",children:"Querying"})," the data again will now show updated records. Each write operation generates a new ",(0,s.jsx)(n.a,{href:"/docs/concepts",children:"commit"}),"\ndenoted by the timestamp. Look for changes in ",(0,s.jsx)(n.code,{children:"_hoodie_commit_time"}),", ",(0,s.jsx)(n.code,{children:"age"})," fields for the same ",(0,s.jsx)(n.code,{children:"_hoodie_record_key"}),"s in previous commit.\n{: .notice--info}"]}),"\n",(0,s.jsx)(n.h3,{id:"streaming-query",children:"Streaming Query"}),"\n",(0,s.jsx)(n.p,{children:"Hudi Flink also provides capability to obtain a stream of records that changed since given commit timestamp.\nThis can be achieved using Hudi's streaming querying and providing a start time from which changes need to be streamed.\nWe do not need to specify endTime, if we want all changes after the given commit (as is the common case)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"CREATE TABLE t1(\n  uuid VARCHAR(20),\n  name VARCHAR(10),\n  age INT,\n  ts TIMESTAMP(3),\n  `partition` VARCHAR(20)\n)\nPARTITIONED BY (`partition`)\nWITH (\n  'connector' = 'hudi',\n  'path' = 'oss://vvr-daily/hudi/t1',\n  'table.type' = 'MERGE_ON_READ',\n  'read.streaming.enabled' = 'true',  -- this option enable the streaming read\n  'read.streaming.start-commit' = '20210316134557' -- specifies the start commit instant time\n  'read.streaming.check-interval' = '4' -- specifies the check interval for finding new source commits, default 60s.\n);\n\n-- Then query the table in stream mode\nselect * from t1;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This will give all changes that happened after the ",(0,s.jsx)(n.code,{children:"read.streaming.start-commit"})," commit. The unique thing about this\nfeature is that it now lets you author streaming pipelines on streaming or batch data source.\n{: .notice--info}"]}),"\n",(0,s.jsx)(n.h3,{id:"deletes",children:"Delete Data"}),"\n",(0,s.jsx)(n.p,{children:"When consuming data in streaming query, Hudi Flink source can also accepts the change logs from the underneath data source,\nit can then applies the UPDATE and DELETE by per-row level. You can then sync a NEAR-REAL-TIME snapshot on Hudi for all kinds\nof RDBMS."}),"\n",(0,s.jsx)(n.h2,{id:"flink-configuration",children:"Flink Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Before using Flink, you need to set some global configurations in ",(0,s.jsx)(n.code,{children:"$FLINK_HOME/conf/flink-conf.yaml"})]}),"\n",(0,s.jsx)(n.h3,{id:"parallelism",children:"Parallelism"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"taskmanager.numberOfTaskSlots"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Integer"})}),(0,s.jsx)(n.td,{children:"The number of parallel operator or user function instances that a single TaskManager can run. We recommend setting this value > 4, and the actual value needs to be set according to the amount of data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"parallelism.default"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"1"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Integer"})}),(0,s.jsxs)(n.td,{children:["The default parallelism used when no parallelism is specified anywhere (default: 1). For example, If the value of ",(0,s.jsx)(n.a,{href:"#parallelism-1",children:(0,s.jsx)(n.code,{children:"write.bucket_assign.tasks"})})," is not set, this value will be used"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"memory",children:"Memory"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"jobmanager.memory.process.size"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MemorySize"})}),(0,s.jsx)(n.td,{children:"Total Process Memory size for the JobManager. This includes all the memory that a JobManager JVM process consumes, consisting of Total Flink Memory, JVM Metaspace, and JVM Overhead"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"taskmanager.memory.task.heap.size"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MemorySize"})}),(0,s.jsx)(n.td,{children:"Task Heap Memory size for TaskExecutors. This is the size of JVM heap memory reserved for write cache"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"taskmanager.memory.managed.size"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"MemorySize"})}),(0,s.jsx)(n.td,{children:"Managed Memory size for TaskExecutors. This is the size of off-heap memory managed by the memory manager, reserved for sorting and RocksDB state backend. If you choose RocksDB as the state backend, you need to set this memory"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"checkpoint",children:"Checkpoint"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"execution.checkpointing.interval"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Duration"})}),(0,s.jsxs)(n.td,{children:["Setting this value as ",(0,s.jsx)(n.code,{children:"execution.checkpointing.interval = 150000ms"}),", 150000ms = 2.5min. Configuring this parameter is equivalent to enabling the checkpoint"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state.backend"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsxs)(n.td,{children:["The state backend to be used to store state. We recommend setting store state as ",(0,s.jsx)(n.code,{children:"rocksdb"})," : ",(0,s.jsx)(n.code,{children:"state.backend: rocksdb"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state.backend.rocksdb.localdir"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsx)(n.td,{children:"The local directory (on the TaskManager) where RocksDB puts its files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state.checkpoints.dir"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"(none)"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"String"})}),(0,s.jsx)(n.td,{children:"The default directory used for storing the data files and meta data of checkpoints in a Flink supported filesystem. The storage path must be accessible from all participating processes/nodes(i.e. all TaskManagers and JobManagers), like hdfs and oss path"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"state.backend.incremental"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"Boolean"})}),(0,s.jsxs)(n.td,{children:["Option whether the state backend should create incremental checkpoints, if possible. For an incremental checkpoint, only a diff from the previous checkpoint is stored, rather than the complete checkpoint state. If store state is setting as ",(0,s.jsx)(n.code,{children:"rocksdb"}),", recommending to turn on"]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"table-option",children:"Table Option"}),"\n",(0,s.jsxs)(n.p,{children:["Flink SQL job can be configured through the options in ",(0,s.jsx)(n.a,{href:"#table-option",children:(0,s.jsx)(n.code,{children:"WITH"})})," clause.\nThe actual datasource level configs are listed below."]}),"\n",(0,s.jsx)(n.h3,{id:"memory-1",children:"Memory"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["When optimizing memory, we need to pay attention to the ",(0,s.jsx)(n.a,{href:"#memory",children:"memory configuration"}),"\nand the number of taskManagers, parallelism of write tasks (write.tasks : 4) first. After confirm each write task to be\nallocated with enough memory, we can try to set these memory options."]})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.task.max.size"})}),(0,s.jsxs)(n.td,{children:["Maximum memory in MB for a write task, when the threshold hits, it flushes the max size data bucket to avoid OOM. Default ",(0,s.jsx)(n.code,{children:"1024MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"1024D"})}),(0,s.jsxs)(n.td,{children:["The memory reserved for write buffer is ",(0,s.jsx)(n.code,{children:"write.task.max.size"})," - ",(0,s.jsx)(n.code,{children:"compaction.max_memory"}),". When total buffer of write tasks reach the threshold, the largest buffer in the memory will be flushed"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.batch.size"})}),(0,s.jsxs)(n.td,{children:["In order to improve the efficiency of writing, Flink write task will cache data in buffer according to the write bucket until the memory reaches the threshold. When reached threshold, the data buffer would be flushed out. Default ",(0,s.jsx)(n.code,{children:"64MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"64D"})}),(0,s.jsx)(n.td,{children:"Recommend to use the default settings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.log_block.size"})}),(0,s.jsxs)(n.td,{children:["The log writer of Hudi will not flush the data immediately after receiving data. The writer flush data to the disk in the unit of ",(0,s.jsx)(n.code,{children:"LogBlock"}),". Before ",(0,s.jsx)(n.code,{children:"LogBlock"})," reached threshold, records will be buffered in the writer in form of serialized bytes. Default ",(0,s.jsx)(n.code,{children:"128MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"128"})}),(0,s.jsx)(n.td,{children:"Recommend to use the default settings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.merge.max_memory"})}),(0,s.jsxs)(n.td,{children:["If write type is ",(0,s.jsx)(n.code,{children:"COPY_ON_WRITE"}),", Hudi will merge the incremental data and base file data. The incremental data will be cached and spilled to disk. this threshold controls the max heap size that can be used. Default ",(0,s.jsx)(n.code,{children:"100MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"100"})}),(0,s.jsx)(n.td,{children:"Recommend to use the default settings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.max_memory"})}),(0,s.jsxs)(n.td,{children:["Same as ",(0,s.jsx)(n.code,{children:"write.merge.max_memory"}),", but occurs during compaction. Default ",(0,s.jsx)(n.code,{children:"100MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"100"})}),(0,s.jsxs)(n.td,{children:["If it is online compaction, it can be turned up when resources are sufficient, such as setting as ",(0,s.jsx)(n.code,{children:"1024MB"})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"parallelism-1",children:"Parallelism"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.tasks"})}),(0,s.jsxs)(n.td,{children:["The parallelism of writer tasks. Each write task writes 1 to ",(0,s.jsx)(n.code,{children:"N"})," buckets in sequence. Default ",(0,s.jsx)(n.code,{children:"4"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"4"})}),(0,s.jsx)(n.td,{children:"Increases the parallelism has no effect on the number of small files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.bucket_assign.tasks"})}),(0,s.jsxs)(n.td,{children:["The parallelism of bucket assigner operators. No default value, using Flink ",(0,s.jsx)(n.code,{children:"parallelism.default"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#parallelism",children:(0,s.jsx)(n.code,{children:"parallelism.default"})})}),(0,s.jsx)(n.td,{children:"Increases the parallelism also increases the number of buckets, thus the number of small files (small buckets)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.index_boostrap.tasks"})}),(0,s.jsxs)(n.td,{children:["The parallelism of index bootstrap. Increasing parallelism can speed up the efficiency of the bootstrap stage. The bootstrap stage will block checkpointing. Therefore, it is necessary to set more checkpoint failure tolerance times. Default using Flink ",(0,s.jsx)(n.code,{children:"parallelism.default"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.a,{href:"#parallelism",children:(0,s.jsx)(n.code,{children:"parallelism.default"})})}),(0,s.jsxs)(n.td,{children:["It only take effect when ",(0,s.jsx)(n.code,{children:"index.bootsrap.enabled"})," is ",(0,s.jsx)(n.code,{children:"true"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"read.tasks"})}),(0,s.jsxs)(n.td,{children:["The parallelism of read operators (batch and stream). Default ",(0,s.jsx)(n.code,{children:"4"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"4"})}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.tasks"})}),(0,s.jsxs)(n.td,{children:["The parallelism of online compaction. Default ",(0,s.jsx)(n.code,{children:"10"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"10"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Online compaction"})," will occupy the resources of the write task. It is recommended to use ",(0,s.jsx)(n.a,{href:"#offline-compaction",children:(0,s.jsx)(n.code,{children:"offline compaction"})})]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"compaction",children:"Compaction"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["These are options only for ",(0,s.jsx)(n.code,{children:"online compaction"}),"."]})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Turn off online compaction by setting ",(0,s.jsx)(n.code,{children:"compaction.async.enabled"})," = ",(0,s.jsx)(n.code,{children:"false"}),", but we still recommend turning on ",(0,s.jsx)(n.code,{children:"compaction.schedule.enable"})," for the writing job. You can then execute the compaction plan by ",(0,s.jsx)(n.a,{href:"#offline-compaction",children:(0,s.jsx)(n.code,{children:"offline compaction"})}),"."]})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.schedule.enabled"})}),(0,s.jsx)(n.td,{children:"Whether to generate compaction plan periodically"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsxs)(n.td,{children:["Recommend to turn it on, even if ",(0,s.jsx)(n.code,{children:"compaction.async.enabled"})," = ",(0,s.jsx)(n.code,{children:"false"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.async.enabled"})}),(0,s.jsx)(n.td,{children:"Async Compaction, enabled by default for MOR"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsxs)(n.td,{children:["Turn off ",(0,s.jsx)(n.code,{children:"online compaction"})," by turning off this option"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.trigger.strategy"})}),(0,s.jsx)(n.td,{children:"Strategy to trigger compaction"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"num_commits"})}),(0,s.jsxs)(n.td,{children:["Options are ",(0,s.jsx)(n.code,{children:"num_commits"}),": trigger compaction when reach N delta commits; ",(0,s.jsx)(n.code,{children:"time_elapsed"}),": trigger compaction when time elapsed > N seconds since last compaction; ",(0,s.jsx)(n.code,{children:"num_and_time"}),": trigger compaction when both ",(0,s.jsx)(n.code,{children:"NUM_COMMITS"})," and ",(0,s.jsx)(n.code,{children:"TIME_ELAPSED"})," are satisfied; ",(0,s.jsx)(n.code,{children:"num_or_time"}),": trigger compaction when ",(0,s.jsx)(n.code,{children:"NUM_COMMITS"})," or ",(0,s.jsx)(n.code,{children:"TIME_ELAPSED"})," is satisfied."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.delta_commits"})}),(0,s.jsxs)(n.td,{children:["Max delta commits needed to trigger compaction, default ",(0,s.jsx)(n.code,{children:"5"})," commits"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"5"})}),(0,s.jsx)(n.td,{children:"--"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.delta_seconds"})}),(0,s.jsxs)(n.td,{children:["Max delta seconds time needed to trigger compaction, default ",(0,s.jsx)(n.code,{children:"1"})," hour"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"3600"})}),(0,s.jsx)(n.td,{children:"--"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.max_memory"})}),(0,s.jsxs)(n.td,{children:["Max memory in MB for compaction spillable map, default ",(0,s.jsx)(n.code,{children:"100MB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"100"})}),(0,s.jsxs)(n.td,{children:["If your have sufficient resources, recommend to adjust to ",(0,s.jsx)(n.code,{children:"1024MB"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"compaction.target_io"})}),(0,s.jsxs)(n.td,{children:["Target IO per compaction (both read and write), default ",(0,s.jsx)(n.code,{children:"5GB"})]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"5120"})}),(0,s.jsxs)(n.td,{children:["The default value for ",(0,s.jsx)(n.code,{children:"offline compaction"})," is ",(0,s.jsx)(n.code,{children:"500GB"})]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"memory-optimization",children:"Memory Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"mor",children:"MOR"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.a,{href:"#checkpoint",children:["Setting Flink state backend to ",(0,s.jsx)(n.code,{children:"rocksdb"})]})," (the default ",(0,s.jsx)(n.code,{children:"in memory"})," state backend is very memory intensive)."]}),"\n",(0,s.jsxs)(n.li,{children:["If there is enough memory, ",(0,s.jsx)(n.code,{children:"compaction.max_memory"})," can be set larger (",(0,s.jsx)(n.code,{children:"100MB"})," by default, and can be adjust to ",(0,s.jsx)(n.code,{children:"1024MB"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Pay attention to the memory allocated to each write task by taskManager to ensure that each write task can be allocated to the\ndesired memory size ",(0,s.jsx)(n.code,{children:"write.task.max.size"}),". For example, taskManager has ",(0,s.jsx)(n.code,{children:"4GB"})," of memory running two streamWriteFunction, so each write task\ncan be allocated with ",(0,s.jsx)(n.code,{children:"2GB"})," memory. Please reserve some buffers because the network buffer and other types of tasks on taskManager (such as bucketAssignFunction) will also consume memory."]}),"\n",(0,s.jsxs)(n.li,{children:["Pay attention to the memory changes of compaction. ",(0,s.jsx)(n.code,{children:"compaction.max_memory"})," controls the maximum memory that each task can be used when compaction tasks read\nlogs. ",(0,s.jsx)(n.code,{children:"compaction.tasks"})," controls the parallelism of compaction tasks."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"cow",children:"COW"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.a,{href:"#checkpoint",children:["Setting Flink state backend to ",(0,s.jsx)(n.code,{children:"rocksdb"})]})," (the default ",(0,s.jsx)(n.code,{children:"in memory"})," state backend is very memory intensive)."]}),"\n",(0,s.jsxs)(n.li,{children:["Increase both ",(0,s.jsx)(n.code,{children:"write.task.max.size"})," and ",(0,s.jsx)(n.code,{children:"write.merge.max_memory"})," (",(0,s.jsx)(n.code,{children:"1024MB"})," and ",(0,s.jsx)(n.code,{children:"100MB"})," by default, adjust to ",(0,s.jsx)(n.code,{children:"2014MB"})," and ",(0,s.jsx)(n.code,{children:"1024MB"}),")."]}),"\n",(0,s.jsxs)(n.li,{children:["Pay attention to the memory allocated to each write task by taskManager to ensure that each write task can be allocated to the\ndesired memory size ",(0,s.jsx)(n.code,{children:"write.task.max.size"}),". For example, taskManager has ",(0,s.jsx)(n.code,{children:"4GB"})," of memory running two write tasks, so each write task\ncan be allocated with ",(0,s.jsx)(n.code,{children:"2GB"})," memory. Please reserve some buffers because the network buffer and other types of tasks on taskManager (such as ",(0,s.jsx)(n.code,{children:"BucketAssignFunction"}),") will also consume memory."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"bulk-insert",children:"Bulk Insert"}),"\n",(0,s.jsxs)(n.p,{children:["For the demand of snapshot data import. If the snapshot data comes from other data sources, use the ",(0,s.jsx)(n.code,{children:"bulk_insert"})," mode to quickly\nimport the snapshot data into Hudi."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bulk_insert"})," eliminates the serialization and data merging. The data deduplication is skipped, so the user need to guarantee the uniqueness of the data."]})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"bulk_insert"})," is more efficient in the ",(0,s.jsx)(n.code,{children:"batch execution mode"}),". By default, the ",(0,s.jsx)(n.code,{children:"batch execution mode"})," sorts the input records\nby the partition path and writes these records to Hudi, which can avoid write performance degradation caused by\nfrequent ",(0,s.jsx)(n.code,{children:"file handle"})," switching."]})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsxs)(n.p,{children:["The parallelism of ",(0,s.jsx)(n.code,{children:"bulk_insert"})," is specified by ",(0,s.jsx)(n.code,{children:"write.tasks"}),". The parallelism will affect the number of small files.\nIn theory, the parallelism of ",(0,s.jsx)(n.code,{children:"bulk_insert"})," is the number of ",(0,s.jsx)(n.code,{children:"bucket"}),"s (In particular, when each bucket writes to maximum file size, it\nwill rollover to the new file handle. Finally, ",(0,s.jsx)(n.code,{children:"the number of files"})," >= ",(0,s.jsx)(n.a,{href:"#parallelism",children:(0,s.jsx)(n.code,{children:"write.bucket_assign.tasks"})}),")."]})]}),"\n",(0,s.jsx)(n.h3,{id:"options",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.operation"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"upsert"})}),(0,s.jsxs)(n.td,{children:["Setting as ",(0,s.jsx)(n.code,{children:"bulk_insert"})," to open this function"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.tasks"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"4"})}),(0,s.jsxs)(n.td,{children:["The parallelism of ",(0,s.jsx)(n.code,{children:"bulk_insert"}),", ",(0,s.jsx)(n.code,{children:"the number of files"})," >= ",(0,s.jsx)(n.a,{href:"#parallelism",children:(0,s.jsx)(n.code,{children:"write.bucket_assign.tasks"})})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.bulk_insert.shuffle_by_partition"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Whether to shuffle data according to the partition field before writing. Enabling this option will reduce the number of small files, but there may be a risk of data skew"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.bulk_insert.sort_by_partition"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Whether to sort data according to the partition field before writing. Enabling this option will reduce the number of small files when a write task writes multiple partitions"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.sort.memory"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"128"})}),(0,s.jsxs)(n.td,{children:["Available managed memory of sort operator. default  ",(0,s.jsx)(n.code,{children:"128"})," MB"]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"index-bootstrap",children:"Index Bootstrap"}),"\n",(0,s.jsxs)(n.p,{children:["For the demand of ",(0,s.jsx)(n.code,{children:"snapshot data"})," + ",(0,s.jsx)(n.code,{children:"incremental data"})," import. If the ",(0,s.jsx)(n.code,{children:"snapshot data"})," already insert into Hudi by  ",(0,s.jsx)(n.a,{href:"#bulk-insert",children:"bulk insert"}),".\nUser can insert ",(0,s.jsx)(n.code,{children:"incremental data"})," in real time and ensure the data is not repeated by using the index bootstrap function."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you think this process is very time-consuming, you can add resources to write in streaming mode while writing ",(0,s.jsx)(n.code,{children:"snapshot data"}),",\nand then reduce the resources to write ",(0,s.jsx)(n.code,{children:"incremental data"})," (or open the rate limit function)."]})}),"\n",(0,s.jsx)(n.h3,{id:"options-1",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"index.bootstrap.enabled"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"When index bootstrap is enabled, the remain records in Hudi table will be loaded into the Flink state at one time"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"index.partition.regex"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"*"})}),(0,s.jsx)(n.td,{children:"Optimize option. Setting regular expressions to filter partitions. By default, all partitions are loaded into flink state"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"how-to-use",children:"How To Use"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"CREATE TABLE"})," creates a statement corresponding to the Hudi table. Note that the ",(0,s.jsx)(n.code,{children:"table.type"})," must be correct."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting ",(0,s.jsx)(n.code,{children:"index.bootstrap.enabled"})," = ",(0,s.jsx)(n.code,{children:"true"})," to enable the index bootstrap function."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting Flink checkpoint failure tolerance in ",(0,s.jsx)(n.code,{children:"flink-conf.yaml"})," : ",(0,s.jsx)(n.code,{children:"execution.checkpointing.tolerable-failed-checkpoints = n"})," (depending on Flink checkpoint scheduling times)."]}),"\n",(0,s.jsx)(n.li,{children:"Waiting until the first checkpoint succeeds, indicating that the index bootstrap completed."}),"\n",(0,s.jsx)(n.li,{children:"After the index bootstrap completed, user can exit and save the savepoint (or directly use the externalized checkpoint)."}),"\n",(0,s.jsxs)(n.li,{children:["Restart the job, setting ",(0,s.jsx)(n.code,{children:"index.bootstrap.enable"})," as ",(0,s.jsx)(n.code,{children:"false"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Index bootstrap is blocking, so checkpoint cannot be completed during index bootstrap."}),"\n",(0,s.jsx)(n.li,{children:"Index bootstrap triggers by the input data. User need to ensure that there is at least one record in each partition."}),"\n",(0,s.jsxs)(n.li,{children:["Index bootstrap executes concurrently. User can search in log by ",(0,s.jsx)(n.code,{children:"finish loading the index under partition"})," and ",(0,s.jsx)(n.code,{children:"Load record form file"})," to observe the progress of index bootstrap."]}),"\n",(0,s.jsx)(n.li,{children:"The first successful checkpoint indicates that the index bootstrap completed. There is no need to load the index again when recovering from the checkpoint."}),"\n"]})}),"\n",(0,s.jsx)(n.h2,{id:"changelog-mode",children:"Changelog Mode"}),"\n",(0,s.jsx)(n.p,{children:"Hudi can keep all the intermediate changes (I / -U / U / D) of messages, then consumes through stateful computing of flink to have a near-real-time\ndata warehouse ETL pipeline (Incremental computing). Hudi MOR table stores messages in the forms of rows, which supports the retention of all change logs (Integration at the format level).\nAll changelog records can be consumed with Flink streaming reader."}),"\n",(0,s.jsx)(n.h3,{id:"options-2",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"changelog.enabled"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsxs)(n.td,{children:["It is turned off by default, to have the ",(0,s.jsx)(n.code,{children:"upsert"})," semantics, only the merged messages are ensured to be kept, intermediate changes may be merged. Setting to true to support consumption of all changes"]})]})})]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Batch (Snapshot) read still merge all the intermediate changes, regardless of whether the format has stored the intermediate changelog messages."})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["After setting ",(0,s.jsx)(n.code,{children:"changelog.enable"})," as ",(0,s.jsx)(n.code,{children:"true"}),", the retention of changelog records are only best effort: the asynchronous compaction task will merge the changelog records into one record, so if the\nstream source does not consume timely, only the merged record for each key can be read after compaction. The solution is to reserve some buffer time for the reader by adjusting the compaction strategy, such as\nthe compaction options: ",(0,s.jsx)(n.a,{href:"#compaction",children:(0,s.jsx)(n.code,{children:"compaction.delta_commits"})})," and ",(0,s.jsx)(n.a,{href:"#compaction",children:(0,s.jsx)(n.code,{children:"compaction.delta_seconds"})}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"insert-mode",children:"Insert Mode"}),"\n",(0,s.jsx)(n.p,{children:"Hudi apply the small file strategy for the insert mode by default: MOR appends delta records to log files, COW merges the base parquet files (the incremental data set will be deduplicated).\nThis strategy lead to performance degradation."}),"\n",(0,s.jsxs)(n.p,{children:["If you want to forbid the behavior of file merge, sets ",(0,s.jsx)(n.code,{children:"write.insert.deduplicate"})," as ",(0,s.jsx)(n.code,{children:"false"}),",the deduplication is skipped.\nEach flush behavior directly writes a now parquet file (MOR table also directly write parquet file)."]}),"\n",(0,s.jsx)(n.h3,{id:"options-3",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.insert.deduplicate"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"true"})}),(0,s.jsx)(n.td,{children:"Insert mode enable deduplication by default. After this option is turned off, each flush behavior directly writes a now parquet file"})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"hive-query",children:"Hive Query"}),"\n",(0,s.jsx)(n.h3,{id:"install",children:"Install"}),"\n",(0,s.jsxs)(n.p,{children:["Now you can git clone Hudi master branch to test Flink hive sync. The first step is to install Hudi to get ",(0,s.jsx)(n.code,{children:"hudi-flink-bundle_2.11-0.x.jar"}),".\n",(0,s.jsx)(n.code,{children:"hudi-flink-bundle"})," module pom.xml sets the scope related to hive as ",(0,s.jsx)(n.code,{children:"provided"})," by default. If you want to use hive sync, you need to use the\nprofile ",(0,s.jsx)(n.code,{children:"flink-bundle-shade-hive"})," during packaging. Executing command below to install:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Maven install command\nmvn install -DskipTests -Drat.skip=true -Pflink-bundle-shade-hive2\n\n# For hive1, you need to use profile -Pflink-bundle-shade-hive1\n# For hive3, you need to use profile -Pflink-bundle-shade-hive3 \n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsx)(n.p,{children:"Hive1.x can only synchronize metadata to hive, but cannot use hive query now. If you need to query, you can use spark to query hive table."})]}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsxs)(n.p,{children:["If using hive profile, you need to modify the hive version in the profile to your hive cluster version (Only need to modify the hive version in this profile).\nThe location of this ",(0,s.jsx)(n.code,{children:"pom.xml"})," is ",(0,s.jsx)(n.code,{children:"packaging/hudi-flink-bundle/pom.xml"}),", and the corresponding profile is at the bottom of this file."]})]}),"\n",(0,s.jsx)(n.h3,{id:"hive-environment",children:"Hive Environment"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Import ",(0,s.jsx)(n.code,{children:"hudi-hadoop-mr-bundle"})," into hive. Creating ",(0,s.jsx)(n.code,{children:"auxlib/"})," folder under the root directory of hive, and moving ",(0,s.jsx)(n.code,{children:"hudi-hadoop-mr-bundle-0.x.x-SNAPSHOT.jar"})," into ",(0,s.jsx)(n.code,{children:"auxlib"}),".\n",(0,s.jsx)(n.code,{children:"hudi-hadoop-mr-bundle-0.x.x-SNAPSHOT.jar"})," is at ",(0,s.jsx)(n.code,{children:"packaging/hudi-hadoop-mr-bundle/target"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["When Flink sql client connects hive metastore remotely, ",(0,s.jsx)(n.code,{children:"hive metastore"})," and ",(0,s.jsx)(n.code,{children:"hiveserver2"})," services need to be enabled, and the port number need to\nbe set correctly. Command to turn on the services:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Enable hive metastore and hiveserver2\nnohup ./bin/hive --service metastore &\nnohup ./bin/hive --service hiveserver2 &\n\n# While modifying the jar package under auxlib, you need to restart the service.\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sync-template",children:"Sync Template"}),"\n",(0,s.jsxs)(n.p,{children:["Flink hive sync now supports two hive sync mode, ",(0,s.jsx)(n.code,{children:"hms"})," and ",(0,s.jsx)(n.code,{children:"jdbc"}),". ",(0,s.jsx)(n.code,{children:"hms"})," mode only needs to configure metastore uris. For\nthe ",(0,s.jsx)(n.code,{children:"jdbc"})," mode, the JDBC attributes and metastore uris both need to be configured. The options template is as below:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"-- hms mode template\nCREATE TABLE t1(\n  uuid VARCHAR(20),\n  name VARCHAR(10),\n  age INT,\n  ts TIMESTAMP(3),\n  `partition` VARCHAR(20)\n)\nPARTITIONED BY (`partition`)\nWITH (\n  'connector' = 'hudi',\n  'path' = 'oss://vvr-daily/hudi/t1',\n  'table.type' = 'COPY_ON_WRITE',  --If MERGE_ON_READ, hive query will not have output until the parquet file is generated\n  'hive_sync.enable' = 'true',     -- Required. To enable hive synchronization\n  'hive_sync.mode' = 'hms'         -- Required. Setting hive sync mode to hms, default jdbc\n  'hive_sync.metastore.uris' = 'thrift://ip:9083' -- Required. The port need set on hive-site.xml\n);\n\n\n-- jdbc mode template\nCREATE TABLE t1(\n  uuid VARCHAR(20),\n  name VARCHAR(10),\n  age INT,\n  ts TIMESTAMP(3),\n  `partition` VARCHAR(20)\n)\nPARTITIONED BY (`partition`)\nWITH (\n  'connector' = 'hudi',\n  'path' = 'oss://vvr-daily/hudi/t1',\n  'table.type' = 'COPY_ON_WRITE',  --If MERGE_ON_READ, hive query will not have output until the parquet file is generated\n  'hive_sync.enable' = 'true',     -- Required. To enable hive synchronization\n  'hive_sync.mode' = 'hms'         -- Required. Setting hive sync mode to hms, default jdbc\n  'hive_sync.metastore.uris' = 'thrift://ip:9083'  -- Required. The port need set on hive-site.xml\n  'hive_sync.jdbc_url'='jdbc:hive2://ip:10000',    -- required, hiveServer port\n  'hive_sync.table'='t1',                          -- required, hive table name\n  'hive_sync.db'='testDB',                         -- required, hive database name\n  'hive_sync.username'='root',                     -- required, HMS username\n  'hive_sync.password'='your password'             -- required, HMS password\n);\n"})}),"\n",(0,s.jsx)(n.h3,{id:"query",children:"Query"}),"\n",(0,s.jsx)(n.p,{children:"While using hive beeline query, you need to enter settings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"set hive.input.format = org.apache.hudi.hadoop.hive.HoodieCombineHiveInputFormat;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"conflict",children:"Conflict"}),"\n",(0,s.jsxs)(n.p,{children:["When there is a ",(0,s.jsx)(n.code,{children:"flink-sql-connector-hive-xxx.jar"})," under Flink lib/, there will be a jar conflicts between ",(0,s.jsx)(n.code,{children:"flink-sql-connector-hive-xxx.jar"}),"\nand ",(0,s.jsx)(n.code,{children:"hudi-flink-bundle_2.11.xxx.jar"}),". The solution is to use another profile ",(0,s.jsx)(n.code,{children:"include-flink-sql-connector-hive"})," when install and delete\nthe ",(0,s.jsx)(n.code,{children:"flink-sql-connector-hive-xxx.jar"})," under Flink lib/. install command :"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Maven install command\nmvn install -DskipTests -Drat.skip=true -Pflink-bundle-shade-hive2 -Pinclude-flink-sql-connector-hive\n"})}),"\n",(0,s.jsx)(n.h2,{id:"presto-query",children:"Presto Query"}),"\n",(0,s.jsx)(n.h3,{id:"hive-sync",children:"Hive Sync"}),"\n",(0,s.jsxs)(n.p,{children:["First, you need to sync Hudi table metadata to hive according to the above steps of ",(0,s.jsx)(n.a,{href:"#hive-query",children:"Hive Query"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"presto-environment",children:"Presto Environment"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Configure Presto according to the ",(0,s.jsx)(n.a,{href:"https://prestodb.io/docs/current/installation/deployment.html",children:"Presto configuration document"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Configure hive catalog in ",(0,s.jsx)(n.code,{children:" /presto-server-0.2xxx/etc/catalog/hive.properties"})," as follows:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-properties",children:"connector.name=hive-hadoop2\nhive.metastore.uri=thrift://xxx.xxx.xxx.xxx:9083\nhive.config.resources=.../hadoop-2.x/etc/hadoop/core-site.xml,.../hadoop-2.x/etc/hadoop/hdfs-site.xml\n"})}),"\n",(0,s.jsx)(n.h3,{id:"query-1",children:"Query"}),"\n",(0,s.jsx)(n.p,{children:"Beginning query by connecting hive metastore with presto client. The presto client connection command is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# The presto client connection command\n./presto --server xxx.xxx.xxx.xxx:9999 --catalog hive --schema default\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Presto-server-0.2445 is a lower version. When querying the ",(0,s.jsx)(n.code,{children:"rt table"})," of MERGE_ON_WRITE, there will be a package conflict, this bug is in fix."]}),"\n",(0,s.jsxs)(n.li,{children:["When Presto-server-xxx version < 0.233, the ",(0,s.jsx)(n.code,{children:"hudi-presto-bundle.jar"})," needs to manually import into ",(0,s.jsx)(n.code,{children:"{presto_install_dir}/plugin/hive-hadoop2/"}),"."]}),"\n"]})}),"\n",(0,s.jsx)(n.h2,{id:"offline-compaction",children:"Offline Compaction"}),"\n",(0,s.jsx)(n.p,{children:"The compaction of the MERGE_ON_READ table is enabled by default. The trigger strategy is to perform compaction after completing\nfive commits. Because compaction consumes a lot of memory and is placed in the same pipeline with the write operation, it's easy to\ninterfere with the write operation when there is a large amount of data (> 100000 per second). As this time, it is more stable to execute\nthe compaction task by using offline compaction."}),"\n",(0,s.jsxs)(n.admonition,{type:"note",children:[(0,s.jsx)(n.mdxAdmonitionTitle,{}),(0,s.jsxs)(n.p,{children:["The execution of a compaction task includes two parts: schedule compaction plan and execute compaction plan. It's recommended that\nthe process of schedule compaction plan be triggered periodically by the write task, and the write parameter ",(0,s.jsx)(n.code,{children:"compaction.schedule.enable"}),"\nis enabled by default."]})]}),"\n",(0,s.jsxs)(n.p,{children:["Offline compaction needs to submit the Flink task on the command line. The program entry is as follows: ",(0,s.jsx)(n.code,{children:"hudi-flink-bundle_2.11-0.9.0-SNAPSHOT.jar"})," :\n",(0,s.jsx)(n.code,{children:"org.apache.hudi.sink.compact.HoodieFlinkCompactor"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# Command line\n./bin/flink run -c org.apache.hudi.sink.compact.HoodieFlinkCompactor lib/hudi-flink-bundle_2.11-0.9.0.jar --path hdfs://xxx:9000/table\n"})}),"\n",(0,s.jsx)(n.h3,{id:"options-4",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"--path"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"frue"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"--"})}),(0,s.jsx)(n.td,{children:"The path where the target table is stored on Hudi"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"--compaction-max-memory"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"100"})}),(0,s.jsx)(n.td,{children:"The index map size of log data during compaction, 100 MB by default. If you have enough memory, you can turn up this parameter"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"--schedule"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:"whether to execute the operation of scheduling compaction plan. When the write process is still writing\uff0c turning on this parameter have a risk of losing data. Therefore, it must be ensured that there are no write tasks currently writing data to this table when this parameter is turned on"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"--seq"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"LIFO"})}),(0,s.jsxs)(n.td,{children:["The order in which compaction tasks are executed. Executing from the latest compaction plan by default. ",(0,s.jsx)(n.code,{children:"LIFO"}),": executing from the latest plan. ",(0,s.jsx)(n.code,{children:"FIFO"}),": executing from the oldest plan."]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"write-rate-limit",children:"Write Rate Limit"}),"\n",(0,s.jsxs)(n.p,{children:["In the existing data synchronization, ",(0,s.jsx)(n.code,{children:"snapshot data"})," and ",(0,s.jsx)(n.code,{children:"incremental data"})," are send to kafka first, and then streaming write\nto Hudi by Flink. Because the direct consumption of ",(0,s.jsx)(n.code,{children:"snapshot data"})," will lead to problems such as high throughput and serious\ndisorder (writing partition randomly), which will lead to write performance degradation and throughput glitches. At this time,\nthe ",(0,s.jsx)(n.code,{children:"write.rate.limit"})," option can be turned on to ensure smooth writing."]}),"\n",(0,s.jsx)(n.h3,{id:"options-5",children:"Options"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Option Name"}),(0,s.jsx)(n.th,{children:"Required"}),(0,s.jsx)(n.th,{children:"Default"}),(0,s.jsx)(n.th,{children:"Remarks"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"write.rate.limit"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"false"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"0"})}),(0,s.jsx)(n.td,{children:"Turn off by default"})]})})]}),"\n",(0,s.jsx)(n.h2,{id:"where-to-go-from-here",children:"Where To Go From Here?"}),"\n",(0,s.jsxs)(n.p,{children:["We used Flink here to show case the capabilities of Hudi. However, Hudi can support multiple table types/query types and\nHudi tables can be queried from query engines like Hive, Spark, Flink, Presto and much more. We have put together a\n",(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=VhNgUsxdrD0",children:"demo video"})," that show cases all of this on a docker based setup with all\ndependent systems running locally. We recommend you replicate the same setup and run the demo yourself, by following\nsteps ",(0,s.jsx)(n.a,{href:"/docs/docker_demo",children:"here"})," to get a taste for it. Also, if you are looking for ways to migrate your existing data\nto Hudi, refer to ",(0,s.jsx)(n.a,{href:"/docs/migration_guide",children:"migration guide"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>o});var t=i(96540);const s={},r=t.createContext(s);function d(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);