"use strict";(self.webpackChunkhudi=self.webpackChunkhudi||[]).push([[34543],{28453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>l});var n=a(96540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}},73633:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/images/metadata_table_anim-4d6225cef4c2e0937805288146eaf6ad.gif"},97568:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"metadata","title":"Table Metadata","description":"Hudi tracks metadata about a table to remove bottlenecks in achieving great read/write performance, specifically on cloud storage.","source":"@site/docs/metadata.md","sourceDirName":".","slug":"/metadata","permalink":"/docs/next/metadata","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hudi/tree/asf-site/website/docs/metadata.md","tags":[],"version":"current","frontMatter":{"title":"Table Metadata","keywords":["hudi","metadata","S3","GCS","file listings","statistics"]},"sidebar":"docs","previous":{"title":"Record Mergers","permalink":"/docs/next/record_merger"},"next":{"title":"Indexes","permalink":"/docs/next/indexes"}}');var i=a(74848),s=a(28453);const r={title:"Table Metadata",keywords:["hudi","metadata","S3","GCS","file listings","statistics"]},l=void 0,d={},o=[{value:"Metadata Table",id:"metadata-table",level:2},{value:"Types of table metadata",id:"types-of-table-metadata",level:2},{value:"Metadata Tracking on Writers",id:"metadata-tracking-on-writers",level:2},{value:"Leveraging metadata during queries",id:"leveraging-metadata-during-queries",level:2},{value:"files index",id:"files-index",level:3},{value:"column_stats index and data skipping",id:"column_stats-index-and-data-skipping",level:3},{value:"Concurrency Control for Metadata Table",id:"concurrency-control-for-metadata-table",level:2},{value:"Related Resources",id:"related-resources",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Hudi tracks metadata about a table to remove bottlenecks in achieving great read/write performance, specifically on cloud storage."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Avoid list operations to obtain set of files in a table"}),": A fundamental need for any engine that wants to read or write Hudi tables is\nto know all the files/objects that are part of the table, by performing listing of table partitions/folders. Unlike many distributed file systems,\nsuch operation scales poorly on cloud storage taking few seconds or even many minutes on large tables. This is particularly amplified when tables\nare large and partitioned multiple levels deep. Hudi tracks the file listings so they are readily available for readers/writers without listing the folders\ncontaining the data files."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Expose columns statistics for better query planning and faster queries"}),":  Query engines rely on techniques such as partitioning and data skipping\nto cut down on the amount of irrelevant data scanned for query planning and execution. During query planning phase, file footer statistics like column value ranges,\nnull counts are read from all data files to  determine if a particular file needs to be read to satisfy the query. This approach is expensive since reading\nfooters from all files can increase cloud storage API costs and even be subject to throttling issues for larger tables. Hudi enables relevant query predicates to\nbe efficiently evaluated on operate on column statistics without incurring these costs."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"metadata-table",children:"Metadata Table"}),"\n",(0,i.jsxs)(t.p,{children:["Hudi employs a special ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.em,{children:"metadata table"})}),", within each table to provide these capabilities. The metadata table implemented as a single\ninternal Hudi Merge-On-Read table that hosts different types of table metadata in each partition. This is similar to common practices in databases where metadata\nis tracked using internal tables. This approach provides the following advantages."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Scalable"}),": The table metadata must scale to large sizes as well (see ",(0,i.jsx)(t.a,{href:"https://vldb.org/pvldb/vol14/p3083-edara.pdf",children:"Big Metadata paper"})," from Google).\nDifferent types of indexes should be easily integrated to support various use cases with consistent management of metadata. By implementing metadata using the\nsame storage format and engine used for data, Hudi is able to scale to even TBs of metadata with built-in table services for managing metadata."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Flexible"}),": The foundational framework for multi-modal indexing is built to enable and disable new indexes as needed. The\n",(0,i.jsx)(t.a,{href:"https://www.onehouse.ai/blog/asynchronous-indexing-using-hudi",children:"async indexing"})," protocol index building alongside regular writers without impacting the write latency."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"transactional updates"}),": Tables data, metadata and indexes must be upto-date and consistent with each other as writes happen or table services are performed. and table metadata must be always up-to-date and in sync with the data table.\nThe data and metadata table's timelines share a parent-child relationship, to ensure they are always in sync with each other. Furthermore, the MoR table storage helps absorb fast changes to metadata from streaming writes without requiring\nrewriting of all table metadata on each write."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Fast lookups"}),": By employing a SSTable like base file format (HFile) in the metadata table, query engines are able to efficiently perform lookup scans for only specific parts of\nmetadata needed. For e.g. query accessing only 10 out of 100 columns in a table can read stats about only the 10 columns it's interested in, during down planning time and costs.\nFurther, these metadata can also be served via a centralized/embedded timeline server which caches the metadata, further reducing the latency of the lookup from executors."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{alt:"Metadata Table Mechanics",src:a(73633).A+"",width:"1280",height:"720"}),"\n",(0,i.jsx)("p",{align:"center",children:"Figure: Mechanics for Metadata Table in Hudi"})]}),"\n",(0,i.jsx)(t.h2,{id:"types-of-table-metadata",children:"Types of table metadata"}),"\n",(0,i.jsx)(t.p,{children:"Following are the different types of metadata currently supported."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"https://cwiki.apache.org/confluence/display/HUDI/RFC+-+15%3A+HUDI+File+Listing+Improvements",children:"files listings"})})}),":\nStored as ",(0,i.jsx)(t.em,{children:"files"})," partition in the metadata table. Contains file information such as file name, size, and active state\nfor each partition in the data table, along with list of all partitions in the table. Improves the files listing performance\nby avoiding direct storage calls such as ",(0,i.jsx)(t.em,{children:"exists, listStatus"})," and ",(0,i.jsx)(t.em,{children:"listFiles"})," on the data table."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.a,{href:"https://github.com/apache/hudi/blob/master/rfc/rfc-27/rfc-27.md",children:"column statistics"})})}),": Stored as ",(0,i.jsx)(t.em,{children:"column_stats"}),"\npartition in the metadata table. Contains the statistics for a set of tracked columns, such as min and max values, total values,\nnull counts, size, etc., for all data files and are used while serving queries with predicates matching interested\ncolumns. This is heavily used by techniques like ",(0,i.jsx)(t.a,{href:"https://www.onehouse.ai/blog/hudis-column-stats-index-and-data-skipping-feature-help-speed-up-queries-by-an-orders-of-magnitude",children:"data skipping"})," to speed up queries by orders of magnitude, by skipping\nirrelevant files."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:(0,i.jsx)(t.strong,{children:"Partition Statistics"})}),": Partition stats index aggregates statistics at the partition level for the columns tracked by\nthe column statistics for which it is enabled. This helps in efficient partition pruning by skipping entire folders very quickly,\neven without examining column statistics at the file level. The partition stats index is stored in ",(0,i.jsx)(t.em,{children:"partition_stats"})," partition in the metadata table.\nPartition stats index can be enabled using the following configs (note it is required to specify the columns for which stats should be aggregated)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["To try out these features, refer to the ",(0,i.jsx)(t.a,{href:"sql_ddl#create-partition-stats-index",children:"SQL guide"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"metadata-tracking-on-writers",children:"Metadata Tracking on Writers"}),"\n",(0,i.jsxs)(t.p,{children:["Following are based basic configs that are needed to enable metadata tracking. For advanced configs please refer\n",(0,i.jsx)(t.a,{href:"configurations#Metadata-Configs",children:"here"}),"."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Config Name"}),(0,i.jsx)(t.th,{children:"Default"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"hoodie.metadata.enable"}),(0,i.jsx)(t.td,{children:"true (Optional) Enabled on the write side"}),(0,i.jsxs)(t.td,{children:["Enable the internal metadata table serving file listings. For 0.10.1 and prior releases, metadata table is disabled by default and needs to be explicitly enabled.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Config Param: ENABLE"}),(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Since Version: 0.7.0"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"hoodie.metadata.index.column.stats.enable"}),(0,i.jsx)(t.td,{children:"false (Optional)"}),(0,i.jsxs)(t.td,{children:["Enable column statistics tracking of files under metadata table. When enabled, metadata table will have a partition to store the column ranges and will be used for pruning files during data skipping.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Config Param: ENABLE_METADATA_INDEX_COLUMN_STATS"}),(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Since Version: 0.11.0"})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"hoodie.metadata.index.column.stats.columns"}),(0,i.jsx)(t.td,{children:"all columns in the table"}),(0,i.jsx)(t.td,{children:"Comma separated list of columns to track column statistics on."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"hoodie.metadata.index.partition.stats.enable"}),(0,i.jsx)(t.td,{children:"false (Optional)"}),(0,i.jsx)(t.td,{children:"Enable the partition stats tracking, on the same columns tracked by column stats metadata."})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["For Flink, following are the basic configs of interest to enable metadata tracking. Please refer\n",(0,i.jsx)(t.a,{href:"https://hudi.apache.org/docs/next/configurations#Flink-Options",children:"here"})," for advanced configs"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Config Name"}),(0,i.jsx)(t.th,{children:"Default"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"metadata.enabled"}),(0,i.jsx)(t.td,{children:"true (Optional)"}),(0,i.jsxs)(t.td,{children:["Enable the internal metadata table which serves table metadata like level file listings, default enabled",(0,i.jsx)("br",{}),(0,i.jsx)("br",{})," ",(0,i.jsx)(t.code,{children:"Config Param: METADATA_ENABLED"})]})]})})]}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsx)(t.p,{children:"If you turn off the metadata table after enabling, be sure to wait for a few commits so that the metadata table is fully\ncleaned up, before re-enabling the metadata table again."})}),"\n",(0,i.jsx)(t.h2,{id:"leveraging-metadata-during-queries",children:"Leveraging metadata during queries"}),"\n",(0,i.jsx)(t.h3,{id:"files-index",children:"files index"}),"\n",(0,i.jsxs)(t.p,{children:["Metadata based listing using ",(0,i.jsx)(t.em,{children:"files_index"})," can be leveraged on the read side by setting appropriate configs/session properties\nfrom different engines as shown below:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Readers"}),(0,i.jsx)(t.th,{children:"Config"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Spark DataSource, Spark SQL, Strucured Streaming"}),(0,i.jsx)(t.td,{children:"hoodie.metadata.enable"}),(0,i.jsxs)(t.td,{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," enables use of the spark file index implementation for Hudi, that speeds up listing of large tables.",(0,i.jsx)("br",{})]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Flink DataStream, Flink SQL"}),(0,i.jsx)(t.td,{children:"metadata.enabled"}),(0,i.jsxs)(t.td,{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," from DDL uses the internal metadata table to serves table metadata like level file listings"]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Presto"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://prestodb.io/docs/current/connector/hudi.html",children:"hudi.metadata-table-enabled"})}),(0,i.jsxs)(t.td,{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," fetches the list of file names and sizes from Hudi\u2019s metadata table rather than storage."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Trino"}),(0,i.jsx)(t.td,{children:"N/A"}),(0,i.jsxs)(t.td,{children:["Support for reading from the metadata table ",(0,i.jsx)(t.a,{href:"https://issues.apache.org/jira/browse/HUDI-7020",children:"has been dropped in Trino 419"}),"."]})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Athena"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"https://docs.aws.amazon.com/athena/latest/ug/querying-hudi.html",children:"hudi.metadata-listing-enabled"})}),(0,i.jsxs)(t.td,{children:["When this table property is set to ",(0,i.jsx)(t.code,{children:"TRUE"})," enables the Hudi metadata table and the related file listing functionality"]})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"column_stats-index-and-data-skipping",children:"column_stats index and data skipping"}),"\n",(0,i.jsx)(t.p,{children:"Enabling metadata table and column stats index is a prerequisite to enabling data skipping capabilities. Following are the\ncorresponding configs across Spark and Flink readers."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Readers"}),(0,i.jsx)(t.th,{children:"Config"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Spark DataSource, Spark SQL, Strucured Streaming"}),(0,i.jsx)(t.td,{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsx)(t.code,{children:"hoodie.metadata.enable"})}),(0,i.jsx)("li",{children:(0,i.jsx)(t.code,{children:"hoodie.enable.data.skipping"})})]})}),(0,i.jsx)(t.td,{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," enables use of the spark file index implementation for Hudi, that speeds up listing of large tables."]}),(0,i.jsxs)("li",{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," enables data-skipping allowing queries to leverage indexes to reduce the search space by skipping over files ",(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Config Param: ENABLE_DATA_SKIPPING"}),(0,i.jsx)("br",{}),(0,i.jsx)(t.code,{children:"Since Version: 0.10.0"})," ",(0,i.jsx)("br",{})]})]})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Flink DataStream, Flink SQL"}),(0,i.jsx)(t.td,{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsx)(t.code,{children:"metadata.enabled"})}),(0,i.jsx)("li",{children:(0,i.jsx)(t.code,{children:"read.data.skipping.enabled"})})]})}),(0,i.jsx)(t.td,{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[" When set to ",(0,i.jsx)(t.code,{children:"true"})," from DDL uses the internal metadata table to serves table metadata like level file listings"]}),(0,i.jsxs)("li",{children:["When set to ",(0,i.jsx)(t.code,{children:"true"})," enables data-skipping allowing queries to leverage indexes to reduce the search space byskipping over files"]})]})})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"concurrency-control-for-metadata-table",children:"Concurrency Control for Metadata Table"}),"\n",(0,i.jsxs)(t.p,{children:["To ensure that metadata table stays up to date and table metadata is tracked safely across concurrent write and\ntable operations, there are some additional considerations. If async table services are enabled for the table (i.e. running a separate compaction (",(0,i.jsx)(t.code,{children:"HoodieCompactor"}),") or\nclustering (",(0,i.jsx)(t.code,{children:"HoodieClusteringJob"}),") job), even with just a single writer, lock providers\nmust be configured. Please refer to ",(0,i.jsx)(t.a,{href:"concurrency_control",children:"concurrency control"})," for more details."]}),"\n",(0,i.jsxs)(t.p,{children:["Before enabling metadata table for the first time, all writers on the same table must and table services must be stopped.\nIf your current deployment model is ",(0,i.jsx)(t.a,{href:"concurrency_control#full-on-multi-writer--async-table-services",children:"multi-writer"})," along with a lock\nprovider and other required configs set for every writer as follows, there is no additional configuration required. You\ncan bring up the writers sequentially after stopping the writers for enabling metadata table. Applying the proper\nconfigurations to only a subset of writers or table services is unsafe and can lead to loss of data. So, please ensure you enable\nmetadata table across all writers."]}),"\n",(0,i.jsx)(t.h2,{id:"related-resources",children:"Related Resources"}),"\n",(0,i.jsx)("h3",{children:"Blogs"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://medium.com/@simpsons/table-service-deployment-models-in-apache-hudi-9cfa5a44addf",children:"Table service deployment models in Apache Hudi"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.onehouse.ai/blog/introducing-multi-modal-index-for-the-lakehouse-in-apache-hudi",children:"Multi Modal Indexing for the Data Lakehouse"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://www.onehouse.ai/blog/how-to-optimize-performance-for-your-open-data-lakehouse",children:"How to Optimize Performance for Your Open Data Lakehouse"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);