<!doctype html>
<html class="docs-version-0.14.0 docs-custom-styles" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.14">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Apache Hudi: User-Facing Analytics RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Apache Hudi: User-Facing Analytics Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="Apache Hudi: User-Facing Analytics JSON Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Apache Hudi" href="/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/videos/rss.xml" title="Apache Hudi RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/videos/atom.xml" title="Apache Hudi Atom Feed">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Comfortaa|Ubuntu|Roboto|Source+Code+Pro">
<link rel="stylesheet" href="https://at-ui.github.io/feather-font/css/iconfont.css"><title data-react-helmet="true">All Configurations | Apache Hudi</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://hudi.apache.org/docs/configurations"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="0.14.0"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-0.14.0"><meta data-react-helmet="true" property="og:title" content="All Configurations | Apache Hudi"><meta data-react-helmet="true" name="description" content="This page covers the different ways of configuring your job to write/read Hudi tables. At a high level, you can control behaviour at few levels."><meta data-react-helmet="true" property="og:description" content="This page covers the different ways of configuring your job to write/read Hudi tables. At a high level, you can control behaviour at few levels."><meta data-react-helmet="true" name="keywords" content="configurations,default,flink options,spark,configs,parameters"><link data-react-helmet="true" rel="icon" href="/assets/images/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://hudi.apache.org/docs/configurations"><link data-react-helmet="true" rel="alternate" href="https://hudi.apache.org/docs/configurations" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://hudi.apache.org/cn/docs/configurations" hreflang="cn"><link data-react-helmet="true" rel="alternate" href="https://hudi.apache.org/docs/configurations" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.89e78e7f.css">
<link rel="preload" href="/assets/js/runtime~main.072d1a07.js" as="script">
<link rel="preload" href="/assets/js/main.4a28cd57.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><div class="announcementBar_axC9" role="banner"><div class="announcementBarPlaceholder_xYHE"></div><div class="announcementBarContent_6uhP">⭐️ If you like Apache Hudi, give it a star on <a target="_blank" rel="noopener noreferrer" href="https://github.com/apache/hudi">GitHub</a>! ⭐</div><button type="button" class="clean-btn close announcementBarClose_A3A1" aria-label="Close"><svg viewBox="0 0 15 15" width="14" height="14"><g stroke="currentColor" stroke-width="3.1"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><nav class="navbar navbar--fixed-top navbarWrapper_UIa0"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo navbarLogo_Bz6n"><img src="/assets/images/hudi.png" alt="Apache Hudi" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/assets/images/hudi.png" alt="Apache Hudi" class="themedImage_TMUO themedImage--dark_uzRr"></div></a><a class="navbar__item navbar__link" href="/docs/overview"><div class="labelWrapperDropdown_Mqbj">Docs</div></a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link downloadLinkDropdownHide_aDP3"><div class="labelWrapperDropdown_Mqbj">Learn<svg width="10" height="6" viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.5 1.25 5 4.75l-3.5-3.5" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/talks"><div class="labelWrapperDropdown_Mqbj">Talks</div></a></li><li><a class="dropdown__link" href="/videos"><div class="labelWrapperDropdown_Mqbj">Video Guides</div></a></li><li><a class="dropdown__link" href="/docs/faq"><div class="labelWrapperDropdown_Mqbj">FAQ</div></a></li><li><a class="dropdown__link" href="/tech-specs"><div class="labelWrapperDropdown_Mqbj">Tech Specs</div></a></li><li><a class="dropdown__link" href="/tech-specs-1point0"><div class="labelWrapperDropdown_Mqbj">Tech Specs 1.0</div></a></li><li><a href="https://cwiki.apache.org/confluence/display/HUDI" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span class="externalLink_AE3f">Technical Wiki<svg width="20" height="20" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.965 8.745 9.01 16.7M10.561 8.758l6.403-.013-.013 6.403" stroke="#0DB1F9" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><rect x="4.5" y="4.5" width="17" height="17" rx="2.5" stroke="#0DB1F9"></rect></svg></span></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link downloadLinkDropdownHide_aDP3"><div class="labelWrapperDropdown_Mqbj">Contribute<svg width="10" height="6" viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.5 1.25 5 4.75l-3.5-3.5" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/contribute/how-to-contribute"><div class="labelWrapperDropdown_Mqbj">How to Contribute</div></a></li><li><a class="dropdown__link" href="/contribute/developer-setup"><div class="labelWrapperDropdown_Mqbj">Developer Setup</div></a></li><li><a class="dropdown__link" href="/contribute/rfc-process"><div class="labelWrapperDropdown_Mqbj">RFC Process</div></a></li><li><a class="dropdown__link" href="/contribute/report-security-issues"><div class="labelWrapperDropdown_Mqbj">Report Security Issues</div></a></li><li><a href="https://issues.apache.org/jira/projects/HUDI/summary" target="_blank" rel="noopener noreferrer" class="dropdown__link"><span class="externalLink_AE3f">Report Issues<svg width="20" height="20" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16.965 8.745 9.01 16.7M10.561 8.758l6.403-.013-.013 6.403" stroke="#0DB1F9" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><rect x="4.5" y="4.5" width="17" height="17" rx="2.5" stroke="#0DB1F9"></rect></svg></span></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable"><a href="#" class="navbar__link downloadLinkDropdownHide_aDP3"><div class="labelWrapperDropdown_Mqbj">Community<svg width="10" height="6" viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.5 1.25 5 4.75l-3.5-3.5" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/community/get-involved"><div class="labelWrapperDropdown_Mqbj">Get Involved</div></a></li><li><a class="dropdown__link" href="/community/syncs"><div class="labelWrapperDropdown_Mqbj">Community Syncs</div></a></li><li><a class="dropdown__link" href="/community/office_hours"><div class="labelWrapperDropdown_Mqbj">Office Hours</div></a></li><li><a class="dropdown__link" href="/community/team"><div class="labelWrapperDropdown_Mqbj">Team</div></a></li></ul></div><a class="navbar__item navbar__link" href="/blog"><div class="labelWrapperDropdown_Mqbj">Blog</div></a><a class="navbar__item navbar__link" href="/powered-by"><div class="labelWrapperDropdown_Mqbj">Who&#x27;s Using</div></a><a class="navbar__item navbar__link" href="/roadmap"><div class="labelWrapperDropdown_Mqbj">Roadmap</div></a><a class="navbar__item navbar__link" href="/releases/download"><div class="labelWrapperDropdown_Mqbj">Download</div></a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link downloadLinkDropdownHide_aDP3" href="/docs/overview"><div class="labelWrapperDropdown_Mqbj">0.14.0<svg width="10" height="6" viewBox="0 0 10 6" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8.5 1.25 5 4.75l-3.5-3.5" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/configurations"><div class="labelWrapperDropdown_Mqbj">Current</div></a></li><li><a aria-current="page" class="dropdown__link dropdown__link--active" href="/docs/configurations"><div class="labelWrapperDropdown_Mqbj">0.14.0</div></a></li><li><a class="dropdown__link" href="/docs/0.13.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.13.1</div></a></li><li><a class="dropdown__link" href="/docs/0.13.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.13.0</div></a></li><li><a class="dropdown__link" href="/docs/0.12.3/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.3</div></a></li><li><a class="dropdown__link" href="/docs/0.12.2/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.2</div></a></li><li><a class="dropdown__link" href="/docs/0.12.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.1</div></a></li><li><a class="dropdown__link" href="/docs/0.12.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.0</div></a></li><li><a class="dropdown__link" href="/docs/0.11.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.11.1</div></a></li><li><a class="dropdown__link" href="/docs/0.11.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.11.0</div></a></li><li><a class="dropdown__link" href="/docs/0.10.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.10.1</div></a></li><li><a class="dropdown__link" href="/docs/0.10.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.10.0</div></a></li><li><a class="dropdown__link" href="/docs/0.9.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.9.0</div></a></li><li><a class="dropdown__link" href="/docs/0.8.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.8.0</div></a></li><li><a class="dropdown__link" href="/docs/0.7.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.7.0</div></a></li><li><a class="dropdown__link" href="/docs/0.6.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.6.0</div></a></li><li><a class="dropdown__link" href="/docs/0.5.3/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.3</div></a></li><li><a class="dropdown__link" href="/docs/0.5.2/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.2</div></a></li><li><a class="dropdown__link" href="/docs/0.5.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.1</div></a></li><li><a class="dropdown__link" href="/docs/0.5.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.0</div></a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__link downloadLinkDropdownHide_aDP3"><div class="labelWrapperDropdown_Mqbj"><span><svg viewBox="0 0 20 20" width="20" height="20" aria-hidden="true" class="iconLanguage_zID8"><path fill="currentColor" d="M19.753 10.909c-.624-1.707-2.366-2.726-4.661-2.726-.09 0-.176.002-.262.006l-.016-2.063 3.525-.607c.115-.019.133-.119.109-.231-.023-.111-.167-.883-.188-.976-.027-.131-.102-.127-.207-.109-.104.018-3.25.461-3.25.461l-.013-2.078c-.001-.125-.069-.158-.194-.156l-1.025.016c-.105.002-.164.049-.162.148l.033 2.307s-3.061.527-3.144.543c-.084.014-.17.053-.151.143.019.09.19 1.094.208 1.172.018.08.072.129.188.107l2.924-.504.035 2.018c-1.077.281-1.801.824-2.256 1.303-.768.807-1.207 1.887-1.207 2.963 0 1.586.971 2.529 2.328 2.695 3.162.387 5.119-3.06 5.769-4.715 1.097 1.506.256 4.354-2.094 5.98-.043.029-.098.129-.033.207l.619.756c.08.096.206.059.256.023 2.51-1.73 3.661-4.515 2.869-6.683zm-7.386 3.188c-.966-.121-.944-.914-.944-1.453 0-.773.327-1.58.876-2.156a3.21 3.21 0 011.229-.799l.082 4.277a2.773 2.773 0 01-1.243.131zm2.427-.553l.046-4.109c.084-.004.166-.01.252-.01.773 0 1.494.145 1.885.361.391.217-1.023 2.713-2.183 3.758zm-8.95-7.668a.196.196 0 00-.196-.145h-1.95a.194.194 0 00-.194.144L.008 16.916c-.017.051-.011.076.062.076h1.733c.075 0 .099-.023.114-.072l1.008-3.318h3.496l1.008 3.318c.016.049.039.072.113.072h1.734c.072 0 .078-.025.062-.076-.014-.05-3.083-9.741-3.494-11.04zm-2.618 6.318l1.447-5.25 1.447 5.25H3.226z"></path></svg><span>English</span></span><svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#a)"><path d="M14 6.457a6.842 6.842 0 0 0-7-6.02 6.843 6.843 0 0 0-7 6.02v1.085a6.843 6.843 0 0 0 7 6.02 6.843 6.843 0 0 0 7-6.02V6.457Zm-1.094 0h-2.625a9.92 9.92 0 0 0-.376-2.222 6.65 6.65 0 0 0 1.531-.875 5.25 5.25 0 0 1 1.444 3.097h.026Zm-8.032 0a8.479 8.479 0 0 1 .324-1.872 7.376 7.376 0 0 0 3.63 0c.175.61.284 1.239.325 1.872h-4.28Zm4.305 1.085a8.391 8.391 0 0 1-.324 1.873 7.464 7.464 0 0 0-3.658 0 8.479 8.479 0 0 1-.323-1.873h4.305Zm.35-4.375A10.342 10.342 0 0 0 8.75 1.75c.627.194 1.218.49 1.75.875a5.748 5.748 0 0 1-.998.577l.027-.035ZM7.254 1.54A8.75 8.75 0 0 1 8.46 3.552c-.48.11-.97.165-1.461.167-.492-.001-.982-.057-1.461-.167.308-.722.715-1.4 1.207-2.012h.508ZM4.498 3.202a5.748 5.748 0 0 1-.998-.577 6.029 6.029 0 0 1 1.75-.875c-.294.46-.546.947-.753 1.452Zm-1.873.15c.47.358.984.652 1.531.874A9.625 9.625 0 0 0 3.78 6.45H1.155a5.25 5.25 0 0 1 1.47-3.098ZM1.12 7.541h2.625c.038.753.164 1.5.376 2.223a6.649 6.649 0 0 0-1.531.875 5.25 5.25 0 0 1-1.47-3.098Zm3.377 3.255c.207.506.459.992.753 1.453a6.03 6.03 0 0 1-1.75-.875c.312-.226.646-.419.997-.578Zm2.25 1.663a8.594 8.594 0 0 1-1.208-2.013 6.501 6.501 0 0 1 2.922 0 8.54 8.54 0 0 1-1.207 2.013h-.508Zm2.755-1.663c.367.156.716.35 1.042.578a6.338 6.338 0 0 1-1.75.875c.275-.464.512-.95.708-1.453Zm1.873-.148a6.647 6.647 0 0 0-1.531-.875 9.45 9.45 0 0 0 .376-2.223h2.625a5.25 5.25 0 0 1-1.47 3.098Z" fill="#1C1E21"></path></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h14v14H0z"></path></clipPath></defs></svg></div></a><ul class="dropdown__menu"><li><a href="/docs/configurations" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active"><div class="labelWrapperDropdown_Mqbj">English</div></a></li><li><a href="/cn/docs/configurations" target="_self" rel="noopener noreferrer" class="dropdown__link"><div class="labelWrapperDropdown_Mqbj">Chinese</div></a></li></ul></div><a href="https://github.com/apache/hudi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"><div class="labelWrapperDropdown_Mqbj"></div></a><a href="https://twitter.com/ApacheHudi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-twitter-link" aria-label="Hudi Twitter Handle"><div class="labelWrapperDropdown_Mqbj"></div></a><a href="https://join.slack.com/t/apache-hudi/shared_invite/zt-20r833rxh-627NWYDUyR8jRtMa2mZ~gg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-slack-link" aria-label="Hudi Slack Channel"><div class="labelWrapperDropdown_Mqbj"></div></a><a href="https://www.youtube.com/channel/UCs7AhE0BWaEPZSChrBR-Muw" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-youtube-link" aria-label="Hudi YouTube Channel"><div class="labelWrapperDropdown_Mqbj"></div></a><a href="https://www.linkedin.com/company/apache-hudi/?viewAsMember=true" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-linkedin-link" aria-label="Hudi Linkedin Page"><div class="labelWrapperDropdown_Mqbj"></div></a><div class="searchBox_fBfG"><div role="button" class="searchButton_g9-U" aria-label="Search"><span class="searchText_RI6l">Search</span><svg width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="6.864" cy="6.864" r="5.243" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></circle><path d="m10.51 10.783 2.056 2.05" stroke="#1C1E21" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/assets/images/hudi.png" alt="Apache Hudi" class="themedImage_TMUO themedImage--light_4Vu1"><img src="/assets/images/hudi.png" alt="Apache Hudi" class="themedImage_TMUO themedImage--dark_uzRr"></div></a><button type="button" class="clean-btn navbar-sidebar__close"><svg viewBox="0 0 15 15" width="21" height="21"><g stroke="var(--ifm-color-emphasis-600)" stroke-width="1.2"><path d="M.75.75l13.5 13.5M14.25.75L.75 14.25"></path></g></svg></button></div><div class="navbar-sidebar__items"><div class="navbar-sidebar__item menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/overview"><div class="labelWrapperDropdown_Mqbj">Docs</div></a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist"><div class="labelWrapperDropdown_Mqbj">Learn</div></a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist"><div class="labelWrapperDropdown_Mqbj">Contribute</div></a></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist"><div class="labelWrapperDropdown_Mqbj">Community</div></a></li><li class="menu__list-item"><a class="menu__link" href="/blog"><div class="labelWrapperDropdown_Mqbj">Blog</div></a></li><li class="menu__list-item"><a class="menu__link" href="/powered-by"><div class="labelWrapperDropdown_Mqbj">Who&#x27;s Using</div></a></li><li class="menu__list-item"><a class="menu__link" href="/roadmap"><div class="labelWrapperDropdown_Mqbj">Roadmap</div></a></li><li class="menu__list-item"><a class="menu__link" href="/releases/download"><div class="labelWrapperDropdown_Mqbj">Download</div></a></li><li class="menu__list-item"><a role="button" class="menu__link menu__link--sublist"><div class="labelWrapperDropdown_Mqbj">Versions</div></a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/next/configurations"><div class="labelWrapperDropdown_Mqbj">Current</div></a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/configurations"><div class="labelWrapperDropdown_Mqbj">0.14.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.13.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.13.1</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.13.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.13.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.12.3/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.3</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.12.2/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.2</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.12.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.1</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.12.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.12.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.11.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.11.1</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.11.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.11.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.10.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.10.1</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.10.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.10.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.9.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.9.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.8.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.8.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.7.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.7.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.6.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.6.0</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.5.3/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.3</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.5.2/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.2</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.5.1/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.1</div></a></li><li class="menu__list-item"><a class="menu__link" href="/docs/0.5.0/configurations"><div class="labelWrapperDropdown_Mqbj">0.5.0</div></a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a role="button" class="menu__link menu__link--sublist"><div class="labelWrapperDropdown_Mqbj"><span><svg viewBox="0 0 20 20" width="20" height="20" aria-hidden="true" class="iconLanguage_zID8"><path fill="currentColor" d="M19.753 10.909c-.624-1.707-2.366-2.726-4.661-2.726-.09 0-.176.002-.262.006l-.016-2.063 3.525-.607c.115-.019.133-.119.109-.231-.023-.111-.167-.883-.188-.976-.027-.131-.102-.127-.207-.109-.104.018-3.25.461-3.25.461l-.013-2.078c-.001-.125-.069-.158-.194-.156l-1.025.016c-.105.002-.164.049-.162.148l.033 2.307s-3.061.527-3.144.543c-.084.014-.17.053-.151.143.019.09.19 1.094.208 1.172.018.08.072.129.188.107l2.924-.504.035 2.018c-1.077.281-1.801.824-2.256 1.303-.768.807-1.207 1.887-1.207 2.963 0 1.586.971 2.529 2.328 2.695 3.162.387 5.119-3.06 5.769-4.715 1.097 1.506.256 4.354-2.094 5.98-.043.029-.098.129-.033.207l.619.756c.08.096.206.059.256.023 2.51-1.73 3.661-4.515 2.869-6.683zm-7.386 3.188c-.966-.121-.944-.914-.944-1.453 0-.773.327-1.58.876-2.156a3.21 3.21 0 011.229-.799l.082 4.277a2.773 2.773 0 01-1.243.131zm2.427-.553l.046-4.109c.084-.004.166-.01.252-.01.773 0 1.494.145 1.885.361.391.217-1.023 2.713-2.183 3.758zm-8.95-7.668a.196.196 0 00-.196-.145h-1.95a.194.194 0 00-.194.144L.008 16.916c-.017.051-.011.076.062.076h1.733c.075 0 .099-.023.114-.072l1.008-3.318h3.496l1.008 3.318c.016.049.039.072.113.072h1.734c.072 0 .078-.025.062-.076-.014-.05-3.083-9.741-3.494-11.04zm-2.618 6.318l1.447-5.25 1.447 5.25H3.226z"></path></svg><span>Languages</span></span></div></a></li><li class="menu__list-item"><a href="https://github.com/apache/hudi" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"><div class="labelWrapperDropdown_Mqbj"></div></a></li><li class="menu__list-item"><a href="https://twitter.com/ApacheHudi" target="_blank" rel="noopener noreferrer" class="menu__link header-twitter-link" aria-label="Hudi Twitter Handle"><div class="labelWrapperDropdown_Mqbj"></div></a></li><li class="menu__list-item"><a href="https://join.slack.com/t/apache-hudi/shared_invite/zt-20r833rxh-627NWYDUyR8jRtMa2mZ~gg" target="_blank" rel="noopener noreferrer" class="menu__link header-slack-link" aria-label="Hudi Slack Channel"><div class="labelWrapperDropdown_Mqbj"></div></a></li><li class="menu__list-item"><a href="https://www.youtube.com/channel/UCs7AhE0BWaEPZSChrBR-Muw" target="_blank" rel="noopener noreferrer" class="menu__link header-youtube-link" aria-label="Hudi YouTube Channel"><div class="labelWrapperDropdown_Mqbj"></div></a></li><li class="menu__list-item"><a href="https://www.linkedin.com/company/apache-hudi/?viewAsMember=true" target="_blank" rel="noopener noreferrer" class="menu__link header-linkedin-link" aria-label="Hudi Linkedin Page"><div class="labelWrapperDropdown_Mqbj"></div></a></li></ul></div><div class="navbar-sidebar__item menu"><button type="button" class="clean-btn navbar-sidebar__back">← Back to main menu</button></div></div></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_GMj9"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_i9tI" type="button"></button><aside class="docSidebarContainer_k0Pq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/overview">Overview</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/quick-start-guide">Quick Start</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/quick-start-guide">Spark Guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/flink-quick-start-guide">Flink Guide</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/docker_demo">Docker Demo</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/timeline">Concepts</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/sql_ddl">How To</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/migration_guide">Services</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active hasHref_TwRn" href="/docs/basic_configurations">Configurations</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/basic_configurations">Basic Configurations</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/configurations">All Configurations</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist hasHref_TwRn" href="/docs/performance">Guides</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/use_cases">Use Cases</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/faq">FAQs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/privacy">Privacy Policy</a></li></ul></nav></div></aside><main class="docMainContainer_Q970"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><span class="theme-doc-version-badge badge badge--secondary">Version: <!-- -->0.14.0</span><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>All Configurations</h1></header><p>This page covers the different ways of configuring your job to write/read Hudi tables. At a high level, you can control behaviour at few levels.</p><div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>tip</h5></div><div class="admonition-content"><p>With <a href="/docs/configurations#externalized-config-file">externalized config file</a>,
instead of directly passing configuration settings to every Hudi job,
you can also centrally set them in a configuration file <code>hudi-default.conf</code>.</p></div></div><p>By default, Hudi would load the configuration file under <code>/etc/hudi/conf</code> directory. You can specify a different configuration directory location by setting the <code>HUDI_CONF_DIR</code> environment variable.</p><ul><li><a href="#SPARK_DATASOURCE"><strong>Spark Datasource Configs</strong></a>: These configs control the Hudi Spark Datasource, providing ability to define keys/partitioning, pick out the write operation, specify how to merge records or choosing query type to read.</li><li><a href="#FLINK_SQL"><strong>Flink Sql Configs</strong></a>: These configs control the Hudi Flink SQL source/sink connectors, providing ability to define record keys, pick out the write operation, specify how to merge records, enable/disable asynchronous compaction or choosing query type to read.</li><li><a href="#WRITE_CLIENT"><strong>Write Client Configs</strong></a>: Internally, the Hudi datasource uses a RDD based HoodieWriteClient API to actually perform writes to storage. These configs provide deep control over lower level aspects like file sizing, compression, parallelism, compaction, write schema, cleaning etc. Although Hudi provides sane defaults, from time-time these configs may need to be tweaked to optimize for specific workloads.</li><li><a href="#META_SYNC"><strong>Metastore and Catalog Sync Configs</strong></a>: Configurations used by the Hudi to sync metadata to external metastores and catalogs.</li><li><a href="#METRICS"><strong>Metrics Configs</strong></a>: These set of configs are used to enable monitoring and reporting of key Hudi stats and metrics.</li><li><a href="#RECORD_PAYLOAD"><strong>Record Payload Config</strong></a>: This is the lowest level of customization offered by Hudi. Record payloads define how to produce new values to upsert based on incoming new record and stored old record. Hudi provides default implementations such as OverwriteWithLatestAvroPayload which simply update table with the latest/last-written record. This can be overridden to a custom class extending HoodieRecordPayload class, on both datasource and WriteClient levels.</li><li><a href="#KAFKA_CONNECT"><strong>Kafka Connect Configs</strong></a>: These set of configs are used for Kafka Connect Sink Connector for writing Hudi Tables</li><li><a href="#AWS"><strong>Amazon Web Services Configs</strong></a>: Configurations specific to Amazon Web Services.</li><li><a href="#HUDI_STREAMER"><strong>Hudi Streamer Configs</strong></a>: These set of configs are used for Hudi Streamer utility which provides the way to ingest from different sources such as DFS or Kafka.</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</h5></div><div class="admonition-content"><p>In the tables below <strong>(N/A)</strong> means there is no default value set</p></div></div><h2 class="anchor anchorWithStickyNavbar_y2LR" id="externalized-config-file">Externalized Config File<a class="hash-link" href="#externalized-config-file" title="Direct link to heading">​</a></h2><p>Instead of directly passing configuration settings to every Hudi job, you can also centrally set them in a configuration
file <code>hudi-default.conf</code>. By default, Hudi would load the configuration file under <code>/etc/hudi/conf</code> directory. You can
specify a different configuration directory location by setting the <code>HUDI_CONF_DIR</code> environment variable. This can be
useful for uniformly enforcing repeated configs (like Hive sync or write/index tuning), across your entire data lake.</p><p>Each line in the configuration file consists of a key and a value separated by whitespace or = sign. For example:</p><div class="codeBlockContainer_J+bg theme-code-block"><div class="codeBlockContent_csEI"><pre tabindex="0" class="prism-code language-undefined codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">hoodie.datasource.hive_sync.mode               jdbc</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">hoodie.datasource.hive_sync.jdbcurl            jdbc:hive2://localhost:10000</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">hoodie.datasource.hive_sync.support_timestamp  false</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>It helps to have a central configuration file for your common cross job configurations/tunings, so all the jobs on your cluster can utilize it.
It also works with Spark SQL DML/DDL, and helps avoid having to pass configs inside the SQL statements.</p><h2 class="anchor anchorWithStickyNavbar_y2LR" id="SPARK_DATASOURCE">Spark Datasource Configs<a class="hash-link" href="#SPARK_DATASOURCE" title="Direct link to heading">​</a></h2><p>These configs control the Hudi Spark Datasource, providing ability to define keys/partitioning, pick out the write operation, specify how to merge records or choosing query type to read.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Read-Options">Read Options<a class="hash-link" href="#Read-Options" title="Direct link to heading">​</a></h3><p>Options useful for reading tables via <code>read.format.option(...)</code></p><p><a href="#Read-Options-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcereadbegininstanttime">hoodie.datasource.read.begin.instanttime</a></td><td>(N/A)</td><td>Required when <code>hoodie.datasource.query.type</code> is set to <code>incremental</code>. Represents the instant time to start incrementally pulling data from. The instanttime here need not necessarily correspond to an instant on the timeline. New data written with an instant_time <!-- -->&gt;<!-- --> BEGIN_INSTANTTIME are fetched out. For e.g: ‘20170901080000’ will get all new data written after Sep 1, 2017 08:00AM. Note that if <code>hoodie.read.timeline.holes.resolution.policy</code> set to USE_TRANSITION_TIME, will use instant&#x27;s <code>stateTransitionTime</code> to perform comparison.<br><code>Config Param: BEGIN_INSTANTTIME</code></td></tr><tr><td><a href="#hoodiedatasourcereadendinstanttime">hoodie.datasource.read.end.instanttime</a></td><td>(N/A)</td><td>Used when <code>hoodie.datasource.query.type</code> is set to <code>incremental</code>. Represents the instant time to limit incrementally fetched data to. When not specified latest commit time from timeline is assumed by default. When specified, new data written with an instant_time <!-- -->&lt;<!-- -->= END_INSTANTTIME are fetched out. Point in time type queries make more sense with begin and end instant times specified. Note that if <code>hoodie.read.timeline.holes.resolution.policy</code> set to <code>USE_TRANSITION_TIME</code>, will use instant&#x27;s <code>stateTransitionTime</code> to perform comparison.<br><code>Config Param: END_INSTANTTIME</code></td></tr><tr><td><a href="#hoodiedatasourcequerytype">hoodie.datasource.query.type</a></td><td>snapshot</td><td>Whether data needs to be read, in <code>incremental</code> mode (new data since an instantTime) (or) <code>read_optimized</code> mode (obtain latest view, based on base files) (or) <code>snapshot</code> mode (obtain latest view, by merging base and (if any) log files)<br><code>Config Param: QUERY_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewriteprecombinefield">hoodie.datasource.write.precombine.field</a></td><td>ts</td><td>Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)<br><code>Config Param: READ_PRE_COMBINE_FIELD</code></td></tr></tbody></table><p><a href="#Read-Options-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#asofinstant">as.of.instant</a></td><td>(N/A)</td><td>The query instant for time travel. Without specified this option, we query the latest snapshot.<br><code>Config Param: TIME_TRAVEL_AS_OF_INSTANT</code></td></tr><tr><td><a href="#hoodiedatasourcereadpaths">hoodie.datasource.read.paths</a></td><td>(N/A)</td><td>Comma separated list of file paths to read within a Hudi table.<br><code>Config Param: READ_PATHS</code></td></tr><tr><td><a href="#hoodiedatasourcemergetype">hoodie.datasource.merge.type</a></td><td>payload_combine</td><td>For Snapshot query on merge on read table, control whether we invoke the record payload implementation to merge (payload_combine) or skip merging altogetherskip_merge<br><code>Config Param: REALTIME_MERGE</code></td></tr><tr><td><a href="#hoodiedatasourcequeryincrementalformat">hoodie.datasource.query.incremental.format</a></td><td>latest_state</td><td>This config is used alone with the &#x27;incremental&#x27; query type.When set to &#x27;latest_state&#x27;, it returns the latest records&#x27; values.When set to &#x27;cdc&#x27;, it returns the cdc data.<br><code>Config Param: INCREMENTAL_FORMAT</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcereadextractpartitionvaluesfrompath">hoodie.datasource.read.extract.partition.values.from.path</a></td><td>false</td><td>When set to true, values for partition columns (partition values) will be extracted from physical partition path (default Spark behavior). When set to false partition values will be read from the data file (in Hudi partition columns are persisted by default). This config is a fallback allowing to preserve existing behavior, and should not be used otherwise.<br><code>Config Param: EXTRACT_PARTITION_VALUES_FROM_PARTITION_PATH</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiedatasourcereadfileindexlistingmode">hoodie.datasource.read.file.index.listing.mode</a></td><td>lazy</td><td>Overrides Hudi&#x27;s file-index implementation&#x27;s file listing mode: when set to &#x27;eager&#x27;, file-index will list all partition paths and corresponding file slices w/in them eagerly, during initialization, prior to partition-pruning kicking in, meaning that all partitions will be listed including ones that might be  subsequently pruned out; when set to &#x27;lazy&#x27;, partitions and file-slices w/in them will be listed lazily (ie when they actually accessed, instead of when file-index is initialized) allowing partition pruning to occur before that, only listing partitions that has already been pruned. Please note that, this config is provided purely to allow to fallback to behavior existing prior to 0.13.0 release, and will be deprecated soon after.<br><code>Config Param: FILE_INDEX_LISTING_MODE_OVERRIDE</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcereadfileindexlistingpartition-path-prefixanalysisenabled">hoodie.datasource.read.file.index.listing.partition-path-prefix.analysis.enabled</a></td><td>true</td><td>Controls whether partition-path prefix analysis is enabled w/in the file-index, allowing to avoid necessity to recursively list deep folder structures of partitioned tables w/ multiple partition columns, by carefully analyzing provided partition-column predicates and deducing corresponding partition-path prefix from  them (if possible).<br><code>Config Param: FILE_INDEX_LISTING_PARTITION_PATH_PREFIX_ANALYSIS_ENABLED</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcereadincrfallbackfulltablescanenable">hoodie.datasource.read.incr.fallback.fulltablescan.enable</a></td><td>false</td><td>When doing an incremental query whether we should fall back to full table scans if file does not exist.<br><code>Config Param: INCREMENTAL_FALLBACK_TO_FULL_TABLE_SCAN_FOR_NON_EXISTING_FILES</code></td></tr><tr><td><a href="#hoodiedatasourcereadincrfilters">hoodie.datasource.read.incr.filters</a></td><td></td><td>For use-cases like DeltaStreamer which reads from Hoodie Incremental table and applies opaque map functions, filters appearing late in the sequence of transformations cannot be automatically pushed down. This option allows setting filters directly on Hoodie Source.<br><code>Config Param: PUSH_DOWN_INCR_FILTERS</code></td></tr><tr><td><a href="#hoodiedatasourcereadincrpathglob">hoodie.datasource.read.incr.path.glob</a></td><td></td><td>For the use-cases like users only want to incremental pull from certain partitions instead of the full table. This option allows using glob pattern to directly filter on path.<br><code>Config Param: INCR_PATH_GLOB</code></td></tr><tr><td><a href="#hoodiedatasourcereadschemauseendinstanttime">hoodie.datasource.read.schema.use.end.instanttime</a></td><td>false</td><td>Uses end instant schema when incrementally fetched data to. Default: users latest instant schema.<br><code>Config Param: INCREMENTAL_READ_SCHEMA_USE_END_INSTANTTIME</code></td></tr><tr><td><a href="#hoodiedatasourcereadusenewparquetfileformat">hoodie.datasource.read.use.new.parquet.file.format</a></td><td>false</td><td>Read using the new Hudi parquet file format. The new Hudi parquet file format is introduced as an experimental feature in 0.14.0. Currently, the new Hudi parquet file format only applies to bootstrap and MOR queries. Schema evolution is also not supported by the new file format.<br><code>Config Param: USE_NEW_HUDI_PARQUET_FILE_FORMAT</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcestreamingstartOffset">hoodie.datasource.streaming.startOffset</a></td><td>earliest</td><td>Start offset to pull data from hoodie streaming source. allow earliest, latest, and specified start instant time<br><code>Config Param: START_OFFSET</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodieenabledataskipping">hoodie.enable.data.skipping</a></td><td>false</td><td>Enables data-skipping allowing queries to leverage indexes to reduce the search space by skipping over files<br><code>Config Param: ENABLE_DATA_SKIPPING</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiefileindexenable">hoodie.file.index.enable</a></td><td>true</td><td>Enables use of the spark file index implementation for Hudi, that speeds up listing of large tables.<br><code>Config Param: ENABLE_HOODIE_FILE_INDEX</code></td></tr><tr><td><a href="#hoodiereadtimelineholesresolutionpolicy">hoodie.read.timeline.holes.resolution.policy</a></td><td>FAIL</td><td>When doing incremental queries, there could be hollow commits (requested or inflight commits that are not the latest) that are produced by concurrent writers and could lead to potential data loss. This config allows users to have different ways of handling this situation. The valid values are <!-- -->[FAIL, BLOCK, USE_TRANSITION_TIME]<!-- -->: Use <code>FAIL</code> to throw an exception when hollow commit is detected. This is helpful when hollow commits are not expected. Use <code>BLOCK</code> to block processing commits from going beyond the hollow ones. This fits the case where waiting for hollow commits to finish is acceptable. Use <code>USE_TRANSITION_TIME</code> (experimental) to query commits in range by state transition time (completion time), instead of commit time (start time). Using this mode will result in <code>begin.instanttime</code> and <code>end.instanttime</code> using <code>stateTransitionTime</code>  instead of the instant&#x27;s commit time.<br><code>Config Param: INCREMENTAL_READ_HANDLE_HOLLOW_COMMIT</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodieschemaonreadenable">hoodie.schema.on.read.enable</a></td><td>false</td><td>Enables support for Schema Evolution feature<br><code>Config Param: SCHEMA_EVOLUTION_ENABLED</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Write-Options">Write Options<a class="hash-link" href="#Write-Options" title="Direct link to heading">​</a></h3><p>You can pass down any of the WriteClient level configs directly using <code>options()</code> or <code>option(k,v)</code> methods.</p><div class="codeBlockContainer_J+bg language-java theme-code-block"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#F8F8F2;background-color:#282A36"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#F8F8F2"><span class="token plain">inputDF.write()</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.format(&quot;org.apache.hudi&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.options(clientOpts) // any of the Hudi client opts can be passed in as well</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.option(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), &quot;_row_key&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.option(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), &quot;partition&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.option(DataSourceWriteOptions.PRECOMBINE_FIELD_OPT_KEY(), &quot;timestamp&quot;)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.option(HoodieWriteConfig.TABLE_NAME, tableName)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.mode(SaveMode.Append)</span><br></span><span class="token-line" style="color:#F8F8F2"><span class="token plain">.save(basePath);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>Options useful for writing tables via <code>write.format.option(...)</code></p><p><a href="#Write-Options-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncmode">hoodie.datasource.hive_sync.mode</a></td><td>(N/A)</td><td>Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql.<br><code>Config Param: HIVE_SYNC_MODE</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionpathfield">hoodie.datasource.write.partitionpath.field</a></td><td>(N/A)</td><td>Partition path field. Value to be used at the partitionPath component of HoodieKey. Actual value obtained by invoking .toString()<br><code>Config Param: PARTITIONPATH_FIELD</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordkeyfield">hoodie.datasource.write.recordkey.field</a></td><td>(N/A)</td><td>Record key field. Value to be used as the <code>recordKey</code> component of <code>HoodieKey</code>. Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg: <code>a.b.c</code><br><code>Config Param: RECORDKEY_FIELD</code></td></tr><tr><td><a href="#hoodieclusteringasyncenabled">hoodie.clustering.async.enabled</a></td><td>false</td><td>Enable running of clustering service, asynchronously as inserts happen on the table.<br><code>Config Param: ASYNC_CLUSTERING_ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringinline">hoodie.clustering.inline</a></td><td>false</td><td>Turn on inline clustering - clustering will be run after each write operation is complete<br><code>Config Param: INLINE_CLUSTERING_ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncenable">hoodie.datasource.hive_sync.enable</a></td><td>false</td><td>When set to true, register/sync the table to Apache Hive metastore.<br><code>Config Param: HIVE_SYNC_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncjdbcurl">hoodie.datasource.hive_sync.jdbcurl</a></td><td>jdbc:hive2://localhost:10000</td><td>Hive metastore url<br><code>Config Param: HIVE_URL</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncmetastoreuris">hoodie.datasource.hive_sync.metastore.uris</a></td><td>thrift://localhost:9083</td><td>Hive metastore url<br><code>Config Param: METASTORE_URIS</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcewritehive_style_partitioning">hoodie.datasource.write.hive_style_partitioning</a></td><td>false</td><td>Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <!-- -->&lt;<!-- -->partition_column_name<!-- -->&gt;<!-- -->=<!-- -->&lt;<!-- -->partition_value<!-- -->&gt;<!-- --> format. By default false (the names of partition folders are only partition values)<br><code>Config Param: HIVE_STYLE_PARTITIONING</code></td></tr><tr><td><a href="#hoodiedatasourcewriteoperation">hoodie.datasource.write.operation</a></td><td>upsert</td><td>Whether to do upsert, insert or bulk_insert for the write operation. Use bulk_insert to load new data into a table, and there on use upsert/insert. bulk insert uses a disk based write path to scale to load large inputs without need to cache it.<br><code>Config Param: OPERATION</code></td></tr><tr><td><a href="#hoodiedatasourcewriteprecombinefield">hoodie.datasource.write.precombine.field</a></td><td>ts</td><td>Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)<br><code>Config Param: PRECOMBINE_FIELD</code></td></tr><tr><td><a href="#hoodiedatasourcewritetabletype">hoodie.datasource.write.table.type</a></td><td>COPY_ON_WRITE</td><td>The table type for the underlying data, for this write. This can’t change between writes.<br><code>Config Param: TABLE_TYPE</code></td></tr></tbody></table><p><a href="#Write-Options-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncserde_properties">hoodie.datasource.hive_sync.serde_properties</a></td><td>(N/A)</td><td>Serde properties to hive table.<br><code>Config Param: HIVE_TABLE_SERDE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable_properties">hoodie.datasource.hive_sync.table_properties</a></td><td>(N/A)</td><td>Additional properties to store with table.<br><code>Config Param: HIVE_TABLE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourceoverwritemode">hoodie.datasource.overwrite.mode</a></td><td>(N/A)</td><td>Controls whether overwrite use dynamic or static mode, if not configured, respect spark.sql.sources.partitionOverwriteMode<br><code>Config Param: OVERWRITE_MODE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionstodelete">hoodie.datasource.write.partitions.to.delete</a></td><td>(N/A)</td><td>Comma separated list of partitions to delete. Allows use of wildcard *<br><code>Config Param: PARTITIONS_TO_DELETE</code></td></tr><tr><td><a href="#hoodiedatasourcewritetablename">hoodie.datasource.write.table.name</a></td><td>(N/A)</td><td>Table name for the datasource write. Also used to register the table into meta stores.<br><code>Config Param: TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcecompactionasyncenable">hoodie.datasource.compaction.async.enable</a></td><td>true</td><td>Controls whether async compaction should be turned on for MOR table writing.<br><code>Config Param: ASYNC_COMPACT_ENABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: HIVE_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncauto_create_database">hoodie.datasource.hive_sync.auto_create_database</a></td><td>true</td><td>Auto create hive database if does not exists<br><code>Config Param: HIVE_AUTO_CREATE_DATABASE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: HIVE_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbatch_num">hoodie.datasource.hive_sync.batch_num</a></td><td>1000</td><td>The number of partitions one batch when synchronous partitions to hive.<br><code>Config Param: HIVE_BATCH_SYNC_PARTITION_NUM</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbucket_sync">hoodie.datasource.hive_sync.bucket_sync</a></td><td>false</td><td>Whether sync hive metastore bucket specification when using bucket index.The specification is &#x27;CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS&#x27;<br><code>Config Param: HIVE_SYNC_BUCKET_SYNC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synccreate_managed_table">hoodie.datasource.hive_sync.create_managed_table</a></td><td>false</td><td>Whether to sync the table as managed table.<br><code>Config Param: HIVE_CREATE_MANAGED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: HIVE_DATABASE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncignore_exceptions">hoodie.datasource.hive_sync.ignore_exceptions</a></td><td>false</td><td>Ignore exceptions when syncing with Hive.<br><code>Config Param: HIVE_IGNORE_EXCEPTIONS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: HIVE_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: HIVE_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpassword">hoodie.datasource.hive_sync.password</a></td><td>hive</td><td>hive password to use<br><code>Config Param: HIVE_PASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncskip_ro_suffix">hoodie.datasource.hive_sync.skip_ro_suffix</a></td><td>false</td><td>Skip the _ro suffix for Read optimized table, when registering<br><code>Config Param: HIVE_SKIP_RO_SUFFIX_FOR_READ_OPTIMIZED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsupport_timestamp">hoodie.datasource.hive_sync.support_timestamp</a></td><td>false</td><td>‘INT64’ with original type TIMESTAMP_MICROS is converted to hive ‘timestamp’ type. Disabled by default for backward compatibility.<br><code>Config Param: HIVE_SUPPORT_TIMESTAMP_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_as_datasource">hoodie.datasource.hive_sync.sync_as_datasource</a></td><td>true</td><td><br><code>Config Param: HIVE_SYNC_AS_DATA_SOURCE_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_comment">hoodie.datasource.hive_sync.sync_comment</a></td><td>false</td><td>Whether to sync the table column comments while syncing the table.<br><code>Config Param: HIVE_SYNC_COMMENT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: HIVE_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_jdbc">hoodie.datasource.hive_sync.use_jdbc</a></td><td>true</td><td>Use JDBC when hive synchronization is enabled<br><code>Config Param: HIVE_USE_JDBC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_pre_apache_input_format">hoodie.datasource.hive_sync.use_pre_apache_input_format</a></td><td>false</td><td>Flag to choose InputFormat under com.uber.hoodie package instead of org.apache.hudi package. Use this when you are in the process of migrating from com.uber.hoodie to org.apache.hudi. Stop using this after you migrated the table definition to org.apache.hudi input format<br><code>Config Param: HIVE_USE_PRE_APACHE_INPUT_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncusername">hoodie.datasource.hive_sync.username</a></td><td>hive</td><td>hive user name to use<br><code>Config Param: HIVE_USER</code></td></tr><tr><td><a href="#hoodiedatasourceinsertduppolicy">hoodie.datasource.insert.dup.policy</a></td><td>none</td><td>When operation type is set to &quot;insert&quot;, users can optionally enforce a dedup policy. This policy will be employed  when records being ingested already exists in storage. Default policy is none and no action will be taken. Another option is to choose  &quot;drop&quot;, on which matching records from incoming will be dropped and the rest will be ingested. Third option is &quot;fail&quot; which will fail the write operation when same records are re-ingested. In other words, a given record as deduced by the key generation policy can be ingested only once to the target table of interest.<br><code>Config Param: INSERT_DUP_POLICY</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: HIVE_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiedatasourcewritecommitmetakeyprefix">hoodie.datasource.write.commitmeta.key.prefix</a></td><td>_</td><td>Option keys beginning with this prefix, are automatically added to the commit/deltacommit metadata. This is useful to store checkpointing information, in a consistent way with the hudi timeline<br><code>Config Param: COMMIT_METADATA_KEYPREFIX</code></td></tr><tr><td><a href="#hoodiedatasourcewritedroppartitioncolumns">hoodie.datasource.write.drop.partition.columns</a></td><td>false</td><td>When set to true, will not write the partition columns into hudi. By default, false.<br><code>Config Param: DROP_PARTITION_COLUMNS</code></td></tr><tr><td><a href="#hoodiedatasourcewriteinsertdropduplicates">hoodie.datasource.write.insert.drop.duplicates</a></td><td>false</td><td>If set to true, records from the incoming dataframe will not overwrite existing records with the same key during the write operation. This config is deprecated as of 0.14.0. Please use hoodie.datasource.insert.dup.policy instead.<br><code>Config Param: INSERT_DROP_DUPS</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratorclass">hoodie.datasource.write.keygenerator.class</a></td><td>org.apache.hudi.keygen.SimpleKeyGenerator</td><td>Key generator class, that implements <code>org.apache.hudi.keygen.KeyGenerator</code><br><code>Config Param: KEYGENERATOR_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratorconsistentlogicaltimestampenabled">hoodie.datasource.write.keygenerator.consistent.logical.timestamp.enabled</a></td><td>false</td><td>When set to true, consistent value will be generated for a logical timestamp type column, like timestamp-millis and timestamp-micros, irrespective of whether row-writer is enabled. Disabled by default so as not to break the pipeline that deploy either fully row-writer path or non row-writer path. For example, if it is kept disabled then record key of timestamp type with value <code>2016-12-29 09:54:00</code> will be written as timestamp <code>2016-12-29 09:54:00.0</code> in row-writer path, while it will be written as long value <code>1483023240000000</code> in non row-writer path. If enabled, then the timestamp value will be written in both the cases.<br><code>Config Param: KEYGENERATOR_CONSISTENT_LOGICAL_TIMESTAMP_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcewritenewcolumnsnullable">hoodie.datasource.write.new.columns.nullable</a></td><td>false</td><td>When a non-nullable column is added to datasource during a write operation, the write  operation will fail schema compatibility check. Set this option to true will make the newly added  column nullable to successfully complete the write operation.<br><code>Config Param: MAKE_NEW_COLUMNS_NULLABLE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionpathurlencode">hoodie.datasource.write.partitionpath.urlencode</a></td><td>false</td><td>Should we url encode the partition path value, before creating the folder structure.<br><code>Config Param: URL_ENCODE_PARTITIONING</code></td></tr><tr><td><a href="#hoodiedatasourcewritepayloadclass">hoodie.datasource.write.payload.class</a></td><td>org.apache.hudi.common.model.OverwriteWithLatestAvroPayload</td><td>Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for PRECOMBINE_FIELD_OPT_VAL in-effective<br><code>Config Param: PAYLOAD_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewritereconcileschema">hoodie.datasource.write.reconcile.schema</a></td><td>false</td><td>This config controls how writer&#x27;s schema will be selected based on the incoming batch&#x27;s schema as well as existing table&#x27;s one. When schema reconciliation is DISABLED, incoming batch&#x27;s schema will be picked as a writer-schema (therefore updating table&#x27;s schema). When schema reconciliation is ENABLED, writer-schema will be picked such that table&#x27;s schema (after txn) is either kept the same or extended, meaning that we&#x27;ll always prefer the schema that either adds new columns or stays the same. This enables us, to always extend the table&#x27;s schema during evolution and never lose the data (when, for ex, existing column is being dropped in a new batch)<br><code>Config Param: RECONCILE_SCHEMA</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordmergerimpls">hoodie.datasource.write.record.merger.impls</a></td><td>org.apache.hudi.common.model.HoodieAvroRecordMerger</td><td>List of HoodieMerger implementations constituting Hudi&#x27;s merging strategy -- based on the engine used. These merger impls will filter by hoodie.datasource.write.record.merger.strategy Hudi will pick most efficient implementation to perform merging/combining of the records (during update, reading MOR table, etc)<br><code>Config Param: RECORD_MERGER_IMPLS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordmergerstrategy">hoodie.datasource.write.record.merger.strategy</a></td><td>eeb8d96f-b1e4-49fd-bbf8-28ac514178e5</td><td>Id of merger strategy. Hudi will pick HoodieRecordMerger implementations in hoodie.datasource.write.record.merger.impls which has the same merger strategy id<br><code>Config Param: RECORD_MERGER_STRATEGY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcewriterowwriterenable">hoodie.datasource.write.row.writer.enable</a></td><td>true</td><td>When set to true, will perform write operations directly using the spark native <code>Row</code> representation, avoiding any additional conversion costs.<br><code>Config Param: ENABLE_ROW_WRITER</code></td></tr><tr><td><a href="#hoodiedatasourcewritestreamingcheckpointidentifier">hoodie.datasource.write.streaming.checkpoint.identifier</a></td><td>default_single_writer</td><td>A stream identifier used for HUDI to fetch the right checkpoint(<code>batch id</code> to be more specific) corresponding this writer. Please note that keep the identifier an unique value for different writer if under multi-writer scenario. If the value is not set, will only keep the checkpoint info in the memory. This could introduce the potential issue that the job is restart(<code>batch id</code> is lost) while spark checkpoint write fails, causing spark will retry and rewrite the data.<br><code>Config Param: STREAMING_CHECKPOINT_IDENTIFIER</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcewritestreamingdisablecompaction">hoodie.datasource.write.streaming.disable.compaction</a></td><td>false</td><td>By default for MOR table, async compaction is enabled with spark streaming sink. By setting this config to true, we can disable it and the expectation is that, users will schedule and execute compaction in a different process/job altogether. Some users may wish to run it separately to manage resources across table services and regular ingestion pipeline and so this could be preferred on such cases.<br><code>Config Param: STREAMING_DISABLE_COMPACTION</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcewritestreamingignorefailedbatch">hoodie.datasource.write.streaming.ignore.failed.batch</a></td><td>false</td><td>Config to indicate whether to ignore any non exception error (e.g. writestatus error) within a streaming microbatch. Turning this on, could hide the write status errors while the spark checkpoint moves ahead.So, would recommend users to use this with caution.<br><code>Config Param: STREAMING_IGNORE_FAILED_BATCH</code></td></tr><tr><td><a href="#hoodiedatasourcewritestreamingretrycount">hoodie.datasource.write.streaming.retry.count</a></td><td>3</td><td>Config to indicate how many times streaming job should retry for a failed micro batch.<br><code>Config Param: STREAMING_RETRY_CNT</code></td></tr><tr><td><a href="#hoodiedatasourcewritestreamingretryintervalms">hoodie.datasource.write.streaming.retry.interval.ms</a></td><td>2000</td><td>Config to indicate how long (by millisecond) before a retry should issued for failed microbatch<br><code>Config Param: STREAMING_RETRY_INTERVAL_MS</code></td></tr><tr><td><a href="#hoodiemetasyncclienttoolclass">hoodie.meta.sync.client.tool.class</a></td><td>org.apache.hudi.hive.HiveSyncTool</td><td>Sync tool class name used to sync to metastore. Defaults to Hive.<br><code>Config Param: META_SYNC_CLIENT_TOOL_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiesparksqlinsertintooperation">hoodie.spark.sql.insert.into.operation</a></td><td>insert</td><td>Sql write operation to use with INSERT_INTO spark sql command. This comes with 3 possible values, bulk_insert, insert and upsert. bulk_insert is generally meant for initial loads and is known to be performant compared to insert. But bulk_insert may not do small file management. If you prefer hudi to automatically manage small files, then you can go with &quot;insert&quot;. There is no precombine (if there are duplicates within the same batch being ingested, same dups will be ingested) with bulk_insert and insert and there is no index look up as well. If you may use INSERT_INTO for mutable dataset, then you may have to set this config value to &quot;upsert&quot;. With upsert, you will get both precombine and updates to existing records on storage is also honored. If not, you may see duplicates. <br><code>Config Param: SPARK_SQL_INSERT_INTO_OPERATION</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiesparksqloptimizedwritesenable">hoodie.spark.sql.optimized.writes.enable</a></td><td>true</td><td>Controls whether spark sql prepped update, delete, and merge are enabled.<br><code>Config Param: SPARK_SQL_OPTIMIZED_WRITES</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiesqlbulkinsertenable">hoodie.sql.bulk.insert.enable</a></td><td>false</td><td>When set to true, the sql insert statement will use bulk insert. This config is deprecated as of 0.14.0. Please use hoodie.spark.sql.insert.into.operation instead.<br><code>Config Param: SQL_ENABLE_BULK_INSERT</code></td></tr><tr><td><a href="#hoodiesqlinsertmode">hoodie.sql.insert.mode</a></td><td>upsert</td><td>Insert mode when insert data to pk-table. The optional modes are: upsert, strict and non-strict.For upsert mode, insert statement do the upsert operation for the pk-table which will update the duplicate record.For strict mode, insert statement will keep the primary key uniqueness constraint which do not allow duplicate record.While for non-strict mode, hudi just do the insert operation for the pk-table. This config is deprecated as of 0.14.0. Please use hoodie.spark.sql.insert.into.operation and hoodie.datasource.insert.dup.policy as you see fit.<br><code>Config Param: SQL_INSERT_MODE</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkavaluedeserializerclass">hoodie.streamer.source.kafka.value.deserializer.class</a></td><td>io.confluent.kafka.serializers.KafkaAvroDeserializer</td><td>This class is used by kafka client to deserialize the records<br><code>Config Param: KAFKA_AVRO_VALUE_DESERIALIZER_CLASS</code><br><code>Since Version: 0.9.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="PreCommit-Validator-Configurations">PreCommit Validator Configurations<a class="hash-link" href="#PreCommit-Validator-Configurations" title="Direct link to heading">​</a></h3><p>The following set of configurations help validate new data before commits.</p><p><a href="#PreCommit-Validator-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieprecommitvalidators">hoodie.precommit.validators</a></td><td></td><td>Comma separated list of class names that can be invoked to validate commit<br><code>Config Param: VALIDATOR_CLASS_NAMES</code></td></tr><tr><td><a href="#hoodieprecommitvalidatorsequalitysqlqueries">hoodie.precommit.validators.equality.sql.queries</a></td><td></td><td>Spark SQL queries to run on table before committing new data to validate state before and after commit. Multiple queries separated by &#x27;;&#x27; delimiter are supported. Example: &quot;select count(*) from \<!-- -->&lt;<!-- -->TABLE_NAME\<!-- -->&gt;<!-- --> Note \<!-- -->&lt;<!-- -->TABLE_NAME\<!-- -->&gt;<!-- --> is replaced by table state before and after commit.<br><code>Config Param: EQUALITY_SQL_QUERIES</code></td></tr><tr><td><a href="#hoodieprecommitvalidatorsinequalitysqlqueries">hoodie.precommit.validators.inequality.sql.queries</a></td><td></td><td>Spark SQL queries to run on table before committing new data to validate state before and after commit.Multiple queries separated by &#x27;;&#x27; delimiter are supported.Example query: &#x27;select count(*) from \<!-- -->&lt;<!-- -->TABLE_NAME\<!-- -->&gt;<!-- --> where col=null&#x27;Note \<!-- -->&lt;<!-- -->TABLE_NAME\<!-- -->&gt;<!-- --> variable is expected to be present in query.<br><code>Config Param: INEQUALITY_SQL_QUERIES</code></td></tr><tr><td><a href="#hoodieprecommitvalidatorssinglevaluesqlqueries">hoodie.precommit.validators.single.value.sql.queries</a></td><td></td><td>Spark SQL queries to run on table before committing new data to validate state after commit.Multiple queries separated by &#x27;;&#x27; delimiter are supported.Expected result is included as part of query separated by &#x27;#&#x27;. Example query: &#x27;query1#result1:query2#result2&#x27;Note \<!-- -->&lt;<!-- -->TABLE_NAME\<!-- -->&gt;<!-- --> variable is expected to be present in query.<br><code>Config Param: SINGLE_VALUE_SQL_QUERIES</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="FLINK_SQL">Flink Sql Configs<a class="hash-link" href="#FLINK_SQL" title="Direct link to heading">​</a></h2><p>These configs control the Hudi Flink SQL source/sink connectors, providing ability to define record keys, pick out the write operation, specify how to merge records, enable/disable asynchronous compaction or choosing query type to read.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Flink-Options">Flink Options<a class="hash-link" href="#Flink-Options" title="Direct link to heading">​</a></h3><p>Flink jobs using the SQL can be configured through the options in WITH clause. The actual datasource level configs are listed below.</p><p><a href="#Flink-Options-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatabasename">hoodie.database.name</a></td><td>(N/A)</td><td>Database name to register to Hive metastore<br> <code>Config Param: DATABASE_NAME</code></td></tr><tr><td><a href="#hoodietablename">hoodie.table.name</a></td><td>(N/A)</td><td>Table name to register to Hive metastore<br> <code>Config Param: TABLE_NAME</code></td></tr><tr><td><a href="#path">path</a></td><td>(N/A)</td><td>Base path for the target hoodie table. The path would be created if it does not exist, otherwise a Hoodie table expects to be initialized successfully<br> <code>Config Param: PATH</code></td></tr><tr><td><a href="#readend-commit">read.end-commit</a></td><td>(N/A)</td><td>End commit instant for reading, the commit time format should be &#x27;yyyyMMddHHmmss&#x27;<br> <code>Config Param: READ_END_COMMIT</code></td></tr><tr><td><a href="#readstart-commit">read.start-commit</a></td><td>(N/A)</td><td>Start commit instant for reading, the commit time format should be &#x27;yyyyMMddHHmmss&#x27;, by default reading from the latest instant for streaming read<br> <code>Config Param: READ_START_COMMIT</code></td></tr><tr><td><a href="#archivemax_commits">archive.max_commits</a></td><td>50</td><td>Max number of commits to keep before archiving older commits into a sequential log, default 50<br> <code>Config Param: ARCHIVE_MAX_COMMITS</code></td></tr><tr><td><a href="#archivemin_commits">archive.min_commits</a></td><td>40</td><td>Min number of commits to keep before archiving older commits into a sequential log, default 40<br> <code>Config Param: ARCHIVE_MIN_COMMITS</code></td></tr><tr><td><a href="#cdcenabled">cdc.enabled</a></td><td>false</td><td>When enable, persist the change data if necessary, and can be queried as a CDC query mode<br> <code>Config Param: CDC_ENABLED</code></td></tr><tr><td><a href="#cdcsupplementalloggingmode">cdc.supplemental.logging.mode</a></td><td>DATA_BEFORE_AFTER</td><td>Setting &#x27;op_key_only&#x27; persists the &#x27;op&#x27; and the record key only, setting &#x27;data_before&#x27; persists the additional &#x27;before&#x27; image, and setting &#x27;data_before_after&#x27; persists the additional &#x27;before&#x27; and &#x27;after&#x27; images.<br> <code>Config Param: SUPPLEMENTAL_LOGGING_MODE</code></td></tr><tr><td><a href="#changelogenabled">changelog.enabled</a></td><td>false</td><td>Whether to keep all the intermediate changes, we try to keep all the changes of a record when enabled: 1). The sink accept the UPDATE_BEFORE message; 2). The source try to emit every changes of a record. The semantics is best effort because the compaction job would finally merge all changes of a record into one.  default false to have UPSERT semantics<br> <code>Config Param: CHANGELOG_ENABLED</code></td></tr><tr><td><a href="#cleanasyncenabled">clean.async.enabled</a></td><td>true</td><td>Whether to cleanup the old commits immediately on new commits, enabled by default<br> <code>Config Param: CLEAN_ASYNC_ENABLED</code></td></tr><tr><td><a href="#cleanretain_commits">clean.retain_commits</a></td><td>30</td><td>Number of commits to retain. So data will be retained for num_of_commits * time_between_commits (scheduled). This also directly translates into how much you can incrementally pull on this table, default 30<br> <code>Config Param: CLEAN_RETAIN_COMMITS</code></td></tr><tr><td><a href="#clusteringasyncenabled">clustering.async.enabled</a></td><td>false</td><td>Async Clustering, default false<br> <code>Config Param: CLUSTERING_ASYNC_ENABLED</code></td></tr><tr><td><a href="#clusteringplanstrategysmallfilelimit">clustering.plan.strategy.small.file.limit</a></td><td>600</td><td>Files smaller than the size specified here are candidates for clustering, default 600 MB<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_SMALL_FILE_LIMIT</code></td></tr><tr><td><a href="#clusteringplanstrategytargetfilemaxbytes">clustering.plan.strategy.target.file.max.bytes</a></td><td>1073741824</td><td>Each group can produce &#x27;N&#x27; (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups, default 1 GB<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_TARGET_FILE_MAX_BYTES</code></td></tr><tr><td><a href="#compactionasyncenabled">compaction.async.enabled</a></td><td>true</td><td>Async Compaction, enabled by default for MOR<br> <code>Config Param: COMPACTION_ASYNC_ENABLED</code></td></tr><tr><td><a href="#compactiondelta_commits">compaction.delta_commits</a></td><td>5</td><td>Max delta commits needed to trigger compaction, default 5 commits<br> <code>Config Param: COMPACTION_DELTA_COMMITS</code></td></tr><tr><td><a href="#hive_syncenabled">hive_sync.enabled</a></td><td>false</td><td>Asynchronously sync Hive meta to HMS, default false<br> <code>Config Param: HIVE_SYNC_ENABLED</code></td></tr><tr><td><a href="#hive_syncjdbc_url">hive_sync.jdbc_url</a></td><td>jdbc:hive2://localhost:10000</td><td>Jdbc URL for hive sync, default &#x27;jdbc:hive2://localhost:10000&#x27;<br> <code>Config Param: HIVE_SYNC_JDBC_URL</code></td></tr><tr><td><a href="#hive_syncmetastoreuris">hive_sync.metastore.uris</a></td><td></td><td>Metastore uris for hive sync, default &#x27;&#x27;<br> <code>Config Param: HIVE_SYNC_METASTORE_URIS</code></td></tr><tr><td><a href="#hive_syncmode">hive_sync.mode</a></td><td>HMS</td><td>Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql, default &#x27;hms&#x27;<br> <code>Config Param: HIVE_SYNC_MODE</code></td></tr><tr><td><a href="#hoodiedatasourcequerytype">hoodie.datasource.query.type</a></td><td>snapshot</td><td>Decides how data files need to be read, in 1) Snapshot mode (obtain latest view, based on row <!-- -->&amp;<!-- --> columnar data); 2) incremental mode (new data since an instantTime); 3) Read Optimized mode (obtain latest view, based on columnar data) .Default: snapshot<br> <code>Config Param: QUERY_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewritehive_style_partitioning">hoodie.datasource.write.hive_style_partitioning</a></td><td>false</td><td>Whether to use Hive style partitioning. If set true, the names of partition folders follow <!-- -->&lt;<!-- -->partition_column_name<!-- -->&gt;<!-- -->=<!-- -->&lt;<!-- -->partition_value<!-- -->&gt;<!-- --> format. By default false (the names of partition folders are only partition values)<br> <code>Config Param: HIVE_STYLE_PARTITIONING</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionpathfield">hoodie.datasource.write.partitionpath.field</a></td><td></td><td>Partition path field. Value to be used at the <code>partitionPath</code> component of <code>HoodieKey</code>. Actual value obtained by invoking .toString(), default &#x27;&#x27;<br> <code>Config Param: PARTITION_PATH_FIELD</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordkeyfield">hoodie.datasource.write.recordkey.field</a></td><td>uuid</td><td>Record key field. Value to be used as the <code>recordKey</code> component of <code>HoodieKey</code>. Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg: <code>a.b.c</code><br> <code>Config Param: RECORD_KEY_FIELD</code></td></tr><tr><td><a href="#indextype">index.type</a></td><td>FLINK_STATE</td><td>Index type of Flink write job, default is using state backed index.<br> <code>Config Param: INDEX_TYPE</code></td></tr><tr><td><a href="#metadatacompactiondelta_commits">metadata.compaction.delta_commits</a></td><td>10</td><td>Max delta commits for metadata table to trigger compaction, default 10<br> <code>Config Param: METADATA_COMPACTION_DELTA_COMMITS</code></td></tr><tr><td><a href="#metadataenabled">metadata.enabled</a></td><td>false</td><td>Enable the internal metadata table which serves table metadata like level file listings, default disabled<br> <code>Config Param: METADATA_ENABLED</code></td></tr><tr><td><a href="#precombinefield">precombine.field</a></td><td>ts</td><td>Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)<br> <code>Config Param: PRECOMBINE_FIELD</code></td></tr><tr><td><a href="#readstreamingenabled">read.streaming.enabled</a></td><td>false</td><td>Whether to read as streaming source, default false<br> <code>Config Param: READ_AS_STREAMING</code></td></tr><tr><td><a href="#tabletype">table.type</a></td><td>COPY_ON_WRITE</td><td>Type of table to write. COPY_ON_WRITE (or) MERGE_ON_READ<br> <code>Config Param: TABLE_TYPE</code></td></tr><tr><td><a href="#writeoperation">write.operation</a></td><td>upsert</td><td>The write operation, that this write should do<br> <code>Config Param: OPERATION</code></td></tr><tr><td><a href="#writeparquetmaxfilesize">write.parquet.max.file.size</a></td><td>120</td><td>Target size for parquet files produced by Hudi write phases. For DFS, this needs to be aligned with the underlying filesystem block size for optimal performance.<br> <code>Config Param: WRITE_PARQUET_MAX_FILE_SIZE</code></td></tr></tbody></table><p><a href="#Flink-Options-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#clusteringtasks">clustering.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do actual clustering, default same as the write task parallelism<br> <code>Config Param: CLUSTERING_TASKS</code></td></tr><tr><td><a href="#compactiontasks">compaction.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do actual compaction, default same as the write task parallelism<br> <code>Config Param: COMPACTION_TASKS</code></td></tr><tr><td><a href="#hive_syncconfdir">hive_sync.conf.dir</a></td><td>(N/A)</td><td>The hive configuration directory, where the hive-site.xml lies in, the file should be put on the client machine<br> <code>Config Param: HIVE_SYNC_CONF_DIR</code></td></tr><tr><td><a href="#hive_syncserde_properties">hive_sync.serde_properties</a></td><td>(N/A)</td><td>Serde properties to hive table, the data format is k1=v1 k2=v2<br> <code>Config Param: HIVE_SYNC_TABLE_SERDE_PROPERTIES</code></td></tr><tr><td><a href="#hive_synctable_properties">hive_sync.table_properties</a></td><td>(N/A)</td><td>Additional properties to store with table, the data format is k1=v1 k2=v2<br> <code>Config Param: HIVE_SYNC_TABLE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratorclass">hoodie.datasource.write.keygenerator.class</a></td><td>(N/A)</td><td>Key generator class, that implements will extract the key out of incoming record<br> <code>Config Param: KEYGEN_CLASS_NAME</code></td></tr><tr><td><a href="#readtasks">read.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do actual read, default is the parallelism of the execution environment<br> <code>Config Param: READ_TASKS</code></td></tr><tr><td><a href="#sourceavro-schema">source.avro-schema</a></td><td>(N/A)</td><td>Source avro schema string, the parsed schema is used for deserialization<br> <code>Config Param: SOURCE_AVRO_SCHEMA</code></td></tr><tr><td><a href="#sourceavro-schemapath">source.avro-schema.path</a></td><td>(N/A)</td><td>Source avro schema file path, the parsed schema is used for deserialization<br> <code>Config Param: SOURCE_AVRO_SCHEMA_PATH</code></td></tr><tr><td><a href="#writebucket_assigntasks">write.bucket_assign.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do bucket assign, default same as the write task parallelism<br> <code>Config Param: BUCKET_ASSIGN_TASKS</code></td></tr><tr><td><a href="#writeindex_bootstraptasks">write.index_bootstrap.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do index bootstrap, default same as the write task parallelism<br> <code>Config Param: INDEX_BOOTSTRAP_TASKS</code></td></tr><tr><td><a href="#writepartitionformat">write.partition.format</a></td><td>(N/A)</td><td>Partition path format, only valid when &#x27;write.datetime.partitioning&#x27; is true, default is: 1) &#x27;yyyyMMddHH&#x27; for timestamp(3) WITHOUT TIME ZONE, LONG, FLOAT, DOUBLE, DECIMAL; 2) &#x27;yyyyMMdd&#x27; for DATE and INT.<br> <code>Config Param: PARTITION_FORMAT</code></td></tr><tr><td><a href="#writetasks">write.tasks</a></td><td>(N/A)</td><td>Parallelism of tasks that do actual write, default is the parallelism of the execution environment<br> <code>Config Param: WRITE_TASKS</code></td></tr><tr><td><a href="#cleanpolicy">clean.policy</a></td><td>KEEP_LATEST_COMMITS</td><td>Clean policy to manage the Hudi table. Available option: KEEP_LATEST_COMMITS, KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_BY_HOURS.Default is KEEP_LATEST_COMMITS.<br> <code>Config Param: CLEAN_POLICY</code></td></tr><tr><td><a href="#cleanretain_file_versions">clean.retain_file_versions</a></td><td>5</td><td>Number of file versions to retain. default 5<br> <code>Config Param: CLEAN_RETAIN_FILE_VERSIONS</code></td></tr><tr><td><a href="#cleanretain_hours">clean.retain_hours</a></td><td>24</td><td>Number of hours for which commits need to be retained. This config provides a more flexible option ascompared to number of commits retained for cleaning service. Setting this property ensures all the files, but the latest in a file group, corresponding to commits with commit times older than the configured number of hours to be retained are cleaned.<br> <code>Config Param: CLEAN_RETAIN_HOURS</code></td></tr><tr><td><a href="#clusteringdelta_commits">clustering.delta_commits</a></td><td>4</td><td>Max delta commits needed to trigger clustering, default 4 commits<br> <code>Config Param: CLUSTERING_DELTA_COMMITS</code></td></tr><tr><td><a href="#clusteringplanpartitionfiltermode">clustering.plan.partition.filter.mode</a></td><td>NONE</td><td>Partition filter mode used in the creation of clustering plan. Available values are - NONE: do not filter table partition and thus the clustering plan will include all partitions that have clustering candidate.RECENT_DAYS: keep a continuous range of partitions, worked together with configs &#x27;clustering.plan.strategy.daybased.lookback.partitions&#x27; and &#x27;clustering.plan.strategy.daybased.skipfromlatest.partitions.SELECTED_PARTITIONS: keep partitions that are in the specified range <!-- -->[&#x27;clustering.plan.strategy.cluster.begin.partition&#x27;, &#x27;clustering.plan.strategy.cluster.end.partition&#x27;]<!-- -->.DAY_ROLLING: clustering partitions on a rolling basis by the hour to avoid clustering all partitions each time, which strategy sorts the partitions asc and chooses the partition of which index is divided by 24 and the remainder is equal to the current hour.<br> <code>Config Param: CLUSTERING_PLAN_PARTITION_FILTER_MODE_NAME</code></td></tr><tr><td><a href="#clusteringplanstrategyclass">clustering.plan.strategy.class</a></td><td>org.apache.hudi.client.clustering.plan.strategy.FlinkSizeBasedClusteringPlanStrategy</td><td>Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan i.e select what file groups are being clustered. Default strategy, looks at the last N (determined by clustering.plan.strategy.daybased.lookback.partitions) day based partitions picks the small file slices within those partitions.<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_CLASS</code></td></tr><tr><td><a href="#clusteringplanstrategyclusterbeginpartition">clustering.plan.strategy.cluster.begin.partition</a></td><td></td><td>Begin partition used to filter partition (inclusive)<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_CLUSTER_BEGIN_PARTITION</code></td></tr><tr><td><a href="#clusteringplanstrategyclusterendpartition">clustering.plan.strategy.cluster.end.partition</a></td><td></td><td>End partition used to filter partition (inclusive)<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_CLUSTER_END_PARTITION</code></td></tr><tr><td><a href="#clusteringplanstrategydaybasedlookbackpartitions">clustering.plan.strategy.daybased.lookback.partitions</a></td><td>2</td><td>Number of partitions to list to create ClusteringPlan, default is 2<br> <code>Config Param: CLUSTERING_TARGET_PARTITIONS</code></td></tr><tr><td><a href="#clusteringplanstrategydaybasedskipfromlatestpartitions">clustering.plan.strategy.daybased.skipfromlatest.partitions</a></td><td>0</td><td>Number of partitions to skip from latest when choosing partitions to create ClusteringPlan<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_SKIP_PARTITIONS_FROM_LATEST</code></td></tr><tr><td><a href="#clusteringplanstrategymaxnumgroups">clustering.plan.strategy.max.num.groups</a></td><td>30</td><td>Maximum number of groups to create as part of ClusteringPlan. Increasing groups will increase parallelism, default is 30<br> <code>Config Param: CLUSTERING_MAX_NUM_GROUPS</code></td></tr><tr><td><a href="#clusteringplanstrategypartitionregexpattern">clustering.plan.strategy.partition.regex.pattern</a></td><td></td><td>Filter clustering partitions that matched regex pattern<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_PARTITION_REGEX_PATTERN</code></td></tr><tr><td><a href="#clusteringplanstrategypartitionselected">clustering.plan.strategy.partition.selected</a></td><td></td><td>Partitions to run clustering<br> <code>Config Param: CLUSTERING_PLAN_STRATEGY_PARTITION_SELECTED</code></td></tr><tr><td><a href="#clusteringplanstrategysortcolumns">clustering.plan.strategy.sort.columns</a></td><td></td><td>Columns to sort the data by when clustering<br> <code>Config Param: CLUSTERING_SORT_COLUMNS</code></td></tr><tr><td><a href="#clusteringscheduleenabled">clustering.schedule.enabled</a></td><td>false</td><td>Schedule the cluster plan, default false<br> <code>Config Param: CLUSTERING_SCHEDULE_ENABLED</code></td></tr><tr><td><a href="#compactiondelta_seconds">compaction.delta_seconds</a></td><td>3600</td><td>Max delta seconds time needed to trigger compaction, default 1 hour<br> <code>Config Param: COMPACTION_DELTA_SECONDS</code></td></tr><tr><td><a href="#compactionmax_memory">compaction.max_memory</a></td><td>100</td><td>Max memory in MB for compaction spillable map, default 100MB<br> <code>Config Param: COMPACTION_MAX_MEMORY</code></td></tr><tr><td><a href="#compactionscheduleenabled">compaction.schedule.enabled</a></td><td>true</td><td>Schedule the compaction plan, enabled by default for MOR<br> <code>Config Param: COMPACTION_SCHEDULE_ENABLED</code></td></tr><tr><td><a href="#compactiontarget_io">compaction.target_io</a></td><td>512000</td><td>Target IO in MB for per compaction (both read and write), default 500 GB<br> <code>Config Param: COMPACTION_TARGET_IO</code></td></tr><tr><td><a href="#compactiontimeoutseconds">compaction.timeout.seconds</a></td><td>1200</td><td>Max timeout time in seconds for online compaction to rollback, default 20 minutes<br> <code>Config Param: COMPACTION_TIMEOUT_SECONDS</code></td></tr><tr><td><a href="#compactiontriggerstrategy">compaction.trigger.strategy</a></td><td>num_commits</td><td>Strategy to trigger compaction, options are &#x27;num_commits&#x27;: trigger compaction when reach N delta commits; &#x27;time_elapsed&#x27;: trigger compaction when time elapsed <!-- -->&gt;<!-- --> N seconds since last compaction; &#x27;num_and_time&#x27;: trigger compaction when both NUM_COMMITS and TIME_ELAPSED are satisfied; &#x27;num_or_time&#x27;: trigger compaction when NUM_COMMITS or TIME_ELAPSED is satisfied. Default is &#x27;num_commits&#x27;<br> <code>Config Param: COMPACTION_TRIGGER_STRATEGY</code></td></tr><tr><td><a href="#hive_syncassume_date_partitioning">hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/mm/dd, default false<br> <code>Config Param: HIVE_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hive_syncauto_create_db">hive_sync.auto_create_db</a></td><td>true</td><td>Auto create hive database if it does not exists, default true<br> <code>Config Param: HIVE_SYNC_AUTO_CREATE_DB</code></td></tr><tr><td><a href="#hive_syncdb">hive_sync.db</a></td><td>default</td><td>Database name for hive sync, default &#x27;default&#x27;<br> <code>Config Param: HIVE_SYNC_DB</code></td></tr><tr><td><a href="#hive_syncfile_format">hive_sync.file_format</a></td><td>PARQUET</td><td>File format for hive sync, default &#x27;PARQUET&#x27;<br> <code>Config Param: HIVE_SYNC_FILE_FORMAT</code></td></tr><tr><td><a href="#hive_syncignore_exceptions">hive_sync.ignore_exceptions</a></td><td>false</td><td>Ignore exceptions during hive synchronization, default false<br> <code>Config Param: HIVE_SYNC_IGNORE_EXCEPTIONS</code></td></tr><tr><td><a href="#hive_syncpartition_extractor_class">hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Tool to extract the partition value from HDFS path, default &#x27;MultiPartKeysValueExtractor&#x27;<br> <code>Config Param: HIVE_SYNC_PARTITION_EXTRACTOR_CLASS_NAME</code></td></tr><tr><td><a href="#hive_syncpartition_fields">hive_sync.partition_fields</a></td><td></td><td>Partition fields for hive sync, default &#x27;&#x27;<br> <code>Config Param: HIVE_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hive_syncpassword">hive_sync.password</a></td><td>hive</td><td>Password for hive sync, default &#x27;hive&#x27;<br> <code>Config Param: HIVE_SYNC_PASSWORD</code></td></tr><tr><td><a href="#hive_syncskip_ro_suffix">hive_sync.skip_ro_suffix</a></td><td>false</td><td>Skip the _ro suffix for Read optimized table when registering, default false<br> <code>Config Param: HIVE_SYNC_SKIP_RO_SUFFIX</code></td></tr><tr><td><a href="#hive_syncsupport_timestamp">hive_sync.support_timestamp</a></td><td>true</td><td>INT64 with original type TIMESTAMP_MICROS is converted to hive timestamp type. Disabled by default for backward compatibility.<br> <code>Config Param: HIVE_SYNC_SUPPORT_TIMESTAMP</code></td></tr><tr><td><a href="#hive_synctable">hive_sync.table</a></td><td>unknown</td><td>Table name for hive sync, default &#x27;unknown&#x27;<br> <code>Config Param: HIVE_SYNC_TABLE</code></td></tr><tr><td><a href="#hive_synctablestrategy">hive_sync.table.strategy</a></td><td>ALL</td><td>Hive table synchronization strategy. Available option: RO, RT, ALL.<br> <code>Config Param: HIVE_SYNC_TABLE_STRATEGY</code></td></tr><tr><td><a href="#hive_syncuse_jdbc">hive_sync.use_jdbc</a></td><td>true</td><td>Use JDBC when hive synchronization is enabled, default true<br> <code>Config Param: HIVE_SYNC_USE_JDBC</code></td></tr><tr><td><a href="#hive_syncusername">hive_sync.username</a></td><td>hive</td><td>Username for hive sync, default &#x27;hive&#x27;<br> <code>Config Param: HIVE_SYNC_USERNAME</code></td></tr><tr><td><a href="#hoodiebucketindexhashfield">hoodie.bucket.index.hash.field</a></td><td></td><td>Index key field. Value to be used as hashing to find the bucket ID. Should be a subset of or equal to the recordKey fields. Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg: <code>a.b.c</code><br> <code>Config Param: INDEX_KEY_FIELD</code></td></tr><tr><td><a href="#hoodiebucketindexnumbuckets">hoodie.bucket.index.num.buckets</a></td><td>4</td><td>Hudi bucket number per partition. Only affected if using Hudi bucket index.<br> <code>Config Param: BUCKET_INDEX_NUM_BUCKETS</code></td></tr><tr><td><a href="#hoodiedatasourcemergetype">hoodie.datasource.merge.type</a></td><td>payload_combine</td><td>For Snapshot query on merge on read table. Use this key to define how the payloads are merged, in 1) skip_merge: read the base file records plus the log file records; 2) payload_combine: read the base file records first, for each record in base file, checks whether the key is in the    log file records(combines the two records with same key for base and log file records), then read the left log file records<br> <code>Config Param: MERGE_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratortype">hoodie.datasource.write.keygenerator.type</a></td><td>SIMPLE</td><td>Key generator type, that implements will extract the key out of incoming record. <strong>Note</strong> This is being actively worked on. Please use <code>hoodie.datasource.write.keygenerator.class</code> instead.<br> <code>Config Param: KEYGEN_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionpathurlencode">hoodie.datasource.write.partitionpath.urlencode</a></td><td>false</td><td>Whether to encode the partition path url, default false<br> <code>Config Param: URL_ENCODE_PARTITIONING</code></td></tr><tr><td><a href="#hoodieindexbucketengine">hoodie.index.bucket.engine</a></td><td>SIMPLE</td><td>Type of bucket index engine. Available options: [SIMPLE</td></tr><tr><td><a href="#indexbootstrapenabled">index.bootstrap.enabled</a></td><td>false</td><td>Whether to bootstrap the index state from existing hoodie table, default false<br> <code>Config Param: INDEX_BOOTSTRAP_ENABLED</code></td></tr><tr><td><a href="#indexglobalenabled">index.global.enabled</a></td><td>true</td><td>Whether to update index for the old partition path if same key record with different partition path came in, default true<br> <code>Config Param: INDEX_GLOBAL_ENABLED</code></td></tr><tr><td><a href="#indexpartitionregex">index.partition.regex</a></td><td>.*</td><td>Whether to load partitions in state if partition path matching， default <code>*</code><br> <code>Config Param: INDEX_PARTITION_REGEX</code></td></tr><tr><td><a href="#indexstatettl">index.state.ttl</a></td><td>0.0</td><td>Index state ttl in days, default stores the index permanently<br> <code>Config Param: INDEX_STATE_TTL</code></td></tr><tr><td><a href="#partitiondefault_name">partition.default_name</a></td><td><strong>HIVE_DEFAULT_PARTITION</strong></td><td>The default partition name in case the dynamic partition column value is null/empty string<br> <code>Config Param: PARTITION_DEFAULT_NAME</code></td></tr><tr><td><a href="#payloadclass">payload.class</a></td><td>org.apache.hudi.common.model.EventTimeAvroPayload</td><td>Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for the option in-effective<br> <code>Config Param: PAYLOAD_CLASS_NAME</code></td></tr><tr><td><a href="#readdataskippingenabled">read.data.skipping.enabled</a></td><td>false</td><td>Enables data-skipping allowing queries to leverage indexes to reduce the search space byskipping over files<br> <code>Config Param: READ_DATA_SKIPPING_ENABLED</code></td></tr><tr><td><a href="#readstreamingcheck-interval">read.streaming.check-interval</a></td><td>60</td><td>Check interval for streaming read of SECOND, default 1 minute<br> <code>Config Param: READ_STREAMING_CHECK_INTERVAL</code></td></tr><tr><td><a href="#readstreamingskip_clustering">read.streaming.skip_clustering</a></td><td>false</td><td>Whether to skip clustering instants to avoid reading base files of clustering operations for streaming read to improve read performance.<br> <code>Config Param: READ_STREAMING_SKIP_CLUSTERING</code></td></tr><tr><td><a href="#readstreamingskip_compaction">read.streaming.skip_compaction</a></td><td>false</td><td>Whether to skip compaction instants and avoid reading compacted base files for streaming read to improve read performance. This option can be used to avoid reading duplicates when changelog mode is enabled, it is a solution to keep data integrity <br> <code>Config Param: READ_STREAMING_SKIP_COMPACT</code></td></tr><tr><td><a href="#readutc-timezone">read.utc-timezone</a></td><td>true</td><td>Use UTC timezone or local timezone to the conversion between epoch time and LocalDateTime. Hive 0.x/1.x/2.x use local timezone. But Hive 3.x use UTC timezone, by default true<br> <code>Config Param: UTC_TIMEZONE</code></td></tr><tr><td><a href="#recordmergerimpls">record.merger.impls</a></td><td>org.apache.hudi.common.model.HoodieAvroRecordMerger</td><td>List of HoodieMerger implementations constituting Hudi&#x27;s merging strategy -- based on the engine used. These merger impls will filter by record.merger.strategy. Hudi will pick most efficient implementation to perform merging/combining of the records (during update, reading MOR table, etc)<br> <code>Config Param: RECORD_MERGER_IMPLS</code></td></tr><tr><td><a href="#recordmergerstrategy">record.merger.strategy</a></td><td>eeb8d96f-b1e4-49fd-bbf8-28ac514178e5</td><td>Id of merger strategy. Hudi will pick HoodieRecordMerger implementations in record.merger.impls which has the same merger strategy id<br> <code>Config Param: RECORD_MERGER_STRATEGY</code></td></tr><tr><td><a href="#writebatchsize">write.batch.size</a></td><td>256.0</td><td>Batch buffer size in MB to flush data into the underneath filesystem, default 256MB<br> <code>Config Param: WRITE_BATCH_SIZE</code></td></tr><tr><td><a href="#writebulk_insertshuffle_input">write.bulk_insert.shuffle_input</a></td><td>true</td><td>Whether to shuffle the inputs by specific fields for bulk insert tasks, default true<br> <code>Config Param: WRITE_BULK_INSERT_SHUFFLE_INPUT</code></td></tr><tr><td><a href="#writebulk_insertsort_input">write.bulk_insert.sort_input</a></td><td>true</td><td>Whether to sort the inputs by specific fields for bulk insert tasks, default true<br> <code>Config Param: WRITE_BULK_INSERT_SORT_INPUT</code></td></tr><tr><td><a href="#writebulk_insertsort_inputby_record_key">write.bulk_insert.sort_input.by_record_key</a></td><td>false</td><td>Whether to sort the inputs by record keys for bulk insert tasks, default false<br> <code>Config Param: WRITE_BULK_INSERT_SORT_INPUT_BY_RECORD_KEY</code></td></tr><tr><td><a href="#writeclientid">write.client.id</a></td><td></td><td>Unique identifier used to distinguish different writer pipelines for concurrent mode<br> <code>Config Param: WRITE_CLIENT_ID</code></td></tr><tr><td><a href="#writecommitacktimeout">write.commit.ack.timeout</a></td><td>-1</td><td>Timeout limit for a writer task after it finishes a checkpoint and waits for the instant commit success, only for internal use<br> <code>Config Param: WRITE_COMMIT_ACK_TIMEOUT</code></td></tr><tr><td><a href="#writeignorefailed">write.ignore.failed</a></td><td>false</td><td>Flag to indicate whether to ignore any non exception error (e.g. writestatus error). within a checkpoint batch.  By default false. Turning this on, could hide the write status errors while the flink checkpoint moves ahead.  So, would recommend users to use this with caution.<br> <code>Config Param: IGNORE_FAILED</code></td></tr><tr><td><a href="#writeinsertcluster">write.insert.cluster</a></td><td>false</td><td>Whether to merge small files for insert mode, if true, the write throughput will decrease because the read/write of existing small file, only valid for COW table, default false<br> <code>Config Param: INSERT_CLUSTER</code></td></tr><tr><td><a href="#writelogmaxsize">write.log.max.size</a></td><td>1024</td><td>Maximum size allowed in MB for a log file before it is rolled over to the next version, default 1GB<br> <code>Config Param: WRITE_LOG_MAX_SIZE</code></td></tr><tr><td><a href="#writelog_blocksize">write.log_block.size</a></td><td>128</td><td>Max log block size in MB for log file, default 128MB<br> <code>Config Param: WRITE_LOG_BLOCK_SIZE</code></td></tr><tr><td><a href="#writemergemax_memory">write.merge.max_memory</a></td><td>100</td><td>Max memory in MB for merge, default 100MB<br> <code>Config Param: WRITE_MERGE_MAX_MEMORY</code></td></tr><tr><td><a href="#writeparquetblocksize">write.parquet.block.size</a></td><td>120</td><td>Parquet RowGroup size. It&#x27;s recommended to make this large enough that scan costs can be amortized by packing enough column values into a single row group.<br> <code>Config Param: WRITE_PARQUET_BLOCK_SIZE</code></td></tr><tr><td><a href="#writeparquetpagesize">write.parquet.page.size</a></td><td>1</td><td>Parquet page size. Page is the unit of read within a parquet file. Within a block, pages are compressed separately.<br> <code>Config Param: WRITE_PARQUET_PAGE_SIZE</code></td></tr><tr><td><a href="#writepartitionoverwritemode">write.partition.overwrite.mode</a></td><td>STATIC</td><td>When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. Static mode deletes all the partitions that match the partition specification(e.g. PARTITION(a=1,b)) in the INSERT statement, before overwriting. Dynamic mode doesn&#x27;t delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of previous version.<br> <code>Config Param: WRITE_PARTITION_OVERWRITE_MODE</code></td></tr><tr><td><a href="#writeprecombine">write.precombine</a></td><td>false</td><td>Flag to indicate whether to drop duplicates before insert/upsert. By default these cases will accept duplicates, to gain extra performance: 1) insert operation; 2) upsert for MOR table, the MOR table deduplicate on reading<br> <code>Config Param: PRE_COMBINE</code></td></tr><tr><td><a href="#writeratelimit">write.rate.limit</a></td><td>0</td><td>Write record rate limit per second to prevent traffic jitter and improve stability, default 0 (no limit)<br> <code>Config Param: WRITE_RATE_LIMIT</code></td></tr><tr><td><a href="#writeretryintervalms">write.retry.interval.ms</a></td><td>2000</td><td>Flag to indicate how long (by millisecond) before a retry should issued for failed checkpoint batch. By default 2000 and it will be doubled by every retry<br> <code>Config Param: RETRY_INTERVAL_MS</code></td></tr><tr><td><a href="#writeretrytimes">write.retry.times</a></td><td>3</td><td>Flag to indicate how many times streaming job should retry for a failed checkpoint batch. By default 3<br> <code>Config Param: RETRY_TIMES</code></td></tr><tr><td><a href="#writesortmemory">write.sort.memory</a></td><td>128</td><td>Sort memory in MB, default 128MB<br> <code>Config Param: WRITE_SORT_MEMORY</code></td></tr><tr><td><a href="#writetaskmaxsize">write.task.max.size</a></td><td>1024.0</td><td>Maximum memory in MB for a write task, when the threshold hits, it flushes the max size data bucket to avoid OOM, default 1GB<br> <code>Config Param: WRITE_TASK_MAX_SIZE</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="WRITE_CLIENT">Write Client Configs<a class="hash-link" href="#WRITE_CLIENT" title="Direct link to heading">​</a></h2><p>Internally, the Hudi datasource uses a RDD based HoodieWriteClient API to actually perform writes to storage. These configs provide deep control over lower level aspects like file sizing, compression, parallelism, compaction, write schema, cleaning etc. Although Hudi provides sane defaults, from time-time these configs may need to be tweaked to optimize for specific workloads.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Common-Configurations">Common Configurations<a class="hash-link" href="#Common-Configurations" title="Direct link to heading">​</a></h3><p>The following set of configurations are common across Hudi.</p><p><a href="#Common-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#asofinstant">as.of.instant</a></td><td>(N/A)</td><td>The query instant for time travel. Without specified this option, we query the latest snapshot.<br><code>Config Param: TIMESTAMP_AS_OF</code></td></tr><tr><td><a href="#hoodiecommondiskmapcompressionenabled">hoodie.common.diskmap.compression.enabled</a></td><td>true</td><td>Turn on compression for BITCASK disk map used by the External Spillable Map<br><code>Config Param: DISK_MAP_BITCASK_COMPRESSION_ENABLED</code></td></tr><tr><td><a href="#hoodiecommonspillablediskmaptype">hoodie.common.spillable.diskmap.type</a></td><td>BITCASK</td><td>When handling input data that cannot be held in memory, to merge with a file on storage, a spillable diskmap is employed.  By default, we use a persistent hashmap based loosely on bitcask, that offers O(1) inserts, lookups. Change this to <code>ROCKS_DB</code> to prefer using rocksDB, for handling the spill.<br><code>Config Param: SPILLABLE_DISK_MAP_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewritenewcolumnsnullable">hoodie.datasource.write.new.columns.nullable</a></td><td>false</td><td>When a non-nullable column is added to datasource during a write operation, the write  operation will fail schema compatibility check. Set this option to true will make the newly added  column nullable to successfully complete the write operation.<br><code>Config Param: MAKE_NEW_COLUMNS_NULLABLE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcewritereconcileschema">hoodie.datasource.write.reconcile.schema</a></td><td>false</td><td>This config controls how writer&#x27;s schema will be selected based on the incoming batch&#x27;s schema as well as existing table&#x27;s one. When schema reconciliation is DISABLED, incoming batch&#x27;s schema will be picked as a writer-schema (therefore updating table&#x27;s schema). When schema reconciliation is ENABLED, writer-schema will be picked such that table&#x27;s schema (after txn) is either kept the same or extended, meaning that we&#x27;ll always prefer the schema that either adds new columns or stays the same. This enables us, to always extend the table&#x27;s schema during evolution and never lose the data (when, for ex, existing column is being dropped in a new batch)<br><code>Config Param: RECONCILE_SCHEMA</code></td></tr><tr><td><a href="#hoodiefsatomic_creationsupport">hoodie.fs.atomic_creation.support</a></td><td></td><td>This config is used to specify the file system which supports atomic file creation . atomic means that an operation either succeeds and has an effect or has fails and has no effect; now this feature is used by FileSystemLockProvider to guaranteeing that only one writer can create the lock file at a time. since some FS does not support atomic file creation (eg: S3), we decide the FileSystemLockProvider only support HDFS,local FS and View FS as default. if you want to use FileSystemLockProvider with other FS, you can set this config with the FS scheme, eg: fs1,fs2<br><code>Config Param: HOODIE_FS_ATOMIC_CREATION_SUPPORT</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiereadtimelineholesresolutionpolicy">hoodie.read.timeline.holes.resolution.policy</a></td><td>FAIL</td><td>When doing incremental queries, there could be hollow commits (requested or inflight commits that are not the latest) that are produced by concurrent writers and could lead to potential data loss. This config allows users to have different ways of handling this situation. The valid values are <!-- -->[FAIL, BLOCK, USE_TRANSITION_TIME]<!-- -->: Use <code>FAIL</code> to throw an exception when hollow commit is detected. This is helpful when hollow commits are not expected. Use <code>BLOCK</code> to block processing commits from going beyond the hollow ones. This fits the case where waiting for hollow commits to finish is acceptable. Use <code>USE_TRANSITION_TIME</code> (experimental) to query commits in range by state transition time (completion time), instead of commit time (start time). Using this mode will result in <code>begin.instanttime</code> and <code>end.instanttime</code> using <code>stateTransitionTime</code>  instead of the instant&#x27;s commit time.<br><code>Config Param: INCREMENTAL_READ_HANDLE_HOLLOW_COMMIT</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodieschemaonreadenable">hoodie.schema.on.read.enable</a></td><td>false</td><td>Enables support for Schema Evolution feature<br><code>Config Param: SCHEMA_EVOLUTION_ENABLE</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metadata-Configs">Metadata Configs<a class="hash-link" href="#Metadata-Configs" title="Direct link to heading">​</a></h3><p>Configurations used by the Hudi Metadata Table. This table maintains the metadata about a given Hudi table (e.g file listings)  to avoid overhead of accessing cloud storage, during queries.</p><p><a href="#Metadata-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetadataenable">hoodie.metadata.enable</a></td><td>true</td><td>Enable the internal metadata table which serves table metadata like level file listings<br><code>Config Param: ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetadataindexbloomfilterenable">hoodie.metadata.index.bloom.filter.enable</a></td><td>false</td><td>Enable indexing bloom filters of user data files under metadata table. When enabled, metadata table will have a partition to store the bloom filter index and will be used during the index lookups.<br><code>Config Param: ENABLE_METADATA_INDEX_BLOOM_FILTER</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatsenable">hoodie.metadata.index.column.stats.enable</a></td><td>false</td><td>Enable indexing column ranges of user data files under metadata table key lookups. When enabled, metadata table will have a partition to store the column ranges and will be used for pruning files during the index lookups.<br><code>Config Param: ENABLE_METADATA_INDEX_COLUMN_STATS</code><br><code>Since Version: 0.11.0</code></td></tr></tbody></table><p><a href="#Metadata-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetadataindexbloomfiltercolumnlist">hoodie.metadata.index.bloom.filter.column.list</a></td><td>(N/A)</td><td>Comma-separated list of columns for which bloom filter index will be built. If not set, only record key will be indexed.<br><code>Config Param: BLOOM_FILTER_INDEX_FOR_COLUMNS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatscolumnlist">hoodie.metadata.index.column.stats.column.list</a></td><td>(N/A)</td><td>Comma-separated list of columns for which column stats index will be built. If not set, all columns will be indexed<br><code>Config Param: COLUMN_STATS_INDEX_FOR_COLUMNS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatsprocessingmodeoverride">hoodie.metadata.index.column.stats.processing.mode.override</a></td><td>(N/A)</td><td>By default Column Stats Index is automatically determining whether it should be read and processed either&#x27;in-memory&#x27; (w/in executing process) or using Spark (on a cluster), based on some factors like the size of the Index and how many columns are read. This config allows to override this behavior.<br><code>Config Param: COLUMN_STATS_INDEX_PROCESSING_MODE_OVERRIDE</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#_hoodiemetadataignorespuriousdeletes">_hoodie.metadata.ignore.spurious.deletes</a></td><td>true</td><td>There are cases when extra files are requested to be deleted from metadata table which are never added before. This config determines how to handle such spurious deletes<br><code>Config Param: IGNORE_SPURIOUS_DELETES</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodieassumedatepartitioning">hoodie.assume.date.partitioning</a></td><td>false</td><td>Should HoodieWriteClient assume the data is partitioned by dates, i.e three levels from base path. This is a stop-gap to support tables created by versions <!-- -->&lt;<!-- --> 0.3.1. Will be removed eventually<br><code>Config Param: ASSUME_DATE_PARTITIONING</code><br><code>Since Version: 0.3.0</code></td></tr><tr><td><a href="#hoodiefilelistingparallelism">hoodie.file.listing.parallelism</a></td><td>200</td><td>Parallelism to use, when listing the table on lake storage.<br><code>Config Param: FILE_LISTING_PARALLELISM_VALUE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetadataautoinitialize">hoodie.metadata.auto.initialize</a></td><td>true</td><td>Initializes the metadata table by reading from the file system when the table is first created. Enabled by default. Warning: This should only be disabled when manually constructing the metadata table outside of typical Hudi writer flows.<br><code>Config Param: AUTO_INITIALIZE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatacompactmaxdeltacommits">hoodie.metadata.compact.max.delta.commits</a></td><td>10</td><td>Controls how often the metadata table is compacted.<br><code>Config Param: COMPACT_NUM_DELTA_COMMITS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetadatadirfilterregex">hoodie.metadata.dir.filter.regex</a></td><td></td><td>Directories matching this regex, will be filtered out when initializing metadata table from lake storage for the first time.<br><code>Config Param: DIR_FILTER_REGEX</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetadataindexasync">hoodie.metadata.index.async</a></td><td>false</td><td>Enable asynchronous indexing of metadata table.<br><code>Config Param: ASYNC_INDEX_ENABLE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexbloomfilterfilegroupcount">hoodie.metadata.index.bloom.filter.file.group.count</a></td><td>4</td><td>Metadata bloom filter index partition file group count. This controls the size of the base and log files and read parallelism in the bloom filter index partition. The recommendation is to size the file group count such that the base files are under 1GB.<br><code>Config Param: METADATA_INDEX_BLOOM_FILTER_FILE_GROUP_COUNT</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexbloomfilterparallelism">hoodie.metadata.index.bloom.filter.parallelism</a></td><td>200</td><td>Parallelism to use for generating bloom filter index in metadata table.<br><code>Config Param: BLOOM_FILTER_INDEX_PARALLELISM</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexchecktimeoutseconds">hoodie.metadata.index.check.timeout.seconds</a></td><td>900</td><td>After the async indexer has finished indexing upto the base instant, it will ensure that all inflight writers reliably write index updates as well. If this timeout expires, then the indexer will abort itself safely.<br><code>Config Param: METADATA_INDEX_CHECK_TIMEOUT_SECONDS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatsfilegroupcount">hoodie.metadata.index.column.stats.file.group.count</a></td><td>2</td><td>Metadata column stats partition file group count. This controls the size of the base and log files and read parallelism in the column stats index partition. The recommendation is to size the file group count such that the base files are under 1GB.<br><code>Config Param: METADATA_INDEX_COLUMN_STATS_FILE_GROUP_COUNT</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatsinMemoryprojectionthreshold">hoodie.metadata.index.column.stats.inMemory.projection.threshold</a></td><td>100000</td><td>When reading Column Stats Index, if the size of the expected resulting projection is below the in-memory threshold (counted by the # of rows), it will be attempted to be loaded &quot;in-memory&quot; (ie not using the execution engine like Spark, Flink, etc). If the value is above the threshold execution engine will be used to compose the projection.<br><code>Config Param: COLUMN_STATS_INDEX_IN_MEMORY_PROJECTION_THRESHOLD</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#hoodiemetadataindexcolumnstatsparallelism">hoodie.metadata.index.column.stats.parallelism</a></td><td>200</td><td>Parallelism to use, when generating column stats index.<br><code>Config Param: COLUMN_STATS_INDEX_PARALLELISM</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiemetadatalogcompactionblocksthreshold">hoodie.metadata.log.compaction.blocks.threshold</a></td><td>5</td><td>Controls the criteria to log compacted files groups in metadata table.<br><code>Config Param: LOG_COMPACT_BLOCKS_THRESHOLD</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatalogcompactionenable">hoodie.metadata.log.compaction.enable</a></td><td>false</td><td>This configs enables logcompaction for the metadata table.<br><code>Config Param: ENABLE_LOG_COMPACTION_ON_METADATA_TABLE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatamaxdeltacommitswhen_pending">hoodie.metadata.max.deltacommits.when_pending</a></td><td>1000</td><td>When there is a pending instant in data table, this config limits the allowed number of deltacommits in metadata table to prevent the metadata table&#x27;s timeline from growing unboundedly as compaction won&#x27;t be triggered due to the pending data table instant.<br><code>Config Param: METADATA_MAX_NUM_DELTACOMMITS_WHEN_PENDING</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatamaxinitparallelism">hoodie.metadata.max.init.parallelism</a></td><td>100000</td><td>Maximum parallelism to use when initializing Record Index.<br><code>Config Param: RECORD_INDEX_MAX_PARALLELISM</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatamaxlogfilesize">hoodie.metadata.max.logfile.size</a></td><td>2147483648</td><td>Maximum size in bytes of a single log file. Larger log files can contain larger log blocks thereby reducing the number of blocks to search for keys<br><code>Config Param: MAX_LOG_FILE_SIZE_BYTES_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatamaxreaderbuffersize">hoodie.metadata.max.reader.buffer.size</a></td><td>10485760</td><td>Max memory to use for the reader buffer while merging log blocks<br><code>Config Param: MAX_READER_BUFFER_SIZE_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatamaxreadermemory">hoodie.metadata.max.reader.memory</a></td><td>1073741824</td><td>Max memory to use for the reader to read from metadata<br><code>Config Param: MAX_READER_MEMORY_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatametricsenable">hoodie.metadata.metrics.enable</a></td><td>false</td><td>Enable publishing of metrics around metadata table.<br><code>Config Param: METRICS_ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetadataoptimizedlogblocksscanenable">hoodie.metadata.optimized.log.blocks.scan.enable</a></td><td>false</td><td>Optimized log blocks scanner that addresses all the multi-writer use-cases while appending to log files. It also differentiates original blocks written by ingestion writers and compacted blocks written by log compaction.<br><code>Config Param: ENABLE_OPTIMIZED_LOG_BLOCKS_SCAN</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetadatarecordindexenable">hoodie.metadata.record.index.enable</a></td><td>false</td><td>Create the HUDI Record Index within the Metadata Table<br><code>Config Param: RECORD_INDEX_ENABLE_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatarecordindexgrowthfactor">hoodie.metadata.record.index.growth.factor</a></td><td>2.0</td><td>The current number of records are multiplied by this number when estimating the number of file groups to create automatically. This helps account for growth in the number of records in the dataset.<br><code>Config Param: RECORD_INDEX_GROWTH_FACTOR_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatarecordindexmaxfilegroupcount">hoodie.metadata.record.index.max.filegroup.count</a></td><td>10000</td><td>Maximum number of file groups to use for Record Index.<br><code>Config Param: RECORD_INDEX_MAX_FILE_GROUP_COUNT_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatarecordindexmaxfilegroupsize">hoodie.metadata.record.index.max.filegroup.size</a></td><td>1073741824</td><td>Maximum size in bytes of a single file group. Large file group takes longer to compact.<br><code>Config Param: RECORD_INDEX_MAX_FILE_GROUP_SIZE_BYTES_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadatarecordindexminfilegroupcount">hoodie.metadata.record.index.min.filegroup.count</a></td><td>10</td><td>Minimum number of file groups to use for Record Index.<br><code>Config Param: RECORD_INDEX_MIN_FILE_GROUP_COUNT_PROP</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetadataspillablemappath">hoodie.metadata.spillable.map.path</a></td><td></td><td>Path on local storage to use, when keys read from metadata are held in a spillable map.<br><code>Config Param: SPILLABLE_MAP_DIR_PROP</code><br><code>Since Version: 0.14.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metaserver-Configs">Metaserver Configs<a class="hash-link" href="#Metaserver-Configs" title="Direct link to heading">​</a></h3><p>Configurations used by the Hudi Metaserver.</p><p><a href="#Metaserver-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatabasename">hoodie.database.name</a></td><td>(N/A)</td><td>Database name that will be used for incremental query.If different databases have the same table name during incremental query, we can set it to limit the table name under a specific database<br><code>Config Param: DATABASE_NAME</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodietablename">hoodie.table.name</a></td><td>(N/A)</td><td>Table name that will be used for registering with Hive. Needs to be same across runs.<br><code>Config Param: TABLE_NAME</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetaserverconnectretries">hoodie.metaserver.connect.retries</a></td><td>3</td><td>Number of retries while opening a connection to metaserver<br><code>Config Param: METASERVER_CONNECTION_RETRIES</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetaserverconnectretrydelay">hoodie.metaserver.connect.retry.delay</a></td><td>1</td><td>Number of seconds for the client to wait between consecutive connection attempts<br><code>Config Param: METASERVER_CONNECTION_RETRY_DELAY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetaserverenabled">hoodie.metaserver.enabled</a></td><td>false</td><td>Enable Hudi metaserver for storing Hudi tables&#x27; metadata.<br><code>Config Param: METASERVER_ENABLE</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetaserveruris">hoodie.metaserver.uris</a></td><td>thrift://localhost:9090</td><td>Metaserver server uris<br><code>Config Param: METASERVER_URLS</code><br><code>Since Version: 0.13.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Storage-Configs">Storage Configs<a class="hash-link" href="#Storage-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control aspects around writing, sizing, reading base and log files.</p><p><a href="#Storage-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieparquetcompressioncodec">hoodie.parquet.compression.codec</a></td><td>gzip</td><td>Compression Codec for parquet files<br><code>Config Param: PARQUET_COMPRESSION_CODEC_NAME</code></td></tr><tr><td><a href="#hoodieparquetmaxfilesize">hoodie.parquet.max.file.size</a></td><td>125829120</td><td>Target size in bytes for parquet files produced by Hudi write phases. For DFS, this needs to be aligned with the underlying filesystem block size for optimal performance.<br><code>Config Param: PARQUET_MAX_FILE_SIZE</code></td></tr></tbody></table><p><a href="#Storage-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodielogfiledatablockformat">hoodie.logfile.data.block.format</a></td><td>(N/A)</td><td>Format of the data block within delta logs. Following formats are currently supported &quot;avro&quot;, &quot;hfile&quot;, &quot;parquet&quot;<br><code>Config Param: LOGFILE_DATA_BLOCK_FORMAT</code></td></tr><tr><td><a href="#hoodieavrowritesupportclass">hoodie.avro.write.support.class</a></td><td>org.apache.hudi.avro.HoodieAvroWriteSupport</td><td>Provided write support class should extend HoodieAvroWriteSupport class and it is loaded at runtime. This is only required when trying to override the existing write context.<br><code>Config Param: HOODIE_AVRO_WRITE_SUPPORT_CLASS</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiebloomindexfilterdynamicmaxentries">hoodie.bloom.index.filter.dynamic.max.entries</a></td><td>100000</td><td>The threshold for the maximum number of keys to record in a dynamic Bloom filter row. Only applies if filter type is BloomFilterTypeCode.DYNAMIC_V0.<br><code>Config Param: BLOOM_FILTER_DYNAMIC_MAX_ENTRIES</code></td></tr><tr><td><a href="#hoodiebloomindexfiltertype">hoodie.bloom.index.filter.type</a></td><td>DYNAMIC_V0</td><td>org.apache.hudi.common.bloom.BloomFilterTypeCode: Filter type used by Bloom filter.     SIMPLE: Bloom filter that is based on the configured size.     DYNAMIC_V0(default): Bloom filter that is auto sized based on number of keys.<br><code>Config Param: BLOOM_FILTER_TYPE</code></td></tr><tr><td><a href="#hoodiehfileblocksize">hoodie.hfile.block.size</a></td><td>1048576</td><td>Lower values increase the size in bytes of metadata tracked within HFile, but can offer potentially faster lookup times.<br><code>Config Param: HFILE_BLOCK_SIZE</code></td></tr><tr><td><a href="#hoodiehfilecompressionalgorithm">hoodie.hfile.compression.algorithm</a></td><td>GZ</td><td>Compression codec to use for hfile base files.<br><code>Config Param: HFILE_COMPRESSION_ALGORITHM_NAME</code></td></tr><tr><td><a href="#hoodiehfilemaxfilesize">hoodie.hfile.max.file.size</a></td><td>125829120</td><td>Target file size in bytes for HFile base files.<br><code>Config Param: HFILE_MAX_FILE_SIZE</code></td></tr><tr><td><a href="#hoodieindexbloomfpp">hoodie.index.bloom.fpp</a></td><td>0.000000001</td><td>Only applies if index type is BLOOM. Error rate allowed given the number of entries. This is used to calculate how many bits should be assigned for the bloom filter and the number of hash functions. This is usually set very low (default: 0.000000001), we like to tradeoff disk space for lower false positives. If the number of entries added to bloom filter exceeds the configured value (hoodie.index.bloom.num_entries), then this fpp may not be honored.<br><code>Config Param: BLOOM_FILTER_FPP_VALUE</code></td></tr><tr><td><a href="#hoodieindexbloomnum_entries">hoodie.index.bloom.num_entries</a></td><td>60000</td><td>Only applies if index type is BLOOM. This is the number of entries to be stored in the bloom filter. The rationale for the default: Assume the maxParquetFileSize is 128MB and averageRecordSize is 1kb and hence we approx a total of 130K records in a file. The default (60000) is roughly half of this approximation. Warning: Setting this very low, will generate a lot of false positives and index lookup will have to scan a lot more files than it has to and setting this to a very high number will increase the size every base file linearly (roughly 4KB for every 50000 entries). This config is also used with DYNAMIC bloom filter which determines the initial size for the bloom.<br><code>Config Param: BLOOM_FILTER_NUM_ENTRIES_VALUE</code></td></tr><tr><td><a href="#hoodielogfiledatablockmaxsize">hoodie.logfile.data.block.max.size</a></td><td>268435456</td><td>LogFile Data block max size in bytes. This is the maximum size allowed for a single data block to be appended to a log file. This helps to make sure the data appended to the log file is broken up into sizable blocks to prevent from OOM errors. This size should be greater than the JVM memory.<br><code>Config Param: LOGFILE_DATA_BLOCK_MAX_SIZE</code></td></tr><tr><td><a href="#hoodielogfilemaxsize">hoodie.logfile.max.size</a></td><td>1073741824</td><td>LogFile max size in bytes. This is the maximum size allowed for a log file before it is rolled over to the next version.<br><code>Config Param: LOGFILE_MAX_SIZE</code></td></tr><tr><td><a href="#hoodielogfiletoparquetcompressionratio">hoodie.logfile.to.parquet.compression.ratio</a></td><td>0.35</td><td>Expected additional compression as records move from log files to parquet. Used for merge_on_read table to send inserts into log files <!-- -->&amp;<!-- --> control the size of compacted parquet file.<br><code>Config Param: LOGFILE_TO_PARQUET_COMPRESSION_RATIO_FRACTION</code></td></tr><tr><td><a href="#hoodieorcblocksize">hoodie.orc.block.size</a></td><td>125829120</td><td>ORC block size, recommended to be aligned with the target file size.<br><code>Config Param: ORC_BLOCK_SIZE</code></td></tr><tr><td><a href="#hoodieorccompressioncodec">hoodie.orc.compression.codec</a></td><td>ZLIB</td><td>Compression codec to use for ORC base files.<br><code>Config Param: ORC_COMPRESSION_CODEC_NAME</code></td></tr><tr><td><a href="#hoodieorcmaxfilesize">hoodie.orc.max.file.size</a></td><td>125829120</td><td>Target file size in bytes for ORC base files.<br><code>Config Param: ORC_FILE_MAX_SIZE</code></td></tr><tr><td><a href="#hoodieorcstripesize">hoodie.orc.stripe.size</a></td><td>67108864</td><td>Size of the memory buffer in bytes for writing<br><code>Config Param: ORC_STRIPE_SIZE</code></td></tr><tr><td><a href="#hoodieparquetblocksize">hoodie.parquet.block.size</a></td><td>125829120</td><td>Parquet RowGroup size in bytes. It&#x27;s recommended to make this large enough that scan costs can be amortized by packing enough column values into a single row group.<br><code>Config Param: PARQUET_BLOCK_SIZE</code></td></tr><tr><td><a href="#hoodieparquetcompressionratio">hoodie.parquet.compression.ratio</a></td><td>0.1</td><td>Expected compression of parquet data used by Hudi, when it tries to size new parquet files. Increase this value, if bulk_insert is producing smaller than expected sized files<br><code>Config Param: PARQUET_COMPRESSION_RATIO_FRACTION</code></td></tr><tr><td><a href="#hoodieparquetdictionaryenabled">hoodie.parquet.dictionary.enabled</a></td><td>true</td><td>Whether to use dictionary encoding<br><code>Config Param: PARQUET_DICTIONARY_ENABLED</code></td></tr><tr><td><a href="#hoodieparquetfield_idwriteenabled">hoodie.parquet.field_id.write.enabled</a></td><td>true</td><td>Would only be effective with Spark 3.3+. Sets spark.sql.parquet.fieldId.write.enabled. If enabled, Spark will write out parquet native field ids that are stored inside StructField&#x27;s metadata as parquet.field.id to parquet files.<br><code>Config Param: PARQUET_FIELD_ID_WRITE_ENABLED</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#hoodieparquetoutputtimestamptype">hoodie.parquet.outputtimestamptype</a></td><td>TIMESTAMP_MICROS</td><td>Sets spark.sql.parquet.outputTimestampType. Parquet timestamp type to use when Spark writes data to Parquet files.<br><code>Config Param: PARQUET_OUTPUT_TIMESTAMP_TYPE</code></td></tr><tr><td><a href="#hoodieparquetpagesize">hoodie.parquet.page.size</a></td><td>1048576</td><td>Parquet page size in bytes. Page is the unit of read within a parquet file. Within a block, pages are compressed separately.<br><code>Config Param: PARQUET_PAGE_SIZE</code></td></tr><tr><td><a href="#hoodieparquetwritelegacyformatenabled">hoodie.parquet.writelegacyformat.enabled</a></td><td>false</td><td>Sets spark.sql.parquet.writeLegacyFormat. If true, data will be written in a way of Spark 1.4 and earlier. For example, decimal values will be written in Parquet&#x27;s fixed-length byte array format which other systems such as Apache Hive and Apache Impala use. If false, the newer format in Parquet will be used. For example, decimals will be written in int-based format.<br><code>Config Param: PARQUET_WRITE_LEGACY_FORMAT_ENABLED</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Consistency-Guard-Configurations">Consistency Guard Configurations<a class="hash-link" href="#Consistency-Guard-Configurations" title="Direct link to heading">​</a></h3><p>The consistency guard related config options, to help talk to eventually consistent object storage.(Tip: S3 is NOT eventually consistent anymore!)</p><p><a href="#Consistency-Guard-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#_hoodieoptimisticconsistencyguardenable">_hoodie.optimistic.consistency.guard.enable</a></td><td>false</td><td>Enable consistency guard, which optimistically assumes consistency is achieved after a certain time period.<br><code>Config Param: OPTIMISTIC_CONSISTENCY_GUARD_ENABLE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodieconsistencycheckenabled">hoodie.consistency.check.enabled</a></td><td>false</td><td>Enabled to handle S3 eventual consistency issue. This property is no longer required since S3 is now strongly consistent. Will be removed in the future releases.<br><code>Config Param: ENABLE</code><br><code>Since Version: 0.5.0</code><br><code>Deprecated since: 0.7.0</code></td></tr><tr><td><a href="#hoodieconsistencycheckinitial_interval_ms">hoodie.consistency.check.initial_interval_ms</a></td><td>400</td><td>Amount of time (in ms) to wait, before checking for consistency after an operation on storage.<br><code>Config Param: INITIAL_CHECK_INTERVAL_MS</code><br><code>Since Version: 0.5.0</code><br><code>Deprecated since: 0.7.0</code></td></tr><tr><td><a href="#hoodieconsistencycheckmax_checks">hoodie.consistency.check.max_checks</a></td><td>6</td><td>Maximum number of consistency checks to perform, with exponential backoff.<br><code>Config Param: MAX_CHECKS</code><br><code>Since Version: 0.5.0</code><br><code>Deprecated since: 0.7.0</code></td></tr><tr><td><a href="#hoodieconsistencycheckmax_interval_ms">hoodie.consistency.check.max_interval_ms</a></td><td>20000</td><td>Maximum amount of time (in ms), to wait for consistency checking.<br><code>Config Param: MAX_CHECK_INTERVAL_MS</code><br><code>Since Version: 0.5.0</code><br><code>Deprecated since: 0.7.0</code></td></tr><tr><td><a href="#hoodieoptimisticconsistencyguardsleep_time_ms">hoodie.optimistic.consistency.guard.sleep_time_ms</a></td><td>500</td><td>Amount of time (in ms), to wait after which we assume storage is consistent.<br><code>Config Param: OPTIMISTIC_CONSISTENCY_GUARD_SLEEP_TIME_MS</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="FileSystem-Guard-Configurations">FileSystem Guard Configurations<a class="hash-link" href="#FileSystem-Guard-Configurations" title="Direct link to heading">​</a></h3><p>The filesystem retry related config options, to help deal with runtime exception like list/get/put/delete performance issues.</p><p><a href="#FileSystem-Guard-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiefilesystemoperationretryenable">hoodie.filesystem.operation.retry.enable</a></td><td>false</td><td>Enabled to handle list/get/delete etc file system performance issue.<br><code>Config Param: FILESYSTEM_RETRY_ENABLE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiefilesystemoperationretryexceptions">hoodie.filesystem.operation.retry.exceptions</a></td><td></td><td>The class name of the Exception that needs to be retried, separated by commas. Default is empty which means retry all the IOException and RuntimeException from FileSystem<br><code>Config Param: RETRY_EXCEPTIONS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiefilesystemoperationretryinitial_interval_ms">hoodie.filesystem.operation.retry.initial_interval_ms</a></td><td>100</td><td>Amount of time (in ms) to wait, before retry to do operations on storage.<br><code>Config Param: INITIAL_RETRY_INTERVAL_MS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiefilesystemoperationretrymax_interval_ms">hoodie.filesystem.operation.retry.max_interval_ms</a></td><td>2000</td><td>Maximum amount of time (in ms), to wait for next retry.<br><code>Config Param: MAX_RETRY_INTERVAL_MS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiefilesystemoperationretrymax_numbers">hoodie.filesystem.operation.retry.max_numbers</a></td><td>4</td><td>Maximum number of retry actions to perform, with exponential backoff.<br><code>Config Param: MAX_RETRY_NUMBERS</code><br><code>Since Version: 0.11.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="File-System-View-Storage-Configurations">File System View Storage Configurations<a class="hash-link" href="#File-System-View-Storage-Configurations" title="Direct link to heading">​</a></h3><p>Configurations that control how file metadata is stored by Hudi, for transaction processing and queries.</p><p><a href="#File-System-View-Storage-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiefilesystemremotebackupviewenable">hoodie.filesystem.remote.backup.view.enable</a></td><td>true</td><td>Config to control whether backup needs to be configured if clients were not able to reach timeline service.<br><code>Config Param: REMOTE_BACKUP_VIEW_ENABLE</code></td></tr><tr><td><a href="#hoodiefilesystemviewincrtimelinesyncenable">hoodie.filesystem.view.incr.timeline.sync.enable</a></td><td>false</td><td>Controls whether or not, the file system view is incrementally updated as new actions are performed on the timeline.<br><code>Config Param: INCREMENTAL_TIMELINE_SYNC_ENABLE</code></td></tr><tr><td><a href="#hoodiefilesystemviewremotehost">hoodie.filesystem.view.remote.host</a></td><td>localhost</td><td>We expect this to be rarely hand configured.<br><code>Config Param: REMOTE_HOST_NAME</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteport">hoodie.filesystem.view.remote.port</a></td><td>26754</td><td>Port to serve file system view queries, when remote. We expect this to be rarely hand configured.<br><code>Config Param: REMOTE_PORT_NUM</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteretryenable">hoodie.filesystem.view.remote.retry.enable</a></td><td>false</td><td>Whether to enable API request retry for remote file system view.<br><code>Config Param: REMOTE_RETRY_ENABLE</code><br><code>Since Version: 0.12.1</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteretryexceptions">hoodie.filesystem.view.remote.retry.exceptions</a></td><td></td><td>The class name of the Exception that needs to be retried, separated by commas. Default is empty which means retry all the IOException and RuntimeException from Remote Request.<br><code>Config Param: RETRY_EXCEPTIONS</code><br><code>Since Version: 0.12.1</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteretryinitial_interval_ms">hoodie.filesystem.view.remote.retry.initial_interval_ms</a></td><td>100</td><td>Amount of time (in ms) to wait, before retry to do operations on storage.<br><code>Config Param: REMOTE_INITIAL_RETRY_INTERVAL_MS</code><br><code>Since Version: 0.12.1</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteretrymax_interval_ms">hoodie.filesystem.view.remote.retry.max_interval_ms</a></td><td>2000</td><td>Maximum amount of time (in ms), to wait for next retry.<br><code>Config Param: REMOTE_MAX_RETRY_INTERVAL_MS</code><br><code>Since Version: 0.12.1</code></td></tr><tr><td><a href="#hoodiefilesystemviewremoteretrymax_numbers">hoodie.filesystem.view.remote.retry.max_numbers</a></td><td>3</td><td>Maximum number of retry for API requests against a remote file system view. e.g timeline server.<br><code>Config Param: REMOTE_MAX_RETRY_NUMBERS</code><br><code>Since Version: 0.12.1</code></td></tr><tr><td><a href="#hoodiefilesystemviewremotetimeoutsecs">hoodie.filesystem.view.remote.timeout.secs</a></td><td>300</td><td>Timeout in seconds, to wait for API requests against a remote file system view. e.g timeline server.<br><code>Config Param: REMOTE_TIMEOUT_SECS</code></td></tr><tr><td><a href="#hoodiefilesystemviewrocksdbbasepath">hoodie.filesystem.view.rocksdb.base.path</a></td><td>/tmp/hoodie_timeline_rocksdb</td><td>Path on local storage to use, when storing file system view in embedded kv store/rocksdb.<br><code>Config Param: ROCKSDB_BASE_PATH</code></td></tr><tr><td><a href="#hoodiefilesystemviewsecondarytype">hoodie.filesystem.view.secondary.type</a></td><td>MEMORY</td><td>Specifies the secondary form of storage for file system view, if the primary (e.g timeline server)  is unavailable.<br><code>Config Param: SECONDARY_VIEW_TYPE</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillablebootstrapbasefilememfraction">hoodie.filesystem.view.spillable.bootstrap.base.file.mem.fraction</a></td><td>0.05</td><td>Fraction of the file system view memory, to be used for holding mapping to bootstrap base files.<br><code>Config Param: BOOTSTRAP_BASE_FILE_MEM_FRACTION</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillableclusteringmemfraction">hoodie.filesystem.view.spillable.clustering.mem.fraction</a></td><td>0.01</td><td>Fraction of the file system view memory, to be used for holding clustering related metadata.<br><code>Config Param: SPILLABLE_CLUSTERING_MEM_FRACTION</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillablecompactionmemfraction">hoodie.filesystem.view.spillable.compaction.mem.fraction</a></td><td>0.8</td><td>Fraction of the file system view memory, to be used for holding compaction related metadata.<br><code>Config Param: SPILLABLE_COMPACTION_MEM_FRACTION</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillabledir">hoodie.filesystem.view.spillable.dir</a></td><td>/tmp/</td><td>Path on local storage to use, when file system view is held in a spillable map.<br><code>Config Param: SPILLABLE_DIR</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillablelogcompactionmemfraction">hoodie.filesystem.view.spillable.log.compaction.mem.fraction</a></td><td>0.8</td><td>Fraction of the file system view memory, to be used for holding log compaction related metadata.<br><code>Config Param: SPILLABLE_LOG_COMPACTION_MEM_FRACTION</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillablemem">hoodie.filesystem.view.spillable.mem</a></td><td>104857600</td><td>Amount of memory to be used in bytes for holding file system view, before spilling to disk.<br><code>Config Param: SPILLABLE_MEMORY</code></td></tr><tr><td><a href="#hoodiefilesystemviewspillablereplacedmemfraction">hoodie.filesystem.view.spillable.replaced.mem.fraction</a></td><td>0.01</td><td>Fraction of the file system view memory, to be used for holding replace commit related metadata.<br><code>Config Param: SPILLABLE_REPLACED_MEM_FRACTION</code></td></tr><tr><td><a href="#hoodiefilesystemviewtype">hoodie.filesystem.view.type</a></td><td>MEMORY</td><td>File system view provides APIs for viewing the files on the underlying lake storage,  as file groups and file slices. This config controls how such a view is held. Options include MEMORY,SPILLABLE_DISK,EMBEDDED_KV_STORE,REMOTE_ONLY,REMOTE_FIRST which provide different trade offs for memory usage and API request performance.<br><code>Config Param: VIEW_TYPE</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Archival-Configs">Archival Configs<a class="hash-link" href="#Archival-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control archival.</p><p><a href="#Archival-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiekeepmaxcommits">hoodie.keep.max.commits</a></td><td>30</td><td>Archiving service moves older entries from timeline into an archived log after each write, to keep the metadata overhead constant, even as the table size grows. This config controls the maximum number of instants to retain in the active timeline. <br><code>Config Param: MAX_COMMITS_TO_KEEP</code></td></tr><tr><td><a href="#hoodiekeepmincommits">hoodie.keep.min.commits</a></td><td>20</td><td>Similar to hoodie.keep.max.commits, but controls the minimum number of instants to retain in the active timeline.<br><code>Config Param: MIN_COMMITS_TO_KEEP</code></td></tr></tbody></table><p><a href="#Archival-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiearchiveasync">hoodie.archive.async</a></td><td>false</td><td>Only applies when hoodie.archive.automatic is turned on. When turned on runs archiver async with writing, which can speed up overall write performance.<br><code>Config Param: ASYNC_ARCHIVE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiearchiveautomatic">hoodie.archive.automatic</a></td><td>true</td><td>When enabled, the archival table service is invoked immediately after each commit, to archive commits if we cross a maximum value of commits. It&#x27;s recommended to enable this, to ensure number of active commits is bounded.<br><code>Config Param: AUTO_ARCHIVE</code></td></tr><tr><td><a href="#hoodiearchivebeyondsavepoint">hoodie.archive.beyond.savepoint</a></td><td>false</td><td>If enabled, archival will proceed beyond savepoint, skipping savepoint commits. If disabled, archival will stop at the earliest savepoint commit.<br><code>Config Param: ARCHIVE_BEYOND_SAVEPOINT</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#hoodiearchivedeleteparallelism">hoodie.archive.delete.parallelism</a></td><td>100</td><td>When performing archival operation, Hudi needs to delete the files of the archived instants in the active timeline in .hoodie folder. The file deletion also happens after merging small archived files into larger ones if enabled. This config limits the Spark parallelism for deleting files in both cases, i.e., parallelism of deleting files does not go above the configured value and the parallelism is the number of files to delete if smaller than the configured value.  If you see that the file deletion in archival operation is slow because of the limited parallelism, you can increase this to tune the performance.<br><code>Config Param: DELETE_ARCHIVED_INSTANT_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiearchivemergeenable">hoodie.archive.merge.enable</a></td><td>false</td><td>When enable, hoodie will auto merge several small archive files into larger one. It&#x27;s useful when storage scheme doesn&#x27;t support append operation.<br><code>Config Param: ARCHIVE_MERGE_ENABLE</code></td></tr><tr><td><a href="#hoodiearchivemergefilesbatchsize">hoodie.archive.merge.files.batch.size</a></td><td>10</td><td>The number of small archive files to be merged at once.<br><code>Config Param: ARCHIVE_MERGE_FILES_BATCH_SIZE</code></td></tr><tr><td><a href="#hoodiearchivemergesmallfilelimitbytes">hoodie.archive.merge.small.file.limit.bytes</a></td><td>20971520</td><td>This config sets the archive file size limit below which an archive file becomes a candidate to be selected as such a small file.<br><code>Config Param: ARCHIVE_MERGE_SMALL_FILE_LIMIT_BYTES</code></td></tr><tr><td><a href="#hoodiecommitsarchivalbatch">hoodie.commits.archival.batch</a></td><td>10</td><td>Archiving of instants is batched in best-effort manner, to pack more instants into a single archive log. This config controls such archival batch size.<br><code>Config Param: COMMITS_ARCHIVAL_BATCH_SIZE</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Bootstrap-Configs">Bootstrap Configs<a class="hash-link" href="#Bootstrap-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control how you want to bootstrap your existing tables for the first time into hudi. The bootstrap operation can flexibly avoid copying data over before you can use Hudi and support running the existing  writers and new hudi writers in parallel, to validate the migration.</p><p><a href="#Bootstrap-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiebootstrapbasepath">hoodie.bootstrap.base.path</a></td><td>(N/A)</td><td>Base path of the dataset that needs to be bootstrapped as a Hudi table<br><code>Config Param: BASE_PATH</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><p><a href="#Bootstrap-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiebootstrapdataqueriesonly">hoodie.bootstrap.data.queries.only</a></td><td>false</td><td>Improves query performance, but queries cannot use hudi metadata fields<br><code>Config Param: DATA_QUERIES_ONLY</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiebootstrapfullinputprovider">hoodie.bootstrap.full.input.provider</a></td><td>org.apache.hudi.bootstrap.SparkParquetBootstrapDataProvider</td><td>Class to use for reading the bootstrap dataset partitions/files, for Bootstrap mode FULL_RECORD<br><code>Config Param: FULL_BOOTSTRAP_INPUT_PROVIDER_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrapindexclass">hoodie.bootstrap.index.class</a></td><td>org.apache.hudi.common.bootstrap.index.HFileBootstrapIndex</td><td>Implementation to use, for mapping a skeleton base file to a bootstrap base file.<br><code>Config Param: INDEX_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrapmodeselector">hoodie.bootstrap.mode.selector</a></td><td>org.apache.hudi.client.bootstrap.selector.MetadataOnlyBootstrapModeSelector</td><td>Selects the mode in which each file/partition in the bootstrapped dataset gets bootstrapped<br><code>Config Param: MODE_SELECTOR_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrapmodeselectorregex">hoodie.bootstrap.mode.selector.regex</a></td><td>.*</td><td>Matches each bootstrap dataset partition against this regex and applies the mode below to it.<br><code>Config Param: PARTITION_SELECTOR_REGEX_PATTERN</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrapmodeselectorregexmode">hoodie.bootstrap.mode.selector.regex.mode</a></td><td>METADATA_ONLY</td><td>org.apache.hudi.client.bootstrap.BootstrapMode: Bootstrap mode for importing an existing table into Hudi     FULL_RECORD: In this mode, the full record data is copied into hudi and metadata columns are added. A full record bootstrap is functionally equivalent to a bulk-insert. After a full record bootstrap, Hudi will function properly even if the original table is modified or deleted.     METADATA_ONLY(default): In this mode, the full record data is not copied into Hudi therefore it avoids full cost of rewriting the dataset. Instead, &#x27;skeleton&#x27; files containing just the corresponding metadata columns are added to the Hudi table. Hudi relies on the data in the original table and will face data-loss or corruption if files in the original table location are deleted or modified.<br><code>Config Param: PARTITION_SELECTOR_REGEX_MODE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrapparallelism">hoodie.bootstrap.parallelism</a></td><td>1500</td><td>For metadata-only bootstrap, Hudi parallelizes the operation so that each table partition is handled by one Spark task. This config limits the number of parallelism. We pick the configured parallelism if the number of table partitions is larger than this configured value. The parallelism is assigned to the number of table partitions if it is smaller than the configured value. For full-record bootstrap, i.e., BULK_INSERT operation of the records, this configured value is passed as the BULK_INSERT shuffle parallelism (<code>hoodie.bulkinsert.shuffle.parallelism</code>), determining the BULK_INSERT write behavior. If you see that the bootstrap is slow due to the limited parallelism, you can increase this.<br><code>Config Param: PARALLELISM_VALUE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiebootstrappartitionpathtranslatorclass">hoodie.bootstrap.partitionpath.translator.class</a></td><td>org.apache.hudi.client.bootstrap.translator.IdentityBootstrapPartitionPathTranslator</td><td>Translates the partition paths from the bootstrapped data into how is laid out as a Hudi table.<br><code>Config Param: PARTITION_PATH_TRANSLATOR_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Clean-Configs">Clean Configs<a class="hash-link" href="#Clean-Configs" title="Direct link to heading">​</a></h3><p>Cleaning (reclamation of older/unused file groups/slices).</p><p><a href="#Clean-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiecleanasync">hoodie.clean.async</a></td><td>false</td><td>Only applies when hoodie.clean.automatic is turned on. When turned on runs cleaner async with writing, which can speed up overall write performance.<br><code>Config Param: ASYNC_CLEAN</code></td></tr><tr><td><a href="#hoodiecleanercommitsretained">hoodie.cleaner.commits.retained</a></td><td>10</td><td>Number of commits to retain, without cleaning. This will be retained for num_of_commits * time_between_commits (scheduled). This also directly translates into how much data retention the table supports for incremental queries.<br><code>Config Param: CLEANER_COMMITS_RETAINED</code></td></tr></tbody></table><p><a href="#Clean-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiecleanallowmultiple">hoodie.clean.allow.multiple</a></td><td>true</td><td>Allows scheduling/executing multiple cleans by enabling this config. If users prefer to strictly ensure clean requests should be mutually exclusive, .i.e. a 2nd clean will not be scheduled if another clean is not yet completed to avoid repeat cleaning of same files, they might want to disable this config.<br><code>Config Param: ALLOW_MULTIPLE_CLEANS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiecleanautomatic">hoodie.clean.automatic</a></td><td>true</td><td>When enabled, the cleaner table service is invoked immediately after each commit, to delete older file slices. It&#x27;s recommended to enable this, to ensure metadata and data storage growth is bounded.<br><code>Config Param: AUTO_CLEAN</code></td></tr><tr><td><a href="#hoodiecleanmaxcommits">hoodie.clean.max.commits</a></td><td>1</td><td>Number of commits after the last clean operation, before scheduling of a new clean is attempted.<br><code>Config Param: CLEAN_MAX_COMMITS</code></td></tr><tr><td><a href="#hoodiecleantriggerstrategy">hoodie.clean.trigger.strategy</a></td><td>NUM_COMMITS</td><td>org.apache.hudi.table.action.clean.CleaningTriggerStrategy: Controls when cleaning is scheduled.     NUM_COMMITS(default): Trigger the cleaning service every N commits, determined by <code>hoodie.clean.max.commits</code>.<br><code>Config Param: CLEAN_TRIGGER_STRATEGY</code></td></tr><tr><td><a href="#hoodiecleanerdeletebootstrapbasefile">hoodie.cleaner.delete.bootstrap.base.file</a></td><td>false</td><td>When set to true, cleaner also deletes the bootstrap base file when it&#x27;s skeleton base file is  cleaned. Turn this to true, if you want to ensure the bootstrap dataset storage is reclaimed over time, as the table receives updates/deletes. Another reason to turn this on, would be to ensure data residing in bootstrap  base files are also physically deleted, to comply with data privacy enforcement processes.<br><code>Config Param: CLEANER_BOOTSTRAP_BASE_FILE_ENABLE</code></td></tr><tr><td><a href="#hoodiecleanerfileversionsretained">hoodie.cleaner.fileversions.retained</a></td><td>3</td><td>When KEEP_LATEST_FILE_VERSIONS cleaning policy is used,  the minimum number of file slices to retain in each file group, during cleaning.<br><code>Config Param: CLEANER_FILE_VERSIONS_RETAINED</code></td></tr><tr><td><a href="#hoodiecleanerhoursretained">hoodie.cleaner.hours.retained</a></td><td>24</td><td>Number of hours for which commits need to be retained. This config provides a more flexible option ascompared to number of commits retained for cleaning service. Setting this property ensures all the files, but the latest in a file group, corresponding to commits with commit times older than the configured number of hours to be retained are cleaned.<br><code>Config Param: CLEANER_HOURS_RETAINED</code></td></tr><tr><td><a href="#hoodiecleanerincrementalmode">hoodie.cleaner.incremental.mode</a></td><td>true</td><td>When enabled, the plans for each cleaner service run is computed incrementally off the events  in the timeline, since the last cleaner run. This is much more efficient than obtaining listings for the full table for each planning (even with a metadata table).<br><code>Config Param: CLEANER_INCREMENTAL_MODE_ENABLE</code></td></tr><tr><td><a href="#hoodiecleanerparallelism">hoodie.cleaner.parallelism</a></td><td>200</td><td>This config controls the behavior of both the cleaning plan and cleaning execution. Deriving the cleaning plan is parallelized at the table partition level, i.e., each table partition is processed by one Spark task to figure out the files to clean. The cleaner picks the configured parallelism if the number of table partitions is larger than this configured value. The parallelism is assigned to the number of table partitions if it is smaller than the configured value. The clean execution, i.e., the file deletion, is parallelized at file level, which is the unit of Spark task distribution. Similarly, the actual parallelism cannot exceed the configured value if the number of files is larger. If cleaning plan or execution is slow due to limited parallelism, you can increase this to tune the performance..<br><code>Config Param: CLEANER_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiecleanerpolicy">hoodie.cleaner.policy</a></td><td>KEEP_LATEST_COMMITS</td><td>org.apache.hudi.common.model.HoodieCleaningPolicy: Cleaning policy to be used. The cleaner service deletes older file slices files to re-claim space. Long running query plans may often refer to older file slices and will break if those are cleaned, before the query has had a chance to run. So, it is good to make sure that the data is retained for more than the maximum query execution time. By default, the cleaning policy is determined based on one of the following configs explicitly set by the user (at most one of them can be set; otherwise, KEEP_LATEST_COMMITS cleaning policy is used).     KEEP_LATEST_FILE_VERSIONS: keeps the last N versions of the file slices written; used when &quot;hoodie.cleaner.fileversions.retained&quot; is explicitly set only.     KEEP_LATEST_COMMITS(default): keeps the file slices written by the last N commits; used when &quot;hoodie.cleaner.commits.retained&quot; is explicitly set only.     KEEP_LATEST_BY_HOURS: keeps the file slices written in the last N hours based on the commit time; used when &quot;hoodie.cleaner.hours.retained&quot; is explicitly set only.<br><code>Config Param: CLEANER_POLICY</code></td></tr><tr><td><a href="#hoodiecleanerpolicyfailedwrites">hoodie.cleaner.policy.failed.writes</a></td><td>EAGER</td><td>org.apache.hudi.common.model.HoodieFailedWritesCleaningPolicy: Policy that controls how to clean up failed writes. Hudi will delete any files written by failed writes to re-claim space.     EAGER(default): Clean failed writes inline after every write operation.     LAZY: Clean failed writes lazily after heartbeat timeout when the cleaning service runs. This policy is required when multi-writers are enabled.     NEVER: Never clean failed writes.<br><code>Config Param: FAILED_WRITES_CLEANER_POLICY</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Clustering-Configs">Clustering Configs<a class="hash-link" href="#Clustering-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control the clustering table service in hudi, which optimizes the storage layout for better query performance by sorting and sizing data files.</p><p><a href="#Clustering-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieclusteringasyncenabled">hoodie.clustering.async.enabled</a></td><td>false</td><td>Enable running of clustering service, asynchronously as inserts happen on the table.<br><code>Config Param: ASYNC_CLUSTERING_ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringinline">hoodie.clustering.inline</a></td><td>false</td><td>Turn on inline clustering - clustering will be run after each write operation is complete<br><code>Config Param: INLINE_CLUSTERING</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategysmallfilelimit">hoodie.clustering.plan.strategy.small.file.limit</a></td><td>314572800</td><td>Files smaller than the size in bytes specified here are candidates for clustering<br><code>Config Param: PLAN_STRATEGY_SMALL_FILE_LIMIT</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategytargetfilemaxbytes">hoodie.clustering.plan.strategy.target.file.max.bytes</a></td><td>1073741824</td><td>Each group can produce &#x27;N&#x27; (CLUSTERING_MAX_GROUP_SIZE/CLUSTERING_TARGET_FILE_SIZE) output file groups<br><code>Config Param: PLAN_STRATEGY_TARGET_FILE_MAX_BYTES</code><br><code>Since Version: 0.7.0</code></td></tr></tbody></table><p><a href="#Clustering-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieclusteringplanstrategyclusterbeginpartition">hoodie.clustering.plan.strategy.cluster.begin.partition</a></td><td>(N/A)</td><td>Begin partition used to filter partition (inclusive), only effective when the filter mode &#x27;hoodie.clustering.plan.partition.filter.mode&#x27; is SELECTED_PARTITIONS<br><code>Config Param: PARTITION_FILTER_BEGIN_PARTITION</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategyclusterendpartition">hoodie.clustering.plan.strategy.cluster.end.partition</a></td><td>(N/A)</td><td>End partition used to filter partition (inclusive), only effective when the filter mode &#x27;hoodie.clustering.plan.partition.filter.mode&#x27; is SELECTED_PARTITIONS<br><code>Config Param: PARTITION_FILTER_END_PARTITION</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategypartitionregexpattern">hoodie.clustering.plan.strategy.partition.regex.pattern</a></td><td>(N/A)</td><td>Filter clustering partitions that matched regex pattern<br><code>Config Param: PARTITION_REGEX_PATTERN</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategypartitionselected">hoodie.clustering.plan.strategy.partition.selected</a></td><td>(N/A)</td><td>Partitions to run clustering<br><code>Config Param: PARTITION_SELECTED</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategysortcolumns">hoodie.clustering.plan.strategy.sort.columns</a></td><td>(N/A)</td><td>Columns to sort the data by when clustering<br><code>Config Param: PLAN_STRATEGY_SORT_COLUMNS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringasyncmaxcommits">hoodie.clustering.async.max.commits</a></td><td>4</td><td>Config to control frequency of async clustering<br><code>Config Param: ASYNC_CLUSTERING_MAX_COMMITS</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodieclusteringexecutionstrategyclass">hoodie.clustering.execution.strategy.class</a></td><td>org.apache.hudi.client.clustering.run.strategy.SparkSortAndSizeExecutionStrategy</td><td>Config to provide a strategy class (subclass of RunClusteringStrategy) to define how the  clustering plan is executed. By default, we sort the file groups in th plan by the specified columns, while  meeting the configured target file sizes.<br><code>Config Param: EXECUTION_STRATEGY_CLASS_NAME</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringinlinemaxcommits">hoodie.clustering.inline.max.commits</a></td><td>4</td><td>Config to control frequency of clustering planning<br><code>Config Param: INLINE_CLUSTERING_MAX_COMMITS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringmaxparallelism">hoodie.clustering.max.parallelism</a></td><td>15</td><td>Maximum number of parallelism jobs submitted in clustering operation. If the resource is sufficient(Like Spark engine has enough idle executors), increasing this value will let the clustering job run faster, while it will give additional pressure to the execution engines to manage more concurrent running jobs.<br><code>Config Param: CLUSTERING_MAX_PARALLELISM</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodieclusteringplanpartitionfiltermode">hoodie.clustering.plan.partition.filter.mode</a></td><td>NONE</td><td>org.apache.hudi.table.action.cluster.ClusteringPlanPartitionFilterMode: Partition filter mode used in the creation of clustering plan.     NONE(default): Do not filter partitions. The clustering plan will include all partitions that have clustering candidates.     RECENT_DAYS: This filter assumes that your data is partitioned by date. The clustering plan will only include partitions from K days ago to N days ago, where K <!-- -->&gt;<!-- -->= N. K is determined by <code>hoodie.clustering.plan.strategy.daybased.lookback.partitions</code> and N is determined by <code>hoodie.clustering.plan.strategy.daybased.skipfromlatest.partitions</code>.     SELECTED_PARTITIONS: The clustering plan will include only partition paths with names that sort within the inclusive range <!-- -->[<code>hoodie.clustering.plan.strategy.cluster.begin.partition</code>, <code>hoodie.clustering.plan.strategy.cluster.end.partition</code>]<!-- -->.     DAY_ROLLING: To determine the partitions in the clustering plan, the eligible partitions will be sorted in ascending order. Each partition will have an index i in that list. The clustering plan will only contain partitions such that i mod 24 = H, where H is the current hour of the day (from 0 to 23).<br><code>Config Param: PLAN_PARTITION_FILTER_MODE_NAME</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategyclass">hoodie.clustering.plan.strategy.class</a></td><td>org.apache.hudi.client.clustering.plan.strategy.SparkSizeBasedClusteringPlanStrategy</td><td>Config to provide a strategy class (subclass of ClusteringPlanStrategy) to create clustering plan i.e select what file groups are being clustered. Default strategy, looks at the clustering small file size limit (determined by hoodie.clustering.plan.strategy.small.file.limit) to pick the small file slices within partitions for clustering.<br><code>Config Param: PLAN_STRATEGY_CLASS_NAME</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategydaybasedlookbackpartitions">hoodie.clustering.plan.strategy.daybased.lookback.partitions</a></td><td>2</td><td>Number of partitions to list to create ClusteringPlan<br><code>Config Param: DAYBASED_LOOKBACK_PARTITIONS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategydaybasedskipfromlatestpartitions">hoodie.clustering.plan.strategy.daybased.skipfromlatest.partitions</a></td><td>0</td><td>Number of partitions to skip from latest when choosing partitions to create ClusteringPlan<br><code>Config Param: PLAN_STRATEGY_SKIP_PARTITIONS_FROM_LATEST</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategymaxbytespergroup">hoodie.clustering.plan.strategy.max.bytes.per.group</a></td><td>2147483648</td><td>Each clustering operation can create multiple output file groups. Total amount of data processed by clustering operation is defined by below two properties (CLUSTERING_MAX_BYTES_PER_GROUP * CLUSTERING_MAX_NUM_GROUPS). Max amount of data to be included in one group<br><code>Config Param: PLAN_STRATEGY_MAX_BYTES_PER_OUTPUT_FILEGROUP</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategymaxnumgroups">hoodie.clustering.plan.strategy.max.num.groups</a></td><td>30</td><td>Maximum number of groups to create as part of ClusteringPlan. Increasing groups will increase parallelism<br><code>Config Param: PLAN_STRATEGY_MAX_GROUPS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodieclusteringplanstrategysinglegroupclusteringenabled">hoodie.clustering.plan.strategy.single.group.clustering.enabled</a></td><td>true</td><td>Whether to generate clustering plan when there is only one file group involved, by default true<br><code>Config Param: PLAN_STRATEGY_SINGLE_GROUP_CLUSTERING_ENABLED</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodieclusteringrollbackpendingreplacecommitonconflict">hoodie.clustering.rollback.pending.replacecommit.on.conflict</a></td><td>false</td><td>If updates are allowed to file groups pending clustering, then set this config to rollback failed or pending clustering instants. Pending clustering will be rolled back ONLY IF there is conflict between incoming upsert and filegroup to be clustered. Please exercise caution while setting this config, especially when clustering is done very frequently. This could lead to race condition in rare scenarios, for example, when the clustering completes after instants are fetched but before rollback completed.<br><code>Config Param: ROLLBACK_PENDING_CLUSTERING_ON_CONFLICT</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodieclusteringscheduleinline">hoodie.clustering.schedule.inline</a></td><td>false</td><td>When set to true, clustering service will be attempted for inline scheduling after each write. Users have to ensure they have a separate job to run async clustering(execution) for the one scheduled by this writer. Users can choose to set both <code>hoodie.clustering.inline</code> and <code>hoodie.clustering.schedule.inline</code> to false and have both scheduling and execution triggered by any async process, on which case <code>hoodie.clustering.async.enabled</code> is expected to be set to true. But if <code>hoodie.clustering.inline</code> is set to false, and <code>hoodie.clustering.schedule.inline</code> is set to true, regular writers will schedule clustering inline, but users are expected to trigger async job for execution. If <code>hoodie.clustering.inline</code> is set to true, regular writers will do both scheduling and execution inline for clustering<br><code>Config Param: SCHEDULE_INLINE_CLUSTERING</code></td></tr><tr><td><a href="#hoodieclusteringupdatesstrategy">hoodie.clustering.updates.strategy</a></td><td>org.apache.hudi.client.clustering.update.strategy.SparkRejectUpdateStrategy</td><td>Determines how to handle updates, deletes to file groups that are under clustering. Default strategy just rejects the update<br><code>Config Param: UPDATES_STRATEGY</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodielayoutoptimizebuildcurvesamplesize">hoodie.layout.optimize.build.curve.sample.size</a></td><td>200000</td><td>Determines target sample size used by the Boundary-based Interleaved Index method of building space-filling curve. Larger sample size entails better layout optimization outcomes, at the expense of higher memory footprint.<br><code>Config Param: LAYOUT_OPTIMIZE_BUILD_CURVE_SAMPLE_SIZE</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodielayoutoptimizecurvebuildmethod">hoodie.layout.optimize.curve.build.method</a></td><td>DIRECT</td><td>org.apache.hudi.config.HoodieClusteringConfig$SpatialCurveCompositionStrategyType: This configuration only has effect if <code>hoodie.layout.optimize.strategy</code> is set to either &quot;z-order&quot; or &quot;hilbert&quot; (i.e. leveraging space-filling curves). This configuration controls the type of a strategy to use for building the space-filling curves, tackling specifically how the Strings are ordered based on the curve. Since we truncate the String to 8 bytes for ordering, there are two issues: (1) it can lead to poor aggregation effect, (2) the truncation of String longer than 8 bytes loses the precision, if the Strings are different but the 8-byte prefix is the same. The boundary-based interleaved index method (&quot;SAMPLE&quot;) has better generalization, solving the two problems above, but is slower than direct method (&quot;DIRECT&quot;). User should benchmark the write and query performance before tweaking this in production, if this is actually a problem. Please refer to RFC-28 for more details.     DIRECT(default): This strategy builds the spatial curve in full, filling in all of the individual points corresponding to each individual record, which requires less compute.     SAMPLE: This strategy leverages boundary-base interleaved index method (described in more details in Amazon DynamoDB blog <a href="https://aws.amazon.com/cn/blogs/database/tag/z-order/" target="_blank" rel="noopener noreferrer">https://aws.amazon.com/cn/blogs/database/tag/z-order/</a>) and produces a better layout compared to DIRECT strategy.  It requires more compute and is slower.<br><code>Config Param: LAYOUT_OPTIMIZE_SPATIAL_CURVE_BUILD_METHOD</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodielayoutoptimizedataskippingenable">hoodie.layout.optimize.data.skipping.enable</a></td><td>true</td><td>Enable data skipping by collecting statistics once layout optimization is complete.<br><code>Config Param: LAYOUT_OPTIMIZE_DATA_SKIPPING_ENABLE</code><br><code>Since Version: 0.10.0</code><br><code>Deprecated since: 0.11.0</code></td></tr><tr><td><a href="#hoodielayoutoptimizeenable">hoodie.layout.optimize.enable</a></td><td>false</td><td>This setting has no effect. Please refer to clustering configuration, as well as LAYOUT_OPTIMIZE_STRATEGY config to enable advanced record layout optimization strategies<br><code>Config Param: LAYOUT_OPTIMIZE_ENABLE</code><br><code>Since Version: 0.10.0</code><br><code>Deprecated since: 0.11.0</code></td></tr><tr><td><a href="#hoodielayoutoptimizestrategy">hoodie.layout.optimize.strategy</a></td><td>linear</td><td>Determines ordering strategy used in records layout optimization. Currently supported strategies are &quot;linear&quot;, &quot;z-order&quot; and &quot;hilbert&quot; values are supported.<br><code>Config Param: LAYOUT_OPTIMIZE_STRATEGY</code><br><code>Since Version: 0.10.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Compaction-Configs">Compaction Configs<a class="hash-link" href="#Compaction-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control compaction (merging of log files onto a new base files).</p><p><a href="#Compaction-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiecompactinline">hoodie.compact.inline</a></td><td>false</td><td>When set to true, compaction service is triggered after each write. While being  simpler operationally, this adds extra latency on the write path.<br><code>Config Param: INLINE_COMPACT</code></td></tr><tr><td><a href="#hoodiecompactinlinemaxdeltacommits">hoodie.compact.inline.max.delta.commits</a></td><td>5</td><td>Number of delta commits after the last compaction, before scheduling of a new compaction is attempted. This config takes effect only for the compaction triggering strategy based on the number of commits, i.e., NUM_COMMITS, NUM_COMMITS_AFTER_LAST_REQUEST, NUM_AND_TIME, and NUM_OR_TIME.<br><code>Config Param: INLINE_COMPACT_NUM_DELTA_COMMITS</code></td></tr></tbody></table><p><a href="#Compaction-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiecompactinlinemaxdeltaseconds">hoodie.compact.inline.max.delta.seconds</a></td><td>3600</td><td>Number of elapsed seconds after the last compaction, before scheduling a new one. This config takes effect only for the compaction triggering strategy based on the elapsed time, i.e., TIME_ELAPSED, NUM_AND_TIME, and NUM_OR_TIME.<br><code>Config Param: INLINE_COMPACT_TIME_DELTA_SECONDS</code></td></tr><tr><td><a href="#hoodiecompactinlinetriggerstrategy">hoodie.compact.inline.trigger.strategy</a></td><td>NUM_COMMITS</td><td>org.apache.hudi.table.action.compact.CompactionTriggerStrategy: Controls when compaction is scheduled.     NUM_COMMITS(default): triggers compaction when there are at least N delta commits after last completed compaction.     NUM_COMMITS_AFTER_LAST_REQUEST: triggers compaction when there are at least N delta commits after last completed or requested compaction.     TIME_ELAPSED: triggers compaction after N seconds since last compaction.     NUM_AND_TIME: triggers compaction when both there are at least N delta commits and N seconds elapsed (both must be satisfied) after last completed compaction.     NUM_OR_TIME: triggers compaction when both there are at least N delta commits or N seconds elapsed (either condition is satisfied) after last completed compaction.<br><code>Config Param: INLINE_COMPACT_TRIGGER_STRATEGY</code></td></tr><tr><td><a href="#hoodiecompactscheduleinline">hoodie.compact.schedule.inline</a></td><td>false</td><td>When set to true, compaction service will be attempted for inline scheduling after each write. Users have to ensure they have a separate job to run async compaction(execution) for the one scheduled by this writer. Users can choose to set both <code>hoodie.compact.inline</code> and <code>hoodie.compact.schedule.inline</code> to false and have both scheduling and execution triggered by any async process. But if <code>hoodie.compact.inline</code> is set to false, and <code>hoodie.compact.schedule.inline</code> is set to true, regular writers will schedule compaction inline, but users are expected to trigger async job for execution. If <code>hoodie.compact.inline</code> is set to true, regular writers will do both scheduling and execution inline for compaction<br><code>Config Param: SCHEDULE_INLINE_COMPACT</code></td></tr><tr><td><a href="#hoodiecompactiondaybasedtargetpartitions">hoodie.compaction.daybased.target.partitions</a></td><td>10</td><td>Used by org.apache.hudi.io.compact.strategy.DayBasedCompactionStrategy to denote the number of latest partitions to compact during a compaction run.<br><code>Config Param: TARGET_PARTITIONS_PER_DAYBASED_COMPACTION</code></td></tr><tr><td><a href="#hoodiecompactionlazyblockread">hoodie.compaction.lazy.block.read</a></td><td>true</td><td>When merging the delta log files, this config helps to choose whether the log blocks should be read lazily or not. Choose true to use lazy block reading (low memory usage, but incurs seeks to each block header) or false for immediate block read (higher memory usage)<br><code>Config Param: COMPACTION_LAZY_BLOCK_READ_ENABLE</code></td></tr><tr><td><a href="#hoodiecompactionlogfilenumthreshold">hoodie.compaction.logfile.num.threshold</a></td><td>0</td><td>Only if the log file num is greater than the threshold, the file group will be compacted.<br><code>Config Param: COMPACTION_LOG_FILE_NUM_THRESHOLD</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiecompactionlogfilesizethreshold">hoodie.compaction.logfile.size.threshold</a></td><td>0</td><td>Only if the log file size is greater than the threshold in bytes, the file group will be compacted.<br><code>Config Param: COMPACTION_LOG_FILE_SIZE_THRESHOLD</code></td></tr><tr><td><a href="#hoodiecompactionreverselogread">hoodie.compaction.reverse.log.read</a></td><td>false</td><td>HoodieLogFormatReader reads a logfile in the forward direction starting from pos=0 to pos=file_length. If this config is set to true, the reader reads the logfile in reverse direction, from pos=file_length to pos=0<br><code>Config Param: COMPACTION_REVERSE_LOG_READ_ENABLE</code></td></tr><tr><td><a href="#hoodiecompactionstrategy">hoodie.compaction.strategy</a></td><td>org.apache.hudi.table.action.compact.strategy.LogFileSizeBasedCompactionStrategy</td><td>Compaction strategy decides which file groups are picked up for compaction during each compaction run. By default. Hudi picks the log file with most accumulated unmerged data<br><code>Config Param: COMPACTION_STRATEGY</code></td></tr><tr><td><a href="#hoodiecompactiontargetio">hoodie.compaction.target.io</a></td><td>512000</td><td>Amount of MBs to spend during compaction run for the LogFileSizeBasedCompactionStrategy. This value helps bound ingestion latency while compaction is run inline mode.<br><code>Config Param: TARGET_IO_PER_COMPACTION_IN_MB</code></td></tr><tr><td><a href="#hoodiecopyonwriteinsertautosplit">hoodie.copyonwrite.insert.auto.split</a></td><td>true</td><td>Config to control whether we control insert split sizes automatically based on average record sizes. It&#x27;s recommended to keep this turned on, since hand tuning is otherwise extremely cumbersome.<br><code>Config Param: COPY_ON_WRITE_AUTO_SPLIT_INSERTS</code></td></tr><tr><td><a href="#hoodiecopyonwriteinsertsplitsize">hoodie.copyonwrite.insert.split.size</a></td><td>500000</td><td>Number of inserts assigned for each partition/bucket for writing. We based the default on writing out 100MB files, with at least 1kb records (100K records per file), and   over provision to 500K. As long as auto-tuning of splits is turned on, this only affects the first   write, where there is no history to learn record sizes from.<br><code>Config Param: COPY_ON_WRITE_INSERT_SPLIT_SIZE</code></td></tr><tr><td><a href="#hoodiecopyonwriterecordsizeestimate">hoodie.copyonwrite.record.size.estimate</a></td><td>1024</td><td>The average record size. If not explicitly specified, hudi will compute the record size estimate compute dynamically based on commit metadata.  This is critical in computing the insert parallelism and bin-packing inserts into small files.<br><code>Config Param: COPY_ON_WRITE_RECORD_SIZE_ESTIMATE</code></td></tr><tr><td><a href="#hoodielogcompactionblocksthreshold">hoodie.log.compaction.blocks.threshold</a></td><td>5</td><td>Log compaction can be scheduled if the no. of log blocks crosses this threshold value. This is effective only when log compaction is enabled via hoodie.log.compaction.inline<br><code>Config Param: LOG_COMPACTION_BLOCKS_THRESHOLD</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodielogcompactionenable">hoodie.log.compaction.enable</a></td><td>false</td><td>By enabling log compaction through this config, log compaction will also get enabled for the metadata table.<br><code>Config Param: ENABLE_LOG_COMPACTION</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodielogcompactioninline">hoodie.log.compaction.inline</a></td><td>false</td><td>When set to true, logcompaction service is triggered after each write. While being  simpler operationally, this adds extra latency on the write path.<br><code>Config Param: INLINE_LOG_COMPACT</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodieoptimizedlogblocksscanenable">hoodie.optimized.log.blocks.scan.enable</a></td><td>false</td><td>New optimized scan for log blocks that handles all multi-writer use-cases while appending to log files. It also differentiates original blocks written by ingestion writers and compacted blocks written log compaction.<br><code>Config Param: ENABLE_OPTIMIZED_LOG_BLOCKS_SCAN</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodieparquetsmallfilelimit">hoodie.parquet.small.file.limit</a></td><td>104857600</td><td>During upsert operation, we opportunistically expand existing small files on storage, instead of writing new files, to keep number of files to an optimum. This config sets the file size limit below which a file on storage  becomes a candidate to be selected as such a <code>small file</code>. By default, treat any file <!-- -->&lt;<!-- -->= 100MB as a small file. Also note that if this set <!-- -->&lt;<!-- -->= 0, will not try to get small files and directly write new files<br><code>Config Param: PARQUET_SMALL_FILE_LIMIT</code></td></tr><tr><td><a href="#hoodierecordsizeestimationthreshold">hoodie.record.size.estimation.threshold</a></td><td>1.0</td><td>We use the previous commits&#x27; metadata to calculate the estimated record size and use it  to bin pack records into partitions. If the previous commit is too small to make an accurate estimation,  Hudi will search commits in the reverse order, until we find a commit that has totalBytesWritten  larger than (PARQUET_SMALL_FILE_LIMIT_BYTES * this_threshold)<br><code>Config Param: RECORD_SIZE_ESTIMATION_THRESHOLD</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Layout-Configs">Layout Configs<a class="hash-link" href="#Layout-Configs" title="Direct link to heading">​</a></h3><p>Configurations that control storage layout and data distribution, which defines how the files are organized within a table.</p><p><a href="#Layout-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestoragelayoutpartitionerclass">hoodie.storage.layout.partitioner.class</a></td><td>(N/A)</td><td>Partitioner class, it is used to distribute data in a specific way.<br><code>Config Param: LAYOUT_PARTITIONER_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiestoragelayouttype">hoodie.storage.layout.type</a></td><td>DEFAULT</td><td>org.apache.hudi.table.storage.HoodieStorageLayout$LayoutType: Determines how the files are organized within a table.     DEFAULT(default): Each file group contains records of a certain set of keys, without particular grouping criteria.     BUCKET: Each file group contains records of a set of keys which map to a certain range of hash values, so that using the hash function can easily identify the file group a record belongs to, based on the record key.<br><code>Config Param: LAYOUT_TYPE</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Memory-Configurations">Memory Configurations<a class="hash-link" href="#Memory-Configurations" title="Direct link to heading">​</a></h3><p>Controls memory usage for compaction and merges, performed internally by Hudi.</p><p><a href="#Memory-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiememorycompactionmaxsize">hoodie.memory.compaction.max.size</a></td><td>(N/A)</td><td>Maximum amount of memory used  in bytes for compaction operations in bytes , before spilling to local storage.<br><code>Config Param: MAX_MEMORY_FOR_COMPACTION</code></td></tr><tr><td><a href="#hoodiememoryspillablemappath">hoodie.memory.spillable.map.path</a></td><td>(N/A)</td><td>Default file path for spillable map<br><code>Config Param: SPILLABLE_MAP_BASE_PATH</code></td></tr><tr><td><a href="#hoodiememorycompactionfraction">hoodie.memory.compaction.fraction</a></td><td>0.6</td><td>HoodieCompactedLogScanner reads logblocks, converts records to HoodieRecords and then merges these log blocks and records. At any point, the number of entries in a log block can be less than or equal to the number of entries in the corresponding parquet file. This can lead to OOM in the Scanner. Hence, a spillable map helps alleviate the memory pressure. Use this config to set the max allowable inMemory footprint of the spillable map<br><code>Config Param: MAX_MEMORY_FRACTION_FOR_COMPACTION</code></td></tr><tr><td><a href="#hoodiememorydfsbuffermaxsize">hoodie.memory.dfs.buffer.max.size</a></td><td>16777216</td><td>Property to control the max memory in bytes for dfs input stream buffer size<br><code>Config Param: MAX_DFS_STREAM_BUFFER_SIZE</code></td></tr><tr><td><a href="#hoodiememorymergefraction">hoodie.memory.merge.fraction</a></td><td>0.6</td><td>This fraction is multiplied with the user memory fraction (1 - spark.memory.fraction) to get a final fraction of heap space to use during merge<br><code>Config Param: MAX_MEMORY_FRACTION_FOR_MERGE</code></td></tr><tr><td><a href="#hoodiememorymergemaxsize">hoodie.memory.merge.max.size</a></td><td>1073741824</td><td>Maximum amount of memory used  in bytes for merge operations, before spilling to local storage.<br><code>Config Param: MAX_MEMORY_FOR_MERGE</code></td></tr><tr><td><a href="#hoodiememorywritestatusfailurefraction">hoodie.memory.writestatus.failure.fraction</a></td><td>0.1</td><td>Property to control how what fraction of the failed record, exceptions we report back to driver. Default is 10%. If set to 100%, with lot of failures, this can cause memory pressure, cause OOMs and mask actual data errors.<br><code>Config Param: WRITESTATUS_FAILURE_FRACTION</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Write-Configurations">Write Configurations<a class="hash-link" href="#Write-Configurations" title="Direct link to heading">​</a></h3><p>Configurations that control write behavior on Hudi tables. These can be directly passed down from even higher level frameworks (e.g Spark datasources, Flink sink) and utilities (e.g Hudi Streamer).</p><p><a href="#Write-Configurations-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiebasepath">hoodie.base.path</a></td><td>(N/A)</td><td>Base path on lake storage, under which all the table data is stored. Always prefix it explicitly with the storage scheme (e.g hdfs://, s3:// etc). Hudi stores all the main meta-data about commits, savepoints, cleaning audit logs etc in .hoodie directory under this base path directory.<br><code>Config Param: BASE_PATH</code></td></tr><tr><td><a href="#hoodietablename">hoodie.table.name</a></td><td>(N/A)</td><td>Table name that will be used for registering with metastores like HMS. Needs to be same across runs.<br><code>Config Param: TBL_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewriteprecombinefield">hoodie.datasource.write.precombine.field</a></td><td>ts</td><td>Field used in preCombining before actual write. When two records have the same key value, we will pick the one with the largest value for the precombine field, determined by Object.compareTo(..)<br><code>Config Param: PRECOMBINE_FIELD_NAME</code></td></tr><tr><td><a href="#hoodiewriteconcurrencymode">hoodie.write.concurrency.mode</a></td><td>SINGLE_WRITER</td><td>org.apache.hudi.common.model.WriteConcurrencyMode: Concurrency modes for write operations.     SINGLE_WRITER(default): Only one active writer to the table. Maximizes throughput.     OPTIMISTIC_CONCURRENCY_CONTROL: Multiple writers can operate on the table with lazy conflict resolution using locks. This means that only one writer succeeds if multiple writers write to the same file group.<br><code>Config Param: WRITE_CONCURRENCY_MODE</code></td></tr></tbody></table><p><a href="#Write-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieavroschema">hoodie.avro.schema</a></td><td>(N/A)</td><td>Schema string representing the current write schema of the table. Hudi passes this to implementations of HoodieRecordPayload to convert incoming records to avro. This is also used as the write schema evolving records during an update.<br><code>Config Param: AVRO_SCHEMA_STRING</code></td></tr><tr><td><a href="#hoodiebulkinsertuserdefinedpartitionerclass">hoodie.bulkinsert.user.defined.partitioner.class</a></td><td>(N/A)</td><td>If specified, this class will be used to re-partition records before they are bulk inserted. This can be used to sort, pack, cluster data optimally for common query patterns. For now we support a build-in user defined bulkinsert partitioner org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner which can does sorting based on specified column values set by hoodie.bulkinsert.user.defined.partitioner.sort.columns<br><code>Config Param: BULKINSERT_USER_DEFINED_PARTITIONER_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiebulkinsertuserdefinedpartitionersortcolumns">hoodie.bulkinsert.user.defined.partitioner.sort.columns</a></td><td>(N/A)</td><td>Columns to sort the data by when use org.apache.hudi.execution.bulkinsert.RDDCustomColumnsSortPartitioner as user defined partitioner during bulk_insert. For example &#x27;column1,column2&#x27;<br><code>Config Param: BULKINSERT_USER_DEFINED_PARTITIONER_SORT_COLUMNS</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratorclass">hoodie.datasource.write.keygenerator.class</a></td><td>(N/A)</td><td>Key generator class, that implements <code>org.apache.hudi.keygen.KeyGenerator</code> extract a key out of incoming records.<br><code>Config Param: KEYGENERATOR_CLASS_NAME</code></td></tr><tr><td><a href="#hoodieinternalschema">hoodie.internal.schema</a></td><td>(N/A)</td><td>Schema string representing the latest schema of the table. Hudi passes this to implementations of evolution of schema<br><code>Config Param: INTERNAL_SCHEMA_STRING</code></td></tr><tr><td><a href="#hoodiewriteschema">hoodie.write.schema</a></td><td>(N/A)</td><td>Config allowing to override writer&#x27;s schema. This might be necessary in cases when writer&#x27;s schema derived from the incoming dataset might actually be different from the schema we actually want to use when writing. This, for ex, could be the case for&#x27;partial-update&#x27; use-cases (like <code>MERGE INTO</code> Spark SQL statement for ex) where only a projection of the incoming dataset might be used to update the records in the existing table, prompting us to override the writer&#x27;s schema<br><code>Config Param: WRITE_SCHEMA_OVERRIDE</code></td></tr><tr><td><a href="#_hoodieallowmultiwriteonsameinstant">_.hoodie.allow.multi.write.on.same.instant</a></td><td>false</td><td><br><code>Config Param: ALLOW_MULTI_WRITE_ON_SAME_INSTANT_ENABLE</code></td></tr><tr><td><a href="#hoodieallowemptycommit">hoodie.allow.empty.commit</a></td><td>true</td><td>Whether to allow generation of empty commits, even if no data was written in the commit. It&#x27;s useful in cases where extra metadata needs to be published regardless e.g tracking source offsets when ingesting data<br><code>Config Param: ALLOW_EMPTY_COMMIT</code></td></tr><tr><td><a href="#hoodieallowoperationmetadatafield">hoodie.allow.operation.metadata.field</a></td><td>false</td><td>Whether to include &#x27;_hoodie_operation&#x27; in the metadata fields. Once enabled, all the changes of a record are persisted to the delta log directly without merge<br><code>Config Param: ALLOW_OPERATION_METADATA_FIELD</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodieautoadjustlockconfigs">hoodie.auto.adjust.lock.configs</a></td><td>false</td><td>Auto adjust lock configurations when metadata table is enabled and for async table services.<br><code>Config Param: AUTO_ADJUST_LOCK_CONFIGS</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieautocommit">hoodie.auto.commit</a></td><td>true</td><td>Controls whether a write operation should auto commit. This can be turned off to perform inspection of the uncommitted write before deciding to commit.<br><code>Config Param: AUTO_COMMIT_ENABLE</code></td></tr><tr><td><a href="#hoodieavroschemaexternaltransformation">hoodie.avro.schema.external.transformation</a></td><td>false</td><td>When enabled, records in older schema are rewritten into newer schema during upsert,delete and background compaction,clustering operations.<br><code>Config Param: AVRO_EXTERNAL_SCHEMA_TRANSFORMATION_ENABLE</code></td></tr><tr><td><a href="#hoodieavroschemavalidate">hoodie.avro.schema.validate</a></td><td>false</td><td>Validate the schema used for the write against the latest schema, for backwards compatibility.<br><code>Config Param: AVRO_SCHEMA_VALIDATE_ENABLE</code></td></tr><tr><td><a href="#hoodiebulkinsertshuffleparallelism">hoodie.bulkinsert.shuffle.parallelism</a></td><td>0</td><td>For large initial imports using bulk_insert operation, controls the parallelism to use for sort modes or custom partitioning done before writing records to the table. Before 0.13.0 release, if users do not configure it, Hudi would use 200 as the default shuffle parallelism. From 0.13.0 onwards Hudi by default automatically uses the parallelism deduced by Spark based on the source data or the parallelism based on the logical plan for row writer. If the shuffle parallelism is explicitly configured by the user, the user-configured parallelism is used in defining the actual parallelism. If you observe small files from the bulk insert operation, we suggest configuring this shuffle parallelism explicitly, so that the parallelism is around total_input_data_size/120MB.<br><code>Config Param: BULKINSERT_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiebulkinsertsortmode">hoodie.bulkinsert.sort.mode</a></td><td>NONE</td><td>org.apache.hudi.execution.bulkinsert.BulkInsertSortMode: Modes for sorting records during bulk insert.     NONE(default): No sorting. Fastest and matches <code>spark.write.parquet()</code> in number of files and overhead.     GLOBAL_SORT: This ensures best file sizes, with lowest memory overhead at cost of sorting.     PARTITION_SORT: Strikes a balance by only sorting within a Spark RDD partition, still keeping the memory overhead of writing low. File sizing is not as good as GLOBAL_SORT.     PARTITION_PATH_REPARTITION: This ensures that the data for a single physical partition in the table is written by the same Spark executor. This should only be used when input data is evenly distributed across different partition paths. If data is skewed (most records are intended for a handful of partition paths among all) then this can cause an imbalance among Spark executors.     PARTITION_PATH_REPARTITION_AND_SORT: This ensures that the data for a single physical partition in the table is written by the same Spark executor. This should only be used when input data is evenly distributed across different partition paths. Compared to PARTITION_PATH_REPARTITION, this sort mode does an additional step of sorting the records based on the partition path within a single Spark partition, given that data for multiple physical partitions can be sent to the same Spark partition and executor. If data is skewed (most records are intended for a handful of partition paths among all) then this can cause an imbalance among Spark executors.<br><code>Config Param: BULK_INSERT_SORT_MODE</code></td></tr><tr><td><a href="#hoodieclientheartbeatinterval_in_ms">hoodie.client.heartbeat.interval_in_ms</a></td><td>60000</td><td>Writers perform heartbeats to indicate liveness. Controls how often (in ms), such heartbeats are registered to lake storage.<br><code>Config Param: CLIENT_HEARTBEAT_INTERVAL_IN_MS</code></td></tr><tr><td><a href="#hoodieclientheartbeattolerablemisses">hoodie.client.heartbeat.tolerable.misses</a></td><td>2</td><td>Number of heartbeat misses, before a writer is deemed not alive and all pending writes are aborted.<br><code>Config Param: CLIENT_HEARTBEAT_NUM_TOLERABLE_MISSES</code></td></tr><tr><td><a href="#hoodieclientinitcallbackclasses">hoodie.client.init.callback.classes</a></td><td></td><td>Fully-qualified class names of the Hudi client init callbacks to run at the initialization of the Hudi client.  The class names are separated by <code>,</code>. The class must be a subclass of <code>org.apache.hudi.callback.HoodieClientInitCallback</code>.By default, no Hudi client init callback is executed.<br><code>Config Param: CLIENT_INIT_CALLBACK_CLASS_NAMES</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiecombinebeforedelete">hoodie.combine.before.delete</a></td><td>true</td><td>During delete operations, controls whether we should combine deletes (and potentially also upserts) before  writing to storage.<br><code>Config Param: COMBINE_BEFORE_DELETE</code></td></tr><tr><td><a href="#hoodiecombinebeforeinsert">hoodie.combine.before.insert</a></td><td>false</td><td>When inserted records share same key, controls whether they should be first combined (i.e de-duplicated) before writing to storage.<br><code>Config Param: COMBINE_BEFORE_INSERT</code></td></tr><tr><td><a href="#hoodiecombinebeforeupsert">hoodie.combine.before.upsert</a></td><td>true</td><td>When upserted records share same key, controls whether they should be first combined (i.e de-duplicated) before writing to storage. This should be turned off only if you are absolutely certain that there are no duplicates incoming,  otherwise it can lead to duplicate keys and violate the uniqueness guarantees.<br><code>Config Param: COMBINE_BEFORE_UPSERT</code></td></tr><tr><td><a href="#hoodieconsistencycheckinitial_interval_ms">hoodie.consistency.check.initial_interval_ms</a></td><td>2000</td><td>Initial time between successive attempts to ensure written data&#x27;s metadata is consistent on storage. Grows with exponential backoff after the initial value.<br><code>Config Param: INITIAL_CONSISTENCY_CHECK_INTERVAL_MS</code></td></tr><tr><td><a href="#hoodieconsistencycheckmax_checks">hoodie.consistency.check.max_checks</a></td><td>7</td><td>Maximum number of checks, for consistency of written data.<br><code>Config Param: MAX_CONSISTENCY_CHECKS</code></td></tr><tr><td><a href="#hoodieconsistencycheckmax_interval_ms">hoodie.consistency.check.max_interval_ms</a></td><td>300000</td><td>Max time to wait between successive attempts at performing consistency checks<br><code>Config Param: MAX_CONSISTENCY_CHECK_INTERVAL_MS</code></td></tr><tr><td><a href="#hoodiedatasourcewritekeygeneratortype">hoodie.datasource.write.keygenerator.type</a></td><td>SIMPLE</td><td><strong>Note</strong> This is being actively worked on. Please use <code>hoodie.datasource.write.keygenerator.class</code> instead. org.apache.hudi.keygen.constant.KeyGeneratorType: Key generator type, indicating the key generator class to use, that implements <code>org.apache.hudi.keygen.KeyGenerator</code>.     SIMPLE(default): Simple key generator, which takes names of fields to be used for recordKey and partitionPath as configs.     COMPLEX: Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.     TIMESTAMP: Timestamp-based key generator, that relies on timestamps for partitioning field. Still picks record key by name.     CUSTOM: This is a generic implementation type of KeyGenerator where users can configure record key as a single field or  a combination of fields. Similarly partition path can be configured to have multiple fields or only one field.  This KeyGenerator expects value for prop &quot;hoodie.datasource.write.partitionpath.field&quot; in a specific format.  For example:  properties.put(&quot;hoodie.datasource.write.partitionpath.field&quot;, &quot;field1:PartitionKeyType1,field2:PartitionKeyType2&quot;).     NON_PARTITION: Simple Key generator for non-partitioned tables.     GLOBAL_DELETE: Key generator for deletes using global indices.<br><code>Config Param: KEYGENERATOR_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcewritepayloadclass">hoodie.datasource.write.payload.class</a></td><td>org.apache.hudi.common.model.OverwriteWithLatestAvroPayload</td><td>Payload class used. Override this, if you like to roll your own merge logic, when upserting/inserting. This will render any value set for PRECOMBINE_FIELD_OPT_VAL in-effective<br><code>Config Param: WRITE_PAYLOAD_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordmergerimpls">hoodie.datasource.write.record.merger.impls</a></td><td>org.apache.hudi.common.model.HoodieAvroRecordMerger</td><td>List of HoodieMerger implementations constituting Hudi&#x27;s merging strategy -- based on the engine used. These merger impls will filter by hoodie.datasource.write.record.merger.strategy Hudi will pick most efficient implementation to perform merging/combining of the records (during update, reading MOR table, etc)<br><code>Config Param: RECORD_MERGER_IMPLS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordmergerstrategy">hoodie.datasource.write.record.merger.strategy</a></td><td>eeb8d96f-b1e4-49fd-bbf8-28ac514178e5</td><td>Id of merger strategy. Hudi will pick HoodieRecordMerger implementations in hoodie.datasource.write.record.merger.impls which has the same merger strategy id<br><code>Config Param: RECORD_MERGER_STRATEGY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcewriteschemaallowautoevolutioncolumndrop">hoodie.datasource.write.schema.allow.auto.evolution.column.drop</a></td><td>false</td><td>Controls whether table&#x27;s schema is allowed to automatically evolve when incoming batch&#x27;s schema can have any of the columns dropped. By default, Hudi will not allow this kind of (auto) schema evolution. Set this config to true to allow table&#x27;s schema to be updated automatically when columns are dropped from the new incoming batch.<br><code>Config Param: SCHEMA_ALLOW_AUTO_EVOLUTION_COLUMN_DROP</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedeleteshuffleparallelism">hoodie.delete.shuffle.parallelism</a></td><td>0</td><td>Parallelism used for delete operation. Delete operations also performs shuffles, similar to upsert operation. Before 0.13.0 release, if users do not configure it, Hudi would use 200 as the default shuffle parallelism. From 0.13.0 onwards Hudi by default automatically uses the parallelism deduced by Spark based on the source data. If the shuffle parallelism is explicitly configured by the user, the user-configured parallelism is used in defining the actual parallelism.<br><code>Config Param: DELETE_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodieembedtimelineserver">hoodie.embed.timeline.server</a></td><td>true</td><td>When true, spins up an instance of the timeline server (meta server that serves cached file listings, statistics),running on each writer&#x27;s driver process, accepting requests during the write from executors.<br><code>Config Param: EMBEDDED_TIMELINE_SERVER_ENABLE</code></td></tr><tr><td><a href="#hoodieembedtimelineserverasync">hoodie.embed.timeline.server.async</a></td><td>false</td><td>Controls whether or not, the requests to the timeline server are processed in asynchronous fashion, potentially improving throughput.<br><code>Config Param: EMBEDDED_TIMELINE_SERVER_USE_ASYNC_ENABLE</code></td></tr><tr><td><a href="#hoodieembedtimelineservergzip">hoodie.embed.timeline.server.gzip</a></td><td>true</td><td>Controls whether gzip compression is used, for large responses from the timeline server, to improve latency.<br><code>Config Param: EMBEDDED_TIMELINE_SERVER_COMPRESS_ENABLE</code></td></tr><tr><td><a href="#hoodieembedtimelineserverport">hoodie.embed.timeline.server.port</a></td><td>0</td><td>Port at which the timeline server listens for requests. When running embedded in each writer, it picks a free port and communicates to all the executors. This should rarely be changed.<br><code>Config Param: EMBEDDED_TIMELINE_SERVER_PORT_NUM</code></td></tr><tr><td><a href="#hoodieembedtimelineserverreuseenabled">hoodie.embed.timeline.server.reuse.enabled</a></td><td>false</td><td>Controls whether the timeline server instance should be cached and reused across the JVM (across task lifecycles)to avoid startup costs. This should rarely be changed.<br><code>Config Param: EMBEDDED_TIMELINE_SERVER_REUSE_ENABLED</code></td></tr><tr><td><a href="#hoodieembedtimelineserverthreads">hoodie.embed.timeline.server.threads</a></td><td>-1</td><td>Number of threads to serve requests in the timeline server. By default, auto configured based on the number of underlying cores.<br><code>Config Param: EMBEDDED_TIMELINE_NUM_SERVER_THREADS</code></td></tr><tr><td><a href="#hoodiefailontimelinearchiving">hoodie.fail.on.timeline.archiving</a></td><td>true</td><td>Timeline archiving removes older instants from the timeline, after each write operation, to minimize metadata overhead. Controls whether or not, the write should be failed as well, if such archiving fails.<br><code>Config Param: FAIL_ON_TIMELINE_ARCHIVING_ENABLE</code></td></tr><tr><td><a href="#hoodiefailwritesoninlinetableserviceexception">hoodie.fail.writes.on.inline.table.service.exception</a></td><td>true</td><td>Table services such as compaction and clustering can fail and prevent syncing to the metaclient. Set this to true to fail writes when table services fail<br><code>Config Param: FAIL_ON_INLINE_TABLE_SERVICE_EXCEPTION</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiefileidprefixproviderclass">hoodie.fileid.prefix.provider.class</a></td><td>org.apache.hudi.table.RandomFileIdPrefixProvider</td><td>File Id Prefix provider class, that implements <code>org.apache.hudi.fileid.FileIdPrefixProvider</code><br><code>Config Param: FILEID_PREFIX_PROVIDER_CLASS</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiefinalizewriteparallelism">hoodie.finalize.write.parallelism</a></td><td>200</td><td>Parallelism for the write finalization internal operation, which involves removing any partially written files from lake storage, before committing the write. Reduce this value, if the high number of tasks incur delays for smaller tables or low latency writes.<br><code>Config Param: FINALIZE_WRITE_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodieinsertshuffleparallelism">hoodie.insert.shuffle.parallelism</a></td><td>0</td><td>Parallelism for inserting records into the table. Inserts can shuffle data before writing to tune file sizes and optimize the storage layout. Before 0.13.0 release, if users do not configure it, Hudi would use 200 as the default shuffle parallelism. From 0.13.0 onwards Hudi by default automatically uses the parallelism deduced by Spark based on the source data. If the shuffle parallelism is explicitly configured by the user, the user-configured parallelism is used in defining the actual parallelism. If you observe small files from the insert operation, we suggest configuring this shuffle parallelism explicitly, so that the parallelism is around total_input_data_size/120MB.<br><code>Config Param: INSERT_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiemarkersdeleteparallelism">hoodie.markers.delete.parallelism</a></td><td>100</td><td>Determines the parallelism for deleting marker files, which are used to track all files (valid or invalid/partial) written during a write operation. Increase this value if delays are observed, with large batch writes.<br><code>Config Param: MARKERS_DELETE_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiemarkerstimeline_server_basedbatchinterval_ms">hoodie.markers.timeline_server_based.batch.interval_ms</a></td><td>50</td><td>The batch interval in milliseconds for marker creation batch processing<br><code>Config Param: MARKERS_TIMELINE_SERVER_BASED_BATCH_INTERVAL_MS</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodiemarkerstimeline_server_basedbatchnum_threads">hoodie.markers.timeline_server_based.batch.num_threads</a></td><td>20</td><td>Number of threads to use for batch processing marker creation requests at the timeline server<br><code>Config Param: MARKERS_TIMELINE_SERVER_BASED_BATCH_NUM_THREADS</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodiemergeallowduplicateoninserts">hoodie.merge.allow.duplicate.on.inserts</a></td><td>false</td><td>When enabled, we allow duplicate keys even if inserts are routed to merge with an existing file (for ensuring file sizing). This is only relevant for insert operation, since upsert, delete operations will ensure unique key constraints are maintained.<br><code>Config Param: MERGE_ALLOW_DUPLICATE_ON_INSERTS_ENABLE</code></td></tr><tr><td><a href="#hoodiemergedatavalidationenabled">hoodie.merge.data.validation.enabled</a></td><td>false</td><td>When enabled, data validation checks are performed during merges to ensure expected number of records after merge operation.<br><code>Config Param: MERGE_DATA_VALIDATION_CHECK_ENABLE</code></td></tr><tr><td><a href="#hoodiemergesmallfilegroupcandidateslimit">hoodie.merge.small.file.group.candidates.limit</a></td><td>1</td><td>Limits number of file groups, whose base file satisfies small-file limit, to consider for appending records during upsert operation. Only applicable to MOR tables<br><code>Config Param: MERGE_SMALL_FILE_GROUP_CANDIDATES_LIMIT</code></td></tr><tr><td><a href="#hoodiereleaseresourceoncompletionenable">hoodie.release.resource.on.completion.enable</a></td><td>true</td><td>Control to enable release all persist rdds when the spark job finish.<br><code>Config Param: RELEASE_RESOURCE_ENABLE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodierollbackinstantbackupdir">hoodie.rollback.instant.backup.dir</a></td><td>.rollback_backup</td><td>Path where instants being rolled back are copied. If not absolute path then a directory relative to .hoodie folder is created.<br><code>Config Param: ROLLBACK_INSTANT_BACKUP_DIRECTORY</code></td></tr><tr><td><a href="#hoodierollbackinstantbackupenabled">hoodie.rollback.instant.backup.enabled</a></td><td>false</td><td>Backup instants removed during rollback and restore (useful for debugging)<br><code>Config Param: ROLLBACK_INSTANT_BACKUP_ENABLED</code></td></tr><tr><td><a href="#hoodierollbackparallelism">hoodie.rollback.parallelism</a></td><td>100</td><td>This config controls the parallelism for rollback of commits. Rollbacks perform deletion of files or logging delete blocks to file groups on storage in parallel. The configure value limits the parallelism so that the number of Spark tasks do not exceed the value. If rollback is slow due to the limited parallelism, you can increase this to tune the performance.<br><code>Config Param: ROLLBACK_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodierollbackusingmarkers">hoodie.rollback.using.markers</a></td><td>true</td><td>Enables a more efficient mechanism for rollbacks based on the marker files generated during the writes. Turned on by default.<br><code>Config Param: ROLLBACK_USING_MARKERS_ENABLE</code></td></tr><tr><td><a href="#hoodieschemacacheenable">hoodie.schema.cache.enable</a></td><td>false</td><td>cache query internalSchemas in driver/executor side<br><code>Config Param: ENABLE_INTERNAL_SCHEMA_CACHE</code></td></tr><tr><td><a href="#hoodiesensitiveconfigkeys">hoodie.sensitive.config.keys</a></td><td>ssl,tls,sasl,auth,credentials</td><td>Comma separated list of filters for sensitive config keys. Hudi Streamer will not print any configuration which contains the configured filter. For example with a configured filter <code>ssl</code>, value for config <code>ssl.trustore.location</code> would be masked.<br><code>Config Param: SENSITIVE_CONFIG_KEYS_FILTER</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodieskipdefaultpartitionvalidation">hoodie.skip.default.partition.validation</a></td><td>false</td><td>When table is upgraded from pre 0.12 to 0.12, we check for &quot;default&quot; partition and fail if found one. Users are expected to rewrite the data in those partitions. Enabling this config will bypass this validation<br><code>Config Param: SKIP_DEFAULT_PARTITION_VALIDATION</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#hoodietablebasefileformat">hoodie.table.base.file.format</a></td><td>PARQUET</td><td>File format to store all the base file data. org.apache.hudi.common.model.HoodieFileFormat: Hoodie file formats.     PARQUET(default): Apache Parquet is an open source, column-oriented data file format designed for efficient data storage and retrieval. It provides efficient data compression and encoding schemes with enhanced performance to handle complex data in bulk.     HFILE: (internal config) File format for metadata table. A file of sorted key/value pairs. Both keys and values are byte arrays.     ORC: The Optimized Row Columnar (ORC) file format provides a highly efficient way to store Hive data. It was designed to overcome limitations of the other Hive file formats. Using ORC files improves performance when Hive is reading, writing, and processing data.<br><code>Config Param: BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodietableservicesenabled">hoodie.table.services.enabled</a></td><td>true</td><td>Master control to disable all table services including archive, clean, compact, cluster, etc.<br><code>Config Param: TABLE_SERVICES_ENABLED</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodietimelinelayoutversion">hoodie.timeline.layout.version</a></td><td>1</td><td>Controls the layout of the timeline. Version 0 relied on renames, Version 1 (default) models the timeline as an immutable log relying only on atomic writes for object storage.<br><code>Config Param: TIMELINE_LAYOUT_VERSION_NUM</code><br><code>Since Version: 0.5.1</code></td></tr><tr><td><a href="#hoodieupsertshuffleparallelism">hoodie.upsert.shuffle.parallelism</a></td><td>0</td><td>Parallelism to use for upsert operation on the table. Upserts can shuffle data to perform index lookups, file sizing, bin packing records optimally into file groups. Before 0.13.0 release, if users do not configure it, Hudi would use 200 as the default shuffle parallelism. From 0.13.0 onwards Hudi by default automatically uses the parallelism deduced by Spark based on the source data. If the shuffle parallelism is explicitly configured by the user, the user-configured parallelism is used in defining the actual parallelism. If you observe small files from the upsert operation, we suggest configuring this shuffle parallelism explicitly, so that the parallelism is around total_input_data_size/120MB.<br><code>Config Param: UPSERT_PARALLELISM_VALUE</code></td></tr><tr><td><a href="#hoodiewritebufferlimitbytes">hoodie.write.buffer.limit.bytes</a></td><td>4194304</td><td>Size of in-memory buffer used for parallelizing network reads and lake storage writes.<br><code>Config Param: WRITE_BUFFER_LIMIT_BYTES_VALUE</code></td></tr><tr><td><a href="#hoodiewriteconcurrencyasyncconflictdetectorinitial_delay_ms">hoodie.write.concurrency.async.conflict.detector.initial_delay_ms</a></td><td>0</td><td>Used for timeline-server-based markers with <code>AsyncTimelineServerBasedDetectionStrategy</code>. The time in milliseconds to delay the first execution of async marker-based conflict detection.<br><code>Config Param: ASYNC_CONFLICT_DETECTOR_INITIAL_DELAY_MS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteconcurrencyasyncconflictdetectorperiod_ms">hoodie.write.concurrency.async.conflict.detector.period_ms</a></td><td>30000</td><td>Used for timeline-server-based markers with <code>AsyncTimelineServerBasedDetectionStrategy</code>. The period in milliseconds between successive executions of async marker-based conflict detection.<br><code>Config Param: ASYNC_CONFLICT_DETECTOR_PERIOD_MS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteconcurrencyearlyconflictcheckcommitconflict">hoodie.write.concurrency.early.conflict.check.commit.conflict</a></td><td>false</td><td>Whether to enable commit conflict checking or not during early conflict detection.<br><code>Config Param: EARLY_CONFLICT_DETECTION_CHECK_COMMIT_CONFLICT</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteconcurrencyearlyconflictdetectionenable">hoodie.write.concurrency.early.conflict.detection.enable</a></td><td>false</td><td>Whether to enable early conflict detection based on markers. It eagerly detects writing conflict before create markers and fails fast if a conflict is detected, to release cluster compute resources as soon as possible.<br><code>Config Param: EARLY_CONFLICT_DETECTION_ENABLE</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteconcurrencyearlyconflictdetectionstrategy">hoodie.write.concurrency.early.conflict.detection.strategy</a></td><td></td><td>The class name of the early conflict detection strategy to use. This should be a subclass of <code>org.apache.hudi.common.conflict.detection.EarlyConflictDetectionStrategy</code>.<br><code>Config Param: EARLY_CONFLICT_DETECTION_STRATEGY_CLASS_NAME</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteexecutordisruptorbufferlimitbytes">hoodie.write.executor.disruptor.buffer.limit.bytes</a></td><td>1024</td><td>The size of the Disruptor Executor ring buffer, must be power of 2<br><code>Config Param: WRITE_EXECUTOR_DISRUPTOR_BUFFER_LIMIT_BYTES</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteexecutordisruptorwaitstrategy">hoodie.write.executor.disruptor.wait.strategy</a></td><td>BLOCKING_WAIT</td><td>org.apache.hudi.common.util.queue.DisruptorWaitStrategyType: Strategy employed for making Disruptor Executor wait on a cursor.     BLOCKING_WAIT(default): The slowest of the available wait strategies. However, it is the most conservative with the respect to CPU usage and will give the most consistent behaviour across the widest variety of deployment options.     SLEEPING_WAIT: Like the <code>BLOCKING_WAIT</code> strategy, it attempts to be conservative with CPU usage by using a simple busy wait loop. The difference is that the <code>SLEEPING_WAIT</code> strategy uses a call to <code>LockSupport.parkNanos(1)</code> in the middle of the loop. On a typical Linux system this will pause the thread for around 60µs.     YIELDING_WAIT: The <code>YIELDING_WAIT</code> strategy is one of two wait strategy that can be used in low-latency systems. It is designed for cases where there is an opportunity to burn CPU cycles with the goal of improving latency. The <code>YIELDING_WAIT</code> strategy will busy spin, waiting for the sequence to increment to the appropriate value. Inside the body of the loop <code>Thread#yield()</code> will be called allowing other queued threads to run. This is the recommended wait strategy when you need very high performance, and the number of <code>EventHandler</code> threads is lower than the total number of logical cores, such as when hyper-threading is enabled.     BUSY_SPIN_WAIT: The <code>BUSY_SPIN_WAIT</code> strategy is the highest performing wait strategy. Like the <code>YIELDING_WAIT</code> strategy, it can be used in low-latency systems, but puts the highest constraints on the deployment environment.<br><code>Config Param: WRITE_EXECUTOR_DISRUPTOR_WAIT_STRATEGY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewriteexecutortype">hoodie.write.executor.type</a></td><td>SIMPLE</td><td>org.apache.hudi.common.util.queue.ExecutorType: Types of executor that implements org.apache.hudi.common.util.queue.HoodieExecutor. The executor orchestrates concurrent producers and consumers communicating through a message queue.     BOUNDED_IN_MEMORY: Executor which orchestrates concurrent producers and consumers communicating through a bounded in-memory message queue using LinkedBlockingQueue. This queue will use extra lock to balance producers and consumers.     DISRUPTOR: Executor which orchestrates concurrent producers and consumers communicating through disruptor as a lock free message queue to gain better writing performance. Although DisruptorExecutor is still an experimental feature.     SIMPLE(default): Executor with no inner message queue and no inner lock. Consuming and writing records from iterator directly. The advantage is that there is no need for additional memory and cpu resources due to lock or multithreading. The disadvantage is that the executor is a single-write-single-read model, cannot support functions such as speed limit and can not de-couple the network read (shuffle read) and network write (writing objects/files to storage) anymore.<br><code>Config Param: WRITE_EXECUTOR_TYPE</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiewritemarkerstype">hoodie.write.markers.type</a></td><td>TIMELINE_SERVER_BASED</td><td>org.apache.hudi.common.table.marker.MarkerType: Marker type indicating how markers are stored in the file system, used for identifying the files written and cleaning up files not committed which should be deleted.     DIRECT: Individual marker file corresponding to each data file is directly created by the writer.     TIMELINE_SERVER_BASED(default): Marker operations are all handled at the timeline service which serves as a proxy. New marker entries are batch processed and stored in a limited number of underlying files for efficiency. If HDFS is used or timeline server is disabled, DIRECT markers are used as fallback even if this is configured. This configuration does not take effect for Spark structured streaming; DIRECT markers are always used.<br><code>Config Param: MARKERS_TYPE</code><br><code>Since Version: 0.9.0</code></td></tr><tr><td><a href="#hoodiewritenumretriesonconflictfailures">hoodie.write.num.retries.on.conflict.failures</a></td><td>0</td><td>Maximum number of times to retry a batch on conflict failure.<br><code>Config Param: NUM_RETRIES_ON_CONFLICT_FAILURES</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiewritestatusstoragelevel">hoodie.write.status.storage.level</a></td><td>MEMORY_AND_DISK_SER</td><td>Write status objects hold metadata about a write (stats, errors), that is not yet committed to storage. This controls the how that information is cached for inspection by clients. We rarely expect this to be changed.<br><code>Config Param: WRITE_STATUS_STORAGE_LEVEL_VALUE</code></td></tr><tr><td><a href="#hoodiewritetaggedrecordstoragelevel">hoodie.write.tagged.record.storage.level</a></td><td>MEMORY_AND_DISK_SER</td><td>Determine what level of persistence is used to cache write RDDs. Refer to org.apache.spark.storage.StorageLevel for different values<br><code>Config Param: TAGGED_RECORD_STORAGE_LEVEL_VALUE</code></td></tr><tr><td><a href="#hoodiewritestatusclass">hoodie.writestatus.class</a></td><td>org.apache.hudi.client.WriteStatus</td><td>Subclass of org.apache.hudi.client.WriteStatus to be used to collect information about a write. Can be overridden to collection additional metrics/statistics about the data if needed.<br><code>Config Param: WRITE_STATUS_CLASS_NAME</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="COMMIT_CALLBACK">Commit Callback Configs<a class="hash-link" href="#COMMIT_CALLBACK" title="Direct link to heading">​</a></h3><p>Configurations controlling callback behavior into HTTP endpoints, to push notifications on commits on hudi tables.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Write-commit-callback-configs">Write commit callback configs<a class="hash-link" href="#Write-commit-callback-configs" title="Direct link to heading">​</a></h4><p><a href="#Write-commit-callback-configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiewritecommitcallbackhttpurl">hoodie.write.commit.callback.http.url</a></td><td>(N/A)</td><td>Callback host to be sent along with callback messages<br><code>Config Param: CALLBACK_HTTP_URL</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackclass">hoodie.write.commit.callback.class</a></td><td>org.apache.hudi.callback.impl.HoodieWriteCommitHttpCallback</td><td>Full path of callback class and must be a subclass of HoodieWriteCommitCallback class, org.apache.hudi.callback.impl.HoodieWriteCommitHttpCallback by default<br><code>Config Param: CALLBACK_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackhttpapikey">hoodie.write.commit.callback.http.api.key</a></td><td>hudi_write_commit_http_callback</td><td>Http callback API key. hudi_write_commit_http_callback by default<br><code>Config Param: CALLBACK_HTTP_API_KEY_VALUE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackhttptimeoutseconds">hoodie.write.commit.callback.http.timeout.seconds</a></td><td>30</td><td>Callback timeout in seconds.<br><code>Config Param: CALLBACK_HTTP_TIMEOUT_IN_SECONDS</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackon">hoodie.write.commit.callback.on</a></td><td>false</td><td>Turn commit callback on/off. off by default.<br><code>Config Param: TURN_CALLBACK_ON</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Write-commit-Kafka-callback-configs">Write commit Kafka callback configs<a class="hash-link" href="#Write-commit-Kafka-callback-configs" title="Direct link to heading">​</a></h4><p>Controls notifications sent to Kafka, on events happening to a hudi table.</p><p><a href="#Write-commit-Kafka-callback-configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiewritecommitcallbackkafkabootstrapservers">hoodie.write.commit.callback.kafka.bootstrap.servers</a></td><td>(N/A)</td><td>Bootstrap servers of kafka cluster, to be used for publishing commit metadata.<br><code>Config Param: BOOTSTRAP_SERVERS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackkafkapartition">hoodie.write.commit.callback.kafka.partition</a></td><td>(N/A)</td><td>It may be desirable to serialize all changes into a single Kafka partition  for providing strict ordering. By default, Kafka messages are keyed by table name, which  guarantees ordering at the table level, but not globally (or when new partitions are added)<br><code>Config Param: PARTITION</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackkafkatopic">hoodie.write.commit.callback.kafka.topic</a></td><td>(N/A)</td><td>Kafka topic name to publish timeline activity into.<br><code>Config Param: TOPIC</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackkafkaacks">hoodie.write.commit.callback.kafka.acks</a></td><td>all</td><td>kafka acks level, all by default to ensure strong durability.<br><code>Config Param: ACKS</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackkafkaretries">hoodie.write.commit.callback.kafka.retries</a></td><td>3</td><td>Times to retry the produce. 3 by default<br><code>Config Param: RETRIES</code><br><code>Since Version: 0.7.0</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Write-commit-pulsar-callback-configs">Write commit pulsar callback configs<a class="hash-link" href="#Write-commit-pulsar-callback-configs" title="Direct link to heading">​</a></h4><p>Controls notifications sent to pulsar, on events happening to a hudi table.</p><p><a href="#Write-commit-pulsar-callback-configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiewritecommitcallbackpulsarbrokerserviceurl">hoodie.write.commit.callback.pulsar.broker.service.url</a></td><td>(N/A)</td><td>Server&#x27;s url of pulsar cluster, to be used for publishing commit metadata.<br><code>Config Param: BROKER_SERVICE_URL</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsartopic">hoodie.write.commit.callback.pulsar.topic</a></td><td>(N/A)</td><td>pulsar topic name to publish timeline activity into.<br><code>Config Param: TOPIC</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarconnection-timeout">hoodie.write.commit.callback.pulsar.connection-timeout</a></td><td>10s</td><td>Duration of waiting for a connection to a broker to be established.<br><code>Config Param: CONNECTION_TIMEOUT</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarkeepalive-interval">hoodie.write.commit.callback.pulsar.keepalive-interval</a></td><td>30s</td><td>Duration of keeping alive interval for each client broker connection.<br><code>Config Param: KEEPALIVE_INTERVAL</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsaroperation-timeout">hoodie.write.commit.callback.pulsar.operation-timeout</a></td><td>30s</td><td>Duration of waiting for completing an operation.<br><code>Config Param: OPERATION_TIMEOUT</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarproducerblock-if-queue-full">hoodie.write.commit.callback.pulsar.producer.block-if-queue-full</a></td><td>true</td><td>When the queue is full, the method is blocked instead of an exception is thrown.<br><code>Config Param: PRODUCER_BLOCK_QUEUE_FULL</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarproducerpending-queue-size">hoodie.write.commit.callback.pulsar.producer.pending-queue-size</a></td><td>1000</td><td>The maximum size of a queue holding pending messages.<br><code>Config Param: PRODUCER_PENDING_QUEUE_SIZE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarproducerpending-total-size">hoodie.write.commit.callback.pulsar.producer.pending-total-size</a></td><td>50000</td><td>The maximum number of pending messages across partitions.<br><code>Config Param: PRODUCER_PENDING_SIZE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarproducerroute-mode">hoodie.write.commit.callback.pulsar.producer.route-mode</a></td><td>RoundRobinPartition</td><td>Message routing logic for producers on partitioned topics.<br><code>Config Param: PRODUCER_ROUTE_MODE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarproducersend-timeout">hoodie.write.commit.callback.pulsar.producer.send-timeout</a></td><td>30s</td><td>The timeout in each sending to pulsar.<br><code>Config Param: PRODUCER_SEND_TIMEOUT</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiewritecommitcallbackpulsarrequest-timeout">hoodie.write.commit.callback.pulsar.request-timeout</a></td><td>60s</td><td>Duration of waiting for completing a request.<br><code>Config Param: REQUEST_TIMEOUT</code><br><code>Since Version: 0.11.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="LOCK">Lock Configs<a class="hash-link" href="#LOCK" title="Direct link to heading">​</a></h3><p>Configurations that control locking mechanisms required for concurrency control  between writers to a Hudi table. Concurrency between Hudi&#x27;s own table services  are auto managed internally.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Common-Lock-Configurations">Common Lock Configurations<a class="hash-link" href="#Common-Lock-Configurations" title="Direct link to heading">​</a></h4><p><a href="#Common-Lock-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiewritelockfilesystempath">hoodie.write.lock.filesystem.path</a></td><td>(N/A)</td><td>For DFS based lock providers, path to store the locks under. use Table&#x27;s meta path as default<br><code>Config Param: FILESYSTEM_LOCK_PATH</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockhivemetastoredatabase">hoodie.write.lock.hivemetastore.database</a></td><td>(N/A)</td><td>For Hive based lock provider, the Hive database to acquire lock against<br><code>Config Param: HIVE_DATABASE_NAME</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockhivemetastoretable">hoodie.write.lock.hivemetastore.table</a></td><td>(N/A)</td><td>For Hive based lock provider, the Hive table to acquire lock against<br><code>Config Param: HIVE_TABLE_NAME</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockhivemetastoreuris">hoodie.write.lock.hivemetastore.uris</a></td><td>(N/A)</td><td>For Hive based lock provider, the Hive metastore URI to acquire locks against.<br><code>Config Param: HIVE_METASTORE_URI</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeeperbase_path">hoodie.write.lock.zookeeper.base_path</a></td><td>(N/A)</td><td>The base path on Zookeeper under which to create lock related ZNodes. This should be same for all concurrent writers to the same table<br><code>Config Param: ZK_BASE_PATH</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeeperport">hoodie.write.lock.zookeeper.port</a></td><td>(N/A)</td><td>Zookeeper port to connect to.<br><code>Config Param: ZK_PORT</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeeperurl">hoodie.write.lock.zookeeper.url</a></td><td>(N/A)</td><td>Zookeeper URL to connect to.<br><code>Config Param: ZK_CONNECT_URL</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockclientnum_retries">hoodie.write.lock.client.num_retries</a></td><td>50</td><td>Maximum number of times to retry to acquire lock additionally from the lock manager.<br><code>Config Param: LOCK_ACQUIRE_CLIENT_NUM_RETRIES</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockclientwait_time_ms_between_retry">hoodie.write.lock.client.wait_time_ms_between_retry</a></td><td>5000</td><td>Amount of time to wait between retries on the lock provider by the lock manager<br><code>Config Param: LOCK_ACQUIRE_CLIENT_RETRY_WAIT_TIME_IN_MILLIS</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockconflictresolutionstrategy">hoodie.write.lock.conflict.resolution.strategy</a></td><td>org.apache.hudi.client.transaction.SimpleConcurrentFileWritesConflictResolutionStrategy</td><td>Lock provider class name, this should be subclass of org.apache.hudi.client.transaction.ConflictResolutionStrategy<br><code>Config Param: WRITE_CONFLICT_RESOLUTION_STRATEGY_CLASS_NAME</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockfilesystemexpire">hoodie.write.lock.filesystem.expire</a></td><td>0</td><td>For DFS based lock providers, expire time in minutes, must be a non-negative number, default means no expire<br><code>Config Param: FILESYSTEM_LOCK_EXPIRE</code><br><code>Since Version: 0.12.0</code></td></tr><tr><td><a href="#hoodiewritelockmax_wait_time_ms_between_retry">hoodie.write.lock.max_wait_time_ms_between_retry</a></td><td>16000</td><td>Maximum amount of time to wait between retries by lock provider client. This bounds the maximum delay from the exponential backoff. Currently used by ZK based lock provider only.<br><code>Config Param: LOCK_ACQUIRE_RETRY_MAX_WAIT_TIME_IN_MILLIS</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelocknum_retries">hoodie.write.lock.num_retries</a></td><td>15</td><td>Maximum number of times to retry lock acquire, at each lock provider<br><code>Config Param: LOCK_ACQUIRE_NUM_RETRIES</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockprovider">hoodie.write.lock.provider</a></td><td>org.apache.hudi.client.transaction.lock.ZookeeperBasedLockProvider</td><td>Lock provider class name, user can provide their own implementation of LockProvider which should be subclass of org.apache.hudi.common.lock.LockProvider<br><code>Config Param: LOCK_PROVIDER_CLASS_NAME</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockwait_time_ms">hoodie.write.lock.wait_time_ms</a></td><td>60000</td><td>Timeout in ms, to wait on an individual lock acquire() call, at the lock provider.<br><code>Config Param: LOCK_ACQUIRE_WAIT_TIMEOUT_MS</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockwait_time_ms_between_retry">hoodie.write.lock.wait_time_ms_between_retry</a></td><td>1000</td><td>Initial amount of time to wait between retries to acquire locks,  subsequent retries will exponentially backoff.<br><code>Config Param: LOCK_ACQUIRE_RETRY_WAIT_TIME_IN_MILLIS</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeeperconnection_timeout_ms">hoodie.write.lock.zookeeper.connection_timeout_ms</a></td><td>15000</td><td>Timeout in ms, to wait for establishing connection with Zookeeper.<br><code>Config Param: ZK_CONNECTION_TIMEOUT_MS</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeeperlock_key">hoodie.write.lock.zookeeper.lock_key</a></td><td></td><td>Key name under base_path at which to create a ZNode and acquire lock. Final path on zk will look like base_path/lock_key. If this parameter is not set, we would set it as the table name<br><code>Config Param: ZK_LOCK_KEY</code><br><code>Since Version: 0.8.0</code></td></tr><tr><td><a href="#hoodiewritelockzookeepersession_timeout_ms">hoodie.write.lock.zookeeper.session_timeout_ms</a></td><td>60000</td><td>Timeout in ms, to wait after losing connection to ZooKeeper, before the session is expired<br><code>Config Param: ZK_SESSION_TIMEOUT_MS</code><br><code>Since Version: 0.8.0</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="DynamoDB-based-Locks-Configurations">DynamoDB based Locks Configurations<a class="hash-link" href="#DynamoDB-based-Locks-Configurations" title="Direct link to heading">​</a></h4><p>Configs that control DynamoDB based locking mechanisms required for concurrency control  between writers to a Hudi table. Concurrency between Hudi&#x27;s own table services  are auto managed internally.</p><p><a href="#DynamoDB-based-Locks-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiewritelockdynamodbendpoint_url">hoodie.write.lock.dynamodb.endpoint_url</a></td><td>(N/A)</td><td>For DynamoDB based lock provider, the url endpoint used for Amazon DynamoDB service. Useful for development with a local dynamodb instance.<br><code>Config Param: DYNAMODB_ENDPOINT_URL</code><br><code>Since Version: 0.10.1</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbbilling_mode">hoodie.write.lock.dynamodb.billing_mode</a></td><td>PAY_PER_REQUEST</td><td>For DynamoDB based lock provider, by default it is <code>PAY_PER_REQUEST</code> mode. Alternative is <code>PROVISIONED</code>.<br><code>Config Param: DYNAMODB_LOCK_BILLING_MODE</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbpartition_key">hoodie.write.lock.dynamodb.partition_key</a></td><td></td><td>For DynamoDB based lock provider, the partition key for the DynamoDB lock table. Each Hudi dataset should has it&#x27;s unique key so concurrent writers could refer to the same partition key. By default we use the Hudi table name specified to be the partition key<br><code>Config Param: DYNAMODB_LOCK_PARTITION_KEY</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbread_capacity">hoodie.write.lock.dynamodb.read_capacity</a></td><td>20</td><td>For DynamoDB based lock provider, read capacity units when using PROVISIONED billing mode<br><code>Config Param: DYNAMODB_LOCK_READ_CAPACITY</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbregion">hoodie.write.lock.dynamodb.region</a></td><td>us-east-1</td><td>For DynamoDB based lock provider, the region used in endpoint for Amazon DynamoDB service. Would try to first get it from AWS_REGION environment variable. If not find, by default use us-east-1<br><code>Config Param: DYNAMODB_LOCK_REGION</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbtable">hoodie.write.lock.dynamodb.table</a></td><td>hudi_locks</td><td>For DynamoDB based lock provider, the name of the DynamoDB table acting as lock table<br><code>Config Param: DYNAMODB_LOCK_TABLE_NAME</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbtable_creation_timeout">hoodie.write.lock.dynamodb.table_creation_timeout</a></td><td>120000</td><td>For DynamoDB based lock provider, the maximum number of milliseconds to wait for creating DynamoDB table<br><code>Config Param: DYNAMODB_LOCK_TABLE_CREATION_TIMEOUT</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockdynamodbwrite_capacity">hoodie.write.lock.dynamodb.write_capacity</a></td><td>10</td><td>For DynamoDB based lock provider, write capacity units when using PROVISIONED billing mode<br><code>Config Param: DYNAMODB_LOCK_WRITE_CAPACITY</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiewritelockwait_time_ms">hoodie.write.lock.wait_time_ms</a></td><td>60000</td><td>Lock Acquire Wait Timeout in milliseconds<br><code>Config Param: LOCK_ACQUIRE_WAIT_TIMEOUT_MS_PROP_KEY</code><br><code>Since Version: 0.10.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="KEY_GENERATOR">Key Generator Configs<a class="hash-link" href="#KEY_GENERATOR" title="Direct link to heading">​</a></h3><p>Hudi maintains keys (record key + partition path) for uniquely identifying a particular record. These configs allow developers to setup the Key generator class that extracts these out of incoming records.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Key-Generator-Options">Key Generator Options<a class="hash-link" href="#Key-Generator-Options" title="Direct link to heading">​</a></h4><p><a href="#Key-Generator-Options-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcewritepartitionpathfield">hoodie.datasource.write.partitionpath.field</a></td><td>(N/A)</td><td>Partition path field. Value to be used at the partitionPath component of HoodieKey. Actual value obtained by invoking .toString()<br><code>Config Param: PARTITIONPATH_FIELD_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewriterecordkeyfield">hoodie.datasource.write.recordkey.field</a></td><td>(N/A)</td><td>Record key field. Value to be used as the <code>recordKey</code> component of <code>HoodieKey</code>. Actual value will be obtained by invoking .toString() on the field value. Nested fields can be specified using the dot notation eg: <code>a.b.c</code><br><code>Config Param: RECORDKEY_FIELD_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcewritehive_style_partitioning">hoodie.datasource.write.hive_style_partitioning</a></td><td>false</td><td>Flag to indicate whether to use Hive style partitioning. If set true, the names of partition folders follow <!-- -->&lt;<!-- -->partition_column_name<!-- -->&gt;<!-- -->=<!-- -->&lt;<!-- -->partition_value<!-- -->&gt;<!-- --> format. By default false (the names of partition folders are only partition values)<br><code>Config Param: HIVE_STYLE_PARTITIONING_ENABLE</code></td></tr></tbody></table><p><a href="#Key-Generator-Options-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcewritekeygeneratorconsistentlogicaltimestampenabled">hoodie.datasource.write.keygenerator.consistent.logical.timestamp.enabled</a></td><td>false</td><td>When set to true, consistent value will be generated for a logical timestamp type column, like timestamp-millis and timestamp-micros, irrespective of whether row-writer is enabled. Disabled by default so as not to break the pipeline that deploy either fully row-writer path or non row-writer path. For example, if it is kept disabled then record key of timestamp type with value <code>2016-12-29 09:54:00</code> will be written as timestamp <code>2016-12-29 09:54:00.0</code> in row-writer path, while it will be written as long value <code>1483023240000000</code> in non row-writer path. If enabled, then the timestamp value will be written in both the cases.<br><code>Config Param: KEYGENERATOR_CONSISTENT_LOGICAL_TIMESTAMP_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcewritepartitionpathurlencode">hoodie.datasource.write.partitionpath.urlencode</a></td><td>false</td><td>Should we url encode the partition path value, before creating the folder structure.<br><code>Config Param: URL_ENCODE_PARTITIONING</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="INDEX">Index Configs<a class="hash-link" href="#INDEX" title="Direct link to heading">​</a></h3><p>Configurations that control indexing behavior, which tags incoming records as either inserts or updates to older records.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Common-Index-Configs">Common Index Configs<a class="hash-link" href="#Common-Index-Configs" title="Direct link to heading">​</a></h4><p><a href="#Common-Index-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieindextype">hoodie.index.type</a></td><td>(N/A)</td><td>org.apache.hudi.index.HoodieIndex$IndexType: Determines how input records are indexed, i.e., looked up based on the key for the location in the existing table. Default is SIMPLE on Spark engine, and INMEMORY on Flink and Java engines.     HBASE: uses an external managed Apache HBase table to store record key to location mapping. HBase index is a global index, enforcing key uniqueness across all partitions in the table.     INMEMORY: Uses in-memory hashmap in Spark and Java engine and Flink in-memory state in Flink for indexing.     BLOOM: Employs bloom filters built out of the record keys, optionally also pruning candidate files using record key ranges. Key uniqueness is enforced inside partitions.     GLOBAL_BLOOM: Employs bloom filters built out of the record keys, optionally also pruning candidate files using record key ranges. Key uniqueness is enforced across all partitions in the table.      SIMPLE: Performs a lean join of the incoming update/delete records against keys extracted from the table on storage.Key uniqueness is enforced inside partitions.     GLOBAL_SIMPLE: Performs a lean join of the incoming update/delete records against keys extracted from the table on storage.Key uniqueness is enforced across all partitions in the table.     BUCKET: locates the file group containing the record fast by using bucket hashing, particularly beneficial in large scale. Use <code>hoodie.index.bucket.engine</code> to choose bucket engine type, i.e., how buckets are generated.     FLINK_STATE: Internal Config for indexing based on Flink state.     RECORD_INDEX: Index which saves the record key to location mappings in the HUDI Metadata Table. Record index is a global index, enforcing key uniqueness across all partitions in the table. Supports sharding to achieve very high scale.<br><code>Config Param: INDEX_TYPE</code></td></tr></tbody></table><p><a href="#Common-Index-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiebucketindexhashfield">hoodie.bucket.index.hash.field</a></td><td>(N/A)</td><td>Index key. It is used to index the record and find its file group. If not set, use record key field as default<br><code>Config Param: BUCKET_INDEX_HASH_FIELD</code></td></tr><tr><td><a href="#hoodiebucketindexmaxnumbuckets">hoodie.bucket.index.max.num.buckets</a></td><td>(N/A)</td><td>Only applies if bucket index engine is consistent hashing. Determine the upper bound of the number of buckets in the hudi table. Bucket resizing cannot be done higher than this max limit.<br><code>Config Param: BUCKET_INDEX_MAX_NUM_BUCKETS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiebucketindexminnumbuckets">hoodie.bucket.index.min.num.buckets</a></td><td>(N/A)</td><td>Only applies if bucket index engine is consistent hashing. Determine the lower bound of the number of buckets in the hudi table. Bucket resizing cannot be done lower than this min limit.<br><code>Config Param: BUCKET_INDEX_MIN_NUM_BUCKETS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiebloomindexbucketizedchecking">hoodie.bloom.index.bucketized.checking</a></td><td>true</td><td>Only applies if index type is BLOOM. When true, bucketized bloom filtering is enabled. This reduces skew seen in sort based bloom index lookup<br><code>Config Param: BLOOM_INDEX_BUCKETIZED_CHECKING</code></td></tr><tr><td><a href="#hoodiebloomindexinputstoragelevel">hoodie.bloom.index.input.storage.level</a></td><td>MEMORY_AND_DISK_SER</td><td>Only applies when #bloomIndexUseCaching is set. Determine what level of persistence is used to cache input RDDs. Refer to org.apache.spark.storage.StorageLevel for different values<br><code>Config Param: BLOOM_INDEX_INPUT_STORAGE_LEVEL_VALUE</code></td></tr><tr><td><a href="#hoodiebloomindexkeysperbucket">hoodie.bloom.index.keys.per.bucket</a></td><td>10000000</td><td>Only applies if bloomIndexBucketizedChecking is enabled and index type is bloom. This configuration controls the “bucket” size which tracks the number of record-key checks made against a single file and is the unit of work allocated to each partition performing bloom filter lookup. A higher value would amortize the fixed cost of reading a bloom filter to memory.<br><code>Config Param: BLOOM_INDEX_KEYS_PER_BUCKET</code></td></tr><tr><td><a href="#hoodiebloomindexparallelism">hoodie.bloom.index.parallelism</a></td><td>0</td><td>Only applies if index type is BLOOM. This is the amount of parallelism for index lookup, which involves a shuffle. By default, this is auto computed based on input workload characteristics. If the parallelism is explicitly configured by the user, the user-configured value is used in defining the actual parallelism. If the indexing stage is slow due to the limited parallelism, you can increase this to tune the performance.<br><code>Config Param: BLOOM_INDEX_PARALLELISM</code></td></tr><tr><td><a href="#hoodiebloomindexprunebyranges">hoodie.bloom.index.prune.by.ranges</a></td><td>true</td><td>Only applies if index type is BLOOM. When true, range information from files to leveraged speed up index lookups. Particularly helpful, if the key has a monotonously increasing prefix, such as timestamp. If the record key is completely random, it is better to turn this off, since range pruning will only  add extra overhead to the index lookup.<br><code>Config Param: BLOOM_INDEX_PRUNE_BY_RANGES</code></td></tr><tr><td><a href="#hoodiebloomindexupdatepartitionpath">hoodie.bloom.index.update.partition.path</a></td><td>true</td><td>Only applies if index type is GLOBAL_BLOOM. When set to true, an update including the partition path of a record that already exists will result in inserting the incoming record into the new partition and deleting the original record in the old partition. When set to false, the original record will only be updated in the old partition<br><code>Config Param: BLOOM_INDEX_UPDATE_PARTITION_PATH_ENABLE</code></td></tr><tr><td><a href="#hoodiebloomindexusecaching">hoodie.bloom.index.use.caching</a></td><td>true</td><td>Only applies if index type is BLOOM.When true, the input RDD will cached to speed up index lookup by reducing IO for computing parallelism or affected partitions<br><code>Config Param: BLOOM_INDEX_USE_CACHING</code></td></tr><tr><td><a href="#hoodiebloomindexusemetadata">hoodie.bloom.index.use.metadata</a></td><td>false</td><td>Only applies if index type is BLOOM.When true, the index lookup uses bloom filters and column stats from metadata table when available to speed up the process.<br><code>Config Param: BLOOM_INDEX_USE_METADATA</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodiebloomindexusetreebasedfilter">hoodie.bloom.index.use.treebased.filter</a></td><td>true</td><td>Only applies if index type is BLOOM. When true, interval tree based file pruning optimization is enabled. This mode speeds-up file-pruning based on key ranges when compared with the brute-force mode<br><code>Config Param: BLOOM_INDEX_TREE_BASED_FILTER</code></td></tr><tr><td><a href="#hoodiebucketindexmergethreshold">hoodie.bucket.index.merge.threshold</a></td><td>0.2</td><td>Control if buckets should be merged when using consistent hashing bucket indexSpecifically, if a file slice size is smaller than <code>hoodie.xxxx.max.file.size</code> * threshold, then it will be consideredas a merge candidate.<br><code>Config Param: BUCKET_MERGE_THRESHOLD</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiebucketindexnumbuckets">hoodie.bucket.index.num.buckets</a></td><td>256</td><td>Only applies if index type is BUCKET. Determine the number of buckets in the hudi table, and each partition is divided to N buckets.<br><code>Config Param: BUCKET_INDEX_NUM_BUCKETS</code></td></tr><tr><td><a href="#hoodiebucketindexsplitthreshold">hoodie.bucket.index.split.threshold</a></td><td>2.0</td><td>Control if the bucket should be split when using consistent hashing bucket index.Specifically, if a file slice size reaches <code>hoodie.xxxx.max.file.size</code> * threshold, then split will be carried out.<br><code>Config Param: BUCKET_SPLIT_THRESHOLD</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodieglobalindexreconcileparallelism">hoodie.global.index.reconcile.parallelism</a></td><td>60</td><td>Only applies if index type is GLOBAL_BLOOM or GLOBAL_SIMPLE. This controls the parallelism for deduplication during indexing where more than 1 record could be tagged due to partition update.<br><code>Config Param: GLOBAL_INDEX_RECONCILE_PARALLELISM</code></td></tr><tr><td><a href="#hoodieglobalsimpleindexparallelism">hoodie.global.simple.index.parallelism</a></td><td>100</td><td>Only applies if index type is GLOBAL_SIMPLE. This limits the parallelism of fetching records from the base files of all table partitions. The index picks the configured parallelism if the number of base files is larger than this configured value; otherwise, the number of base files is used as the parallelism. If the indexing stage is slow due to the limited parallelism, you can increase this to tune the performance.<br><code>Config Param: GLOBAL_SIMPLE_INDEX_PARALLELISM</code></td></tr><tr><td><a href="#hoodieindexbucketengine">hoodie.index.bucket.engine</a></td><td>SIMPLE</td><td>org.apache.hudi.index.HoodieIndex$BucketIndexEngineType: Determines the type of bucketing or hashing to use when <code>hoodie.index.type</code> is set to <code>BUCKET</code>.     SIMPLE(default): Uses a fixed number of buckets for file groups which cannot shrink or expand. This works for both COW and MOR tables.     CONSISTENT_HASHING: Supports dynamic number of buckets with bucket resizing to properly size each bucket. This solves potential data skew problem where one bucket can be significantly larger than others in SIMPLE engine type. This only works with MOR tables.<br><code>Config Param: BUCKET_INDEX_ENGINE_TYPE</code><br><code>Since Version: 0.11.0</code></td></tr><tr><td><a href="#hoodieindexclass">hoodie.index.class</a></td><td></td><td>Full path of user-defined index class and must be a subclass of HoodieIndex class. It will take precedence over the hoodie.index.type configuration if specified<br><code>Config Param: INDEX_CLASS_NAME</code></td></tr><tr><td><a href="#hoodierecordindexinputstoragelevel">hoodie.record.index.input.storage.level</a></td><td>MEMORY_AND_DISK_SER</td><td>Only applies when #recordIndexUseCaching is set. Determine what level of persistence is used to cache input RDDs. Refer to org.apache.spark.storage.StorageLevel for different values<br><code>Config Param: RECORD_INDEX_INPUT_STORAGE_LEVEL_VALUE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodierecordindexupdatepartitionpath">hoodie.record.index.update.partition.path</a></td><td>false</td><td>Similar to Key: &#x27;hoodie.bloom.index.update.partition.path&#x27; , default: true , isAdvanced: true , description: Only applies if index type is GLOBAL_BLOOM. When set to true, an update including the partition path of a record that already exists will result in inserting the incoming record into the new partition and deleting the original record in the old partition. When set to false, the original record will only be updated in the old partition since version: version is not defined deprecated after: version is not defined), but for record index.<br><code>Config Param: RECORD_INDEX_UPDATE_PARTITION_PATH_ENABLE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodierecordindexusecaching">hoodie.record.index.use.caching</a></td><td>true</td><td>Only applies if index type is RECORD_INDEX.When true, the input RDD will be cached to speed up index lookup by reducing IO for computing parallelism or affected partitions<br><code>Config Param: RECORD_INDEX_USE_CACHING</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiesimpleindexinputstoragelevel">hoodie.simple.index.input.storage.level</a></td><td>MEMORY_AND_DISK_SER</td><td>Only applies when #simpleIndexUseCaching is set. Determine what level of persistence is used to cache input RDDs. Refer to org.apache.spark.storage.StorageLevel for different values<br><code>Config Param: SIMPLE_INDEX_INPUT_STORAGE_LEVEL_VALUE</code></td></tr><tr><td><a href="#hoodiesimpleindexparallelism">hoodie.simple.index.parallelism</a></td><td>0</td><td>Only applies if index type is SIMPLE. This limits the parallelism of fetching records from the base files of affected partitions. By default, this is auto computed based on input workload characteristics. If the parallelism is explicitly configured by the user, the user-configured value is used in defining the actual parallelism. If the indexing stage is slow due to the limited parallelism, you can increase this to tune the performance.<br><code>Config Param: SIMPLE_INDEX_PARALLELISM</code></td></tr><tr><td><a href="#hoodiesimpleindexupdatepartitionpath">hoodie.simple.index.update.partition.path</a></td><td>true</td><td>Similar to Key: &#x27;hoodie.bloom.index.update.partition.path&#x27; , default: true , isAdvanced: true , description: Only applies if index type is GLOBAL_BLOOM. When set to true, an update including the partition path of a record that already exists will result in inserting the incoming record into the new partition and deleting the original record in the old partition. When set to false, the original record will only be updated in the old partition since version: version is not defined deprecated after: version is not defined), but for simple index.<br><code>Config Param: SIMPLE_INDEX_UPDATE_PARTITION_PATH_ENABLE</code></td></tr><tr><td><a href="#hoodiesimpleindexusecaching">hoodie.simple.index.use.caching</a></td><td>true</td><td>Only applies if index type is SIMPLE. When true, the incoming writes will cached to speed up index lookup by reducing IO for computing parallelism or affected partitions<br><code>Config Param: SIMPLE_INDEX_USE_CACHING</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="HBase-Index-Configs">HBase Index Configs<a class="hash-link" href="#HBase-Index-Configs" title="Direct link to heading">​</a></h4><p>Configurations that control indexing behavior (when HBase based indexing is enabled), which tags incoming records as either inserts or updates to older records.</p><p><a href="#HBase-Index-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieindexhbasekerberosuserkeytab">hoodie.index.hbase.kerberos.user.keytab</a></td><td>(N/A)</td><td>File name of the kerberos keytab file for connecting to the hbase cluster.<br><code>Config Param: KERBEROS_USER_KEYTAB</code></td></tr><tr><td><a href="#hoodieindexhbasekerberosuserprincipal">hoodie.index.hbase.kerberos.user.principal</a></td><td>(N/A)</td><td>The kerberos principal name for connecting to the hbase cluster.<br><code>Config Param: KERBEROS_USER_PRINCIPAL</code></td></tr><tr><td><a href="#hoodieindexhbasemasterkerberosprincipal">hoodie.index.hbase.master.kerberos.principal</a></td><td>(N/A)</td><td>The value of hbase.master.kerberos.principal in hbase cluster.<br><code>Config Param: MASTER_PRINCIPAL</code></td></tr><tr><td><a href="#hoodieindexhbasemaxqpsfraction">hoodie.index.hbase.max.qps.fraction</a></td><td>(N/A)</td><td>Maximum for HBASE_QPS_FRACTION_PROP to stabilize skewed write workloads<br><code>Config Param: MAX_QPS_FRACTION</code></td></tr><tr><td><a href="#hoodieindexhbaseminqpsfraction">hoodie.index.hbase.min.qps.fraction</a></td><td>(N/A)</td><td>Minimum for HBASE_QPS_FRACTION_PROP to stabilize skewed write workloads<br><code>Config Param: MIN_QPS_FRACTION</code></td></tr><tr><td><a href="#hoodieindexhbaseregionserverkerberosprincipal">hoodie.index.hbase.regionserver.kerberos.principal</a></td><td>(N/A)</td><td>The value of hbase.regionserver.kerberos.principal in hbase cluster.<br><code>Config Param: REGIONSERVER_PRINCIPAL</code></td></tr><tr><td><a href="#hoodieindexhbasesleepmsforgetbatch">hoodie.index.hbase.sleep.ms.for.get.batch</a></td><td>(N/A)</td><td><br><code>Config Param: SLEEP_MS_FOR_GET_BATCH</code></td></tr><tr><td><a href="#hoodieindexhbasesleepmsforputbatch">hoodie.index.hbase.sleep.ms.for.put.batch</a></td><td>(N/A)</td><td><br><code>Config Param: SLEEP_MS_FOR_PUT_BATCH</code></td></tr><tr><td><a href="#hoodieindexhbasetable">hoodie.index.hbase.table</a></td><td>(N/A)</td><td>Only applies if index type is HBASE. HBase Table name to use as the index. Hudi stores the row_key and <!-- -->[partition_path, fileID, commitTime]<!-- --> mapping in the table<br><code>Config Param: TABLENAME</code></td></tr><tr><td><a href="#hoodieindexhbasezknodepath">hoodie.index.hbase.zknode.path</a></td><td>(N/A)</td><td>Only applies if index type is HBASE. This is the root znode that will contain all the znodes created/used by HBase<br><code>Config Param: ZK_NODE_PATH</code></td></tr><tr><td><a href="#hoodieindexhbasezkport">hoodie.index.hbase.zkport</a></td><td>(N/A)</td><td>Only applies if index type is HBASE. HBase ZK Quorum port to connect to<br><code>Config Param: ZKPORT</code></td></tr><tr><td><a href="#hoodieindexhbasezkquorum">hoodie.index.hbase.zkquorum</a></td><td>(N/A)</td><td>Only applies if index type is HBASE. HBase ZK Quorum url to connect to<br><code>Config Param: ZKQUORUM</code></td></tr><tr><td><a href="#hoodiehbaseindexupdatepartitionpath">hoodie.hbase.index.update.partition.path</a></td><td>false</td><td>Only applies if index type is HBASE. When an already existing record is upserted to a new partition compared to whats in storage, this config when set, will delete old record in old partition and will insert it as new record in new partition.<br><code>Config Param: UPDATE_PARTITION_PATH_ENABLE</code></td></tr><tr><td><a href="#hoodieindexhbasebucketnumber">hoodie.index.hbase.bucket.number</a></td><td>8</td><td>Only applicable when using RebalancedSparkHoodieHBaseIndex, same as hbase regions count can get the best performance<br><code>Config Param: BUCKET_NUMBER</code></td></tr><tr><td><a href="#hoodieindexhbasedesired_puts_time_in_secs">hoodie.index.hbase.desired_puts_time_in_secs</a></td><td>600</td><td><br><code>Config Param: DESIRED_PUTS_TIME_IN_SECONDS</code></td></tr><tr><td><a href="#hoodieindexhbasedynamic_qps">hoodie.index.hbase.dynamic_qps</a></td><td>false</td><td>Property to decide if HBASE_QPS_FRACTION_PROP is dynamically calculated based on write volume.<br><code>Config Param: COMPUTE_QPS_DYNAMICALLY</code></td></tr><tr><td><a href="#hoodieindexhbasegetbatchsize">hoodie.index.hbase.get.batch.size</a></td><td>100</td><td>Controls the batch size for performing gets against HBase. Batching improves throughput, by saving round trips.<br><code>Config Param: GET_BATCH_SIZE</code></td></tr><tr><td><a href="#hoodieindexhbasemaxqpsperregionserver">hoodie.index.hbase.max.qps.per.region.server</a></td><td>1000</td><td>Property to set maximum QPS allowed per Region Server. This should be same across various jobs. This is intended to  limit the aggregate QPS generated across various jobs to an Hbase Region Server. It is recommended to set this  value based on global indexing throughput needs and most importantly, how much the HBase installation in use is  able to tolerate without Region Servers going down.<br><code>Config Param: MAX_QPS_PER_REGION_SERVER</code></td></tr><tr><td><a href="#hoodieindexhbaseputbatchsize">hoodie.index.hbase.put.batch.size</a></td><td>100</td><td>Controls the batch size for performing puts against HBase. Batching improves throughput, by saving round trips.<br><code>Config Param: PUT_BATCH_SIZE</code></td></tr><tr><td><a href="#hoodieindexhbaseputbatchsizeautocompute">hoodie.index.hbase.put.batch.size.autocompute</a></td><td>false</td><td>Property to set to enable auto computation of put batch size<br><code>Config Param: PUT_BATCH_SIZE_AUTO_COMPUTE</code></td></tr><tr><td><a href="#hoodieindexhbaseqpsallocatorclass">hoodie.index.hbase.qps.allocator.class</a></td><td>org.apache.hudi.index.hbase.DefaultHBaseQPSResourceAllocator</td><td>Property to set which implementation of HBase QPS resource allocator to be used, whichcontrols the batching rate dynamically.<br><code>Config Param: QPS_ALLOCATOR_CLASS_NAME</code></td></tr><tr><td><a href="#hoodieindexhbaseqpsfraction">hoodie.index.hbase.qps.fraction</a></td><td>0.5</td><td>Property to set the fraction of the global share of QPS that should be allocated to this job. Let&#x27;s say there are 3 jobs which have input size in terms of number of rows required for HbaseIndexing as x, 2x, 3x respectively. Then this fraction for the jobs would be (0.17) 1/6, 0.33 (2/6) and 0.5 (3/6) respectively. Default is 50%, which means a total of 2 jobs can run using HbaseIndex without overwhelming Region Servers.<br><code>Config Param: QPS_FRACTION</code></td></tr><tr><td><a href="#hoodieindexhbaserollbacksync">hoodie.index.hbase.rollback.sync</a></td><td>false</td><td>When set to true, the rollback method will delete the last failed task index. The default value is false. Because deleting the index will add extra load on the Hbase cluster for each rollback<br><code>Config Param: ROLLBACK_SYNC_ENABLE</code></td></tr><tr><td><a href="#hoodieindexhbasesecurityauthentication">hoodie.index.hbase.security.authentication</a></td><td>simple</td><td>Property to decide if the hbase cluster secure authentication is enabled or not. Possible values are &#x27;simple&#x27; (no authentication), and &#x27;kerberos&#x27;.<br><code>Config Param: SECURITY_AUTHENTICATION</code></td></tr><tr><td><a href="#hoodieindexhbasezkconnection_timeout_ms">hoodie.index.hbase.zk.connection_timeout_ms</a></td><td>15000</td><td>Timeout to use for establishing connection with zookeeper, from HBase client.<br><code>Config Param: ZK_CONNECTION_TIMEOUT_MS</code></td></tr><tr><td><a href="#hoodieindexhbasezksession_timeout_ms">hoodie.index.hbase.zk.session_timeout_ms</a></td><td>60000</td><td>Session timeout value to use for Zookeeper failure detection, for the HBase client.Lower this value, if you want to fail faster.<br><code>Config Param: ZK_SESSION_TIMEOUT_MS</code></td></tr><tr><td><a href="#hoodieindexhbasezkpathqps_root">hoodie.index.hbase.zkpath.qps_root</a></td><td>/QPS_ROOT</td><td>chroot in zookeeper, to use for all qps allocation co-ordination.<br><code>Config Param: ZKPATH_QPS_ROOT</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="META_SYNC">Metastore and Catalog Sync Configs<a class="hash-link" href="#META_SYNC" title="Direct link to heading">​</a></h2><p>Configurations used by the Hudi to sync metadata to external metastores and catalogs.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Common-Metadata-Sync-Configs">Common Metadata Sync Configs<a class="hash-link" href="#Common-Metadata-Sync-Configs" title="Direct link to heading">​</a></h3><p><a href="#Common-Metadata-Sync-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr></tbody></table><p><a href="#Common-Metadata-Sync-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: META_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: META_SYNC_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: META_SYNC_DATABASE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: META_SYNC_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: META_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: META_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncbasepath">hoodie.datasource.meta.sync.base.path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: META_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: META_SYNC_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiemetasyncdecode_partition">hoodie.meta.sync.decode_partition</a></td><td>false</td><td>If true, meta sync will url-decode the partition path, as it is deemed as url-encoded. Default to false.<br><code>Config Param: META_SYNC_DECODE_PARTITION</code></td></tr><tr><td><a href="#hoodiemetasyncincremental">hoodie.meta.sync.incremental</a></td><td>true</td><td>Whether to incrementally sync the partitions to the metastore, i.e., only added, changed, and deleted partitions based on the commit metadata. If set to <code>false</code>, the meta sync executes a full partition sync operation when partitions are lost.<br><code>Config Param: META_SYNC_INCREMENTAL</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetasyncmetadata_file_listing">hoodie.meta.sync.metadata_file_listing</a></td><td>false</td><td>Enable the internal metadata table for file listing for syncing with metastores<br><code>Config Param: META_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncsync_snapshot_with_table_name">hoodie.meta.sync.sync_snapshot_with_table_name</a></td><td>false</td><td>sync meta info to origin table if enable<br><code>Config Param: META_SYNC_SNAPSHOT_WITH_TABLE_NAME</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemeta_syncsparkversion">hoodie.meta_sync.spark.version</a></td><td></td><td>The spark version used when syncing with a metastore.<br><code>Config Param: META_SYNC_SPARK_VERSION</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Glue-catalog-sync-based-client-Configurations">Glue catalog sync based client Configurations<a class="hash-link" href="#Glue-catalog-sync-based-client-Configurations" title="Direct link to heading">​</a></h3><p>Configs that control Glue catalog sync based client.</p><p><a href="#Glue-catalog-sync-based-client-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcemetasyncgluemetadata_file_listing">hoodie.datasource.meta.sync.glue.metadata_file_listing</a></td><td>false</td><td>Makes athena use the metadata table to list partitions and files. Currently it won&#x27;t benefit from other features such stats indexes<br><code>Config Param: GLUE_METADATA_FILE_LISTING</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncglueskip_table_archive">hoodie.datasource.meta.sync.glue.skip_table_archive</a></td><td>true</td><td>Glue catalog sync based client will skip archiving the table version if this config is set to true<br><code>Config Param: GLUE_SKIP_TABLE_ARCHIVE</code><br><code>Since Version: 0.14.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="BigQuery-Sync-Configs">BigQuery Sync Configs<a class="hash-link" href="#BigQuery-Sync-Configs" title="Direct link to heading">​</a></h3><p>Configurations used by the Hudi to sync metadata to Google BigQuery.</p><p><a href="#BigQuery-Sync-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr></tbody></table><p><a href="#BigQuery-Sync-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiegcpbigquerysyncdataset_location">hoodie.gcp.bigquery.sync.dataset_location</a></td><td>(N/A)</td><td>Location of the target dataset in BigQuery<br><code>Config Param: BIGQUERY_SYNC_DATASET_LOCATION</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncproject_id">hoodie.gcp.bigquery.sync.project_id</a></td><td>(N/A)</td><td>Name of the target project in BigQuery<br><code>Config Param: BIGQUERY_SYNC_PROJECT_ID</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncsource_uri">hoodie.gcp.bigquery.sync.source_uri</a></td><td>(N/A)</td><td>Name of the source uri gcs path of the table<br><code>Config Param: BIGQUERY_SYNC_SOURCE_URI</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncsource_uri_prefix">hoodie.gcp.bigquery.sync.source_uri_prefix</a></td><td>(N/A)</td><td>Name of the source uri gcs path prefix of the table<br><code>Config Param: BIGQUERY_SYNC_SOURCE_URI_PREFIX</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: META_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: META_SYNC_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: META_SYNC_DATABASE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: META_SYNC_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: META_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: META_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncbasepath">hoodie.datasource.meta.sync.base.path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: META_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: META_SYNC_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncassume_date_partitioning">hoodie.gcp.bigquery.sync.assume_date_partitioning</a></td><td>false</td><td>Assume standard yyyy/mm/dd partitioning, this exists to support backward compatibility. If you use hoodie 0.3.x, do not set this parameter<br><code>Config Param: BIGQUERY_SYNC_ASSUME_DATE_PARTITIONING</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncbase_path">hoodie.gcp.bigquery.sync.base_path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: BIGQUERY_SYNC_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncdataset_name">hoodie.gcp.bigquery.sync.dataset_name</a></td><td></td><td>Name of the target dataset in BigQuery<br><code>Config Param: BIGQUERY_SYNC_DATASET_NAME</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncpartition_fields">hoodie.gcp.bigquery.sync.partition_fields</a></td><td></td><td>Comma-delimited partition fields. Default to non-partitioned.<br><code>Config Param: BIGQUERY_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiegcpbigquerysynctable_name">hoodie.gcp.bigquery.sync.table_name</a></td><td></td><td>Name of the target table in BigQuery<br><code>Config Param: BIGQUERY_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncuse_bq_manifest_file">hoodie.gcp.bigquery.sync.use_bq_manifest_file</a></td><td>false</td><td>If true, generate a manifest file with data file absolute paths and use BigQuery manifest file support to directly create one external table over the Hudi table. If false (default), generate a manifest file with data file names and create two external tables and one view in BigQuery. Query the view for the same results as querying the Hudi table<br><code>Config Param: BIGQUERY_SYNC_USE_BQ_MANIFEST_FILE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiegcpbigquerysyncuse_file_listing_from_metadata">hoodie.gcp.bigquery.sync.use_file_listing_from_metadata</a></td><td>false</td><td>Fetch file listing from Hudi&#x27;s metadata<br><code>Config Param: BIGQUERY_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncdecode_partition">hoodie.meta.sync.decode_partition</a></td><td>false</td><td>If true, meta sync will url-decode the partition path, as it is deemed as url-encoded. Default to false.<br><code>Config Param: META_SYNC_DECODE_PARTITION</code></td></tr><tr><td><a href="#hoodiemetasyncincremental">hoodie.meta.sync.incremental</a></td><td>true</td><td>Whether to incrementally sync the partitions to the metastore, i.e., only added, changed, and deleted partitions based on the commit metadata. If set to <code>false</code>, the meta sync executes a full partition sync operation when partitions are lost.<br><code>Config Param: META_SYNC_INCREMENTAL</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetasyncmetadata_file_listing">hoodie.meta.sync.metadata_file_listing</a></td><td>false</td><td>Enable the internal metadata table for file listing for syncing with metastores<br><code>Config Param: META_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncsync_snapshot_with_table_name">hoodie.meta.sync.sync_snapshot_with_table_name</a></td><td>false</td><td>sync meta info to origin table if enable<br><code>Config Param: META_SYNC_SNAPSHOT_WITH_TABLE_NAME</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemeta_syncsparkversion">hoodie.meta_sync.spark.version</a></td><td></td><td>The spark version used when syncing with a metastore.<br><code>Config Param: META_SYNC_SPARK_VERSION</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Hive-Sync-Configs">Hive Sync Configs<a class="hash-link" href="#Hive-Sync-Configs" title="Direct link to heading">​</a></h3><p>Configurations used by the Hudi to sync metadata to Hive Metastore.</p><p><a href="#Hive-Sync-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncmode">hoodie.datasource.hive_sync.mode</a></td><td>(N/A)</td><td>Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql.<br><code>Config Param: HIVE_SYNC_MODE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncenable">hoodie.datasource.hive_sync.enable</a></td><td>false</td><td>When set to true, register/sync the table to Apache Hive metastore.<br><code>Config Param: HIVE_SYNC_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncjdbcurl">hoodie.datasource.hive_sync.jdbcurl</a></td><td>jdbc:hive2://localhost:10000</td><td>Hive metastore url<br><code>Config Param: HIVE_URL</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncmetastoreuris">hoodie.datasource.hive_sync.metastore.uris</a></td><td>thrift://localhost:9083</td><td>Hive metastore url<br><code>Config Param: METASTORE_URIS</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr></tbody></table><p><a href="#Hive-Sync-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncserde_properties">hoodie.datasource.hive_sync.serde_properties</a></td><td>(N/A)</td><td>Serde properties to hive table.<br><code>Config Param: HIVE_TABLE_SERDE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable_properties">hoodie.datasource.hive_sync.table_properties</a></td><td>(N/A)</td><td>Additional properties to store with table.<br><code>Config Param: HIVE_TABLE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: META_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncauto_create_database">hoodie.datasource.hive_sync.auto_create_database</a></td><td>true</td><td>Auto create hive database if does not exists<br><code>Config Param: HIVE_AUTO_CREATE_DATABASE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: META_SYNC_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbatch_num">hoodie.datasource.hive_sync.batch_num</a></td><td>1000</td><td>The number of partitions one batch when synchronous partitions to hive.<br><code>Config Param: HIVE_BATCH_SYNC_PARTITION_NUM</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbucket_sync">hoodie.datasource.hive_sync.bucket_sync</a></td><td>false</td><td>Whether sync hive metastore bucket specification when using bucket index.The specification is &#x27;CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS&#x27;<br><code>Config Param: HIVE_SYNC_BUCKET_SYNC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbucket_sync_spec">hoodie.datasource.hive_sync.bucket_sync_spec</a></td><td></td><td>The hive metastore bucket specification when using bucket index.The specification is &#x27;CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS&#x27;<br><code>Config Param: HIVE_SYNC_BUCKET_SYNC_SPEC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synccreate_managed_table">hoodie.datasource.hive_sync.create_managed_table</a></td><td>false</td><td>Whether to sync the table as managed table.<br><code>Config Param: HIVE_CREATE_MANAGED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: META_SYNC_DATABASE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncfilter_pushdown_enabled">hoodie.datasource.hive_sync.filter_pushdown_enabled</a></td><td>false</td><td>Whether to enable push down partitions by filter<br><code>Config Param: HIVE_SYNC_FILTER_PUSHDOWN_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncfilter_pushdown_max_size">hoodie.datasource.hive_sync.filter_pushdown_max_size</a></td><td>1000</td><td>Max size limit to push down partition filters, if the estimate push down filters exceed this size, will directly try to fetch all partitions<br><code>Config Param: HIVE_SYNC_FILTER_PUSHDOWN_MAX_SIZE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncignore_exceptions">hoodie.datasource.hive_sync.ignore_exceptions</a></td><td>false</td><td>Ignore exceptions when syncing with Hive.<br><code>Config Param: HIVE_IGNORE_EXCEPTIONS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncomit_metadata_fields">hoodie.datasource.hive_sync.omit_metadata_fields</a></td><td>false</td><td>Whether to omit the hoodie metadata fields in the target table.<br><code>Config Param: HIVE_SYNC_OMIT_METADATA_FIELDS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: META_SYNC_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: META_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpassword">hoodie.datasource.hive_sync.password</a></td><td>hive</td><td>hive password to use<br><code>Config Param: HIVE_PASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncschema_string_length_thresh">hoodie.datasource.hive_sync.schema_string_length_thresh</a></td><td>4000</td><td><br><code>Config Param: HIVE_SYNC_SCHEMA_STRING_LENGTH_THRESHOLD</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncskip_ro_suffix">hoodie.datasource.hive_sync.skip_ro_suffix</a></td><td>false</td><td>Skip the _ro suffix for Read optimized table, when registering<br><code>Config Param: HIVE_SKIP_RO_SUFFIX_FOR_READ_OPTIMIZED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsupport_timestamp">hoodie.datasource.hive_sync.support_timestamp</a></td><td>false</td><td>‘INT64’ with original type TIMESTAMP_MICROS is converted to hive ‘timestamp’ type. Disabled by default for backward compatibility.<br><code>Config Param: HIVE_SUPPORT_TIMESTAMP_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_as_datasource">hoodie.datasource.hive_sync.sync_as_datasource</a></td><td>true</td><td><br><code>Config Param: HIVE_SYNC_AS_DATA_SOURCE_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_comment">hoodie.datasource.hive_sync.sync_comment</a></td><td>false</td><td>Whether to sync the table column comments while syncing the table.<br><code>Config Param: HIVE_SYNC_COMMENT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: META_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctablestrategy">hoodie.datasource.hive_sync.table.strategy</a></td><td>ALL</td><td>Hive table synchronization strategy. Available option: RO, RT, ALL.<br><code>Config Param: HIVE_SYNC_TABLE_STRATEGY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_jdbc">hoodie.datasource.hive_sync.use_jdbc</a></td><td>true</td><td>Use JDBC when hive synchronization is enabled<br><code>Config Param: HIVE_USE_JDBC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_pre_apache_input_format">hoodie.datasource.hive_sync.use_pre_apache_input_format</a></td><td>false</td><td>Flag to choose InputFormat under com.uber.hoodie package instead of org.apache.hudi package. Use this when you are in the process of migrating from com.uber.hoodie to org.apache.hudi. Stop using this after you migrated the table definition to org.apache.hudi input format<br><code>Config Param: HIVE_USE_PRE_APACHE_INPUT_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncusername">hoodie.datasource.hive_sync.username</a></td><td>hive</td><td>hive user name to use<br><code>Config Param: HIVE_USER</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncbasepath">hoodie.datasource.meta.sync.base.path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: META_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: META_SYNC_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiemetasyncdecode_partition">hoodie.meta.sync.decode_partition</a></td><td>false</td><td>If true, meta sync will url-decode the partition path, as it is deemed as url-encoded. Default to false.<br><code>Config Param: META_SYNC_DECODE_PARTITION</code></td></tr><tr><td><a href="#hoodiemetasyncincremental">hoodie.meta.sync.incremental</a></td><td>true</td><td>Whether to incrementally sync the partitions to the metastore, i.e., only added, changed, and deleted partitions based on the commit metadata. If set to <code>false</code>, the meta sync executes a full partition sync operation when partitions are lost.<br><code>Config Param: META_SYNC_INCREMENTAL</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetasyncmetadata_file_listing">hoodie.meta.sync.metadata_file_listing</a></td><td>false</td><td>Enable the internal metadata table for file listing for syncing with metastores<br><code>Config Param: META_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncsync_snapshot_with_table_name">hoodie.meta.sync.sync_snapshot_with_table_name</a></td><td>false</td><td>sync meta info to origin table if enable<br><code>Config Param: META_SYNC_SNAPSHOT_WITH_TABLE_NAME</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemeta_syncsparkversion">hoodie.meta_sync.spark.version</a></td><td></td><td>The spark version used when syncing with a metastore.<br><code>Config Param: META_SYNC_SPARK_VERSION</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Global-Hive-Sync-Configs">Global Hive Sync Configs<a class="hash-link" href="#Global-Hive-Sync-Configs" title="Direct link to heading">​</a></h3><p>Global replication configurations used by the Hudi to sync metadata to Hive Metastore.</p><p><a href="#Global-Hive-Sync-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncmode">hoodie.datasource.hive_sync.mode</a></td><td>(N/A)</td><td>Mode to choose for Hive ops. Valid values are hms, jdbc and hiveql.<br><code>Config Param: HIVE_SYNC_MODE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncenable">hoodie.datasource.hive_sync.enable</a></td><td>false</td><td>When set to true, register/sync the table to Apache Hive metastore.<br><code>Config Param: HIVE_SYNC_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncjdbcurl">hoodie.datasource.hive_sync.jdbcurl</a></td><td>jdbc:hive2://localhost:10000</td><td>Hive metastore url<br><code>Config Param: HIVE_URL</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncmetastoreuris">hoodie.datasource.hive_sync.metastore.uris</a></td><td>thrift://localhost:9083</td><td>Hive metastore url<br><code>Config Param: METASTORE_URIS</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr></tbody></table><p><a href="#Global-Hive-Sync-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcehive_syncserde_properties">hoodie.datasource.hive_sync.serde_properties</a></td><td>(N/A)</td><td>Serde properties to hive table.<br><code>Config Param: HIVE_TABLE_SERDE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable_properties">hoodie.datasource.hive_sync.table_properties</a></td><td>(N/A)</td><td>Additional properties to store with table.<br><code>Config Param: HIVE_TABLE_PROPERTIES</code></td></tr><tr><td><a href="#hoodiemeta_syncglobalreplicatetimestamp">hoodie.meta_sync.global.replicate.timestamp</a></td><td>(N/A)</td><td><br><code>Config Param: META_SYNC_GLOBAL_REPLICATE_TIMESTAMP</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: META_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncauto_create_database">hoodie.datasource.hive_sync.auto_create_database</a></td><td>true</td><td>Auto create hive database if does not exists<br><code>Config Param: HIVE_AUTO_CREATE_DATABASE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: META_SYNC_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbatch_num">hoodie.datasource.hive_sync.batch_num</a></td><td>1000</td><td>The number of partitions one batch when synchronous partitions to hive.<br><code>Config Param: HIVE_BATCH_SYNC_PARTITION_NUM</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbucket_sync">hoodie.datasource.hive_sync.bucket_sync</a></td><td>false</td><td>Whether sync hive metastore bucket specification when using bucket index.The specification is &#x27;CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS&#x27;<br><code>Config Param: HIVE_SYNC_BUCKET_SYNC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbucket_sync_spec">hoodie.datasource.hive_sync.bucket_sync_spec</a></td><td></td><td>The hive metastore bucket specification when using bucket index.The specification is &#x27;CLUSTERED BY (trace_id) SORTED BY (trace_id ASC) INTO 65536 BUCKETS&#x27;<br><code>Config Param: HIVE_SYNC_BUCKET_SYNC_SPEC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synccreate_managed_table">hoodie.datasource.hive_sync.create_managed_table</a></td><td>false</td><td>Whether to sync the table as managed table.<br><code>Config Param: HIVE_CREATE_MANAGED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: META_SYNC_DATABASE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncfilter_pushdown_enabled">hoodie.datasource.hive_sync.filter_pushdown_enabled</a></td><td>false</td><td>Whether to enable push down partitions by filter<br><code>Config Param: HIVE_SYNC_FILTER_PUSHDOWN_ENABLED</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncfilter_pushdown_max_size">hoodie.datasource.hive_sync.filter_pushdown_max_size</a></td><td>1000</td><td>Max size limit to push down partition filters, if the estimate push down filters exceed this size, will directly try to fetch all partitions<br><code>Config Param: HIVE_SYNC_FILTER_PUSHDOWN_MAX_SIZE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncignore_exceptions">hoodie.datasource.hive_sync.ignore_exceptions</a></td><td>false</td><td>Ignore exceptions when syncing with Hive.<br><code>Config Param: HIVE_IGNORE_EXCEPTIONS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncomit_metadata_fields">hoodie.datasource.hive_sync.omit_metadata_fields</a></td><td>false</td><td>Whether to omit the hoodie metadata fields in the target table.<br><code>Config Param: HIVE_SYNC_OMIT_METADATA_FIELDS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: META_SYNC_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: META_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpassword">hoodie.datasource.hive_sync.password</a></td><td>hive</td><td>hive password to use<br><code>Config Param: HIVE_PASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncschema_string_length_thresh">hoodie.datasource.hive_sync.schema_string_length_thresh</a></td><td>4000</td><td><br><code>Config Param: HIVE_SYNC_SCHEMA_STRING_LENGTH_THRESHOLD</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncskip_ro_suffix">hoodie.datasource.hive_sync.skip_ro_suffix</a></td><td>false</td><td>Skip the _ro suffix for Read optimized table, when registering<br><code>Config Param: HIVE_SKIP_RO_SUFFIX_FOR_READ_OPTIMIZED_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsupport_timestamp">hoodie.datasource.hive_sync.support_timestamp</a></td><td>false</td><td>‘INT64’ with original type TIMESTAMP_MICROS is converted to hive ‘timestamp’ type. Disabled by default for backward compatibility.<br><code>Config Param: HIVE_SUPPORT_TIMESTAMP_TYPE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_as_datasource">hoodie.datasource.hive_sync.sync_as_datasource</a></td><td>true</td><td><br><code>Config Param: HIVE_SYNC_AS_DATA_SOURCE_TABLE</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncsync_comment">hoodie.datasource.hive_sync.sync_comment</a></td><td>false</td><td>Whether to sync the table column comments while syncing the table.<br><code>Config Param: HIVE_SYNC_COMMENT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: META_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctablestrategy">hoodie.datasource.hive_sync.table.strategy</a></td><td>ALL</td><td>Hive table synchronization strategy. Available option: RO, RT, ALL.<br><code>Config Param: HIVE_SYNC_TABLE_STRATEGY</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_jdbc">hoodie.datasource.hive_sync.use_jdbc</a></td><td>true</td><td>Use JDBC when hive synchronization is enabled<br><code>Config Param: HIVE_USE_JDBC</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncuse_pre_apache_input_format">hoodie.datasource.hive_sync.use_pre_apache_input_format</a></td><td>false</td><td>Flag to choose InputFormat under com.uber.hoodie package instead of org.apache.hudi package. Use this when you are in the process of migrating from com.uber.hoodie to org.apache.hudi. Stop using this after you migrated the table definition to org.apache.hudi input format<br><code>Config Param: HIVE_USE_PRE_APACHE_INPUT_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncusername">hoodie.datasource.hive_sync.username</a></td><td>hive</td><td>hive user name to use<br><code>Config Param: HIVE_USER</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncbasepath">hoodie.datasource.meta.sync.base.path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: META_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: META_SYNC_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiemetasyncdecode_partition">hoodie.meta.sync.decode_partition</a></td><td>false</td><td>If true, meta sync will url-decode the partition path, as it is deemed as url-encoded. Default to false.<br><code>Config Param: META_SYNC_DECODE_PARTITION</code></td></tr><tr><td><a href="#hoodiemetasyncincremental">hoodie.meta.sync.incremental</a></td><td>true</td><td>Whether to incrementally sync the partitions to the metastore, i.e., only added, changed, and deleted partitions based on the commit metadata. If set to <code>false</code>, the meta sync executes a full partition sync operation when partitions are lost.<br><code>Config Param: META_SYNC_INCREMENTAL</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetasyncmetadata_file_listing">hoodie.meta.sync.metadata_file_listing</a></td><td>false</td><td>Enable the internal metadata table for file listing for syncing with metastores<br><code>Config Param: META_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncsync_snapshot_with_table_name">hoodie.meta.sync.sync_snapshot_with_table_name</a></td><td>false</td><td>sync meta info to origin table if enable<br><code>Config Param: META_SYNC_SNAPSHOT_WITH_TABLE_NAME</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemeta_syncsparkversion">hoodie.meta_sync.spark.version</a></td><td></td><td>The spark version used when syncing with a metastore.<br><code>Config Param: META_SYNC_SPARK_VERSION</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="DataHub-Sync-Configs">DataHub Sync Configs<a class="hash-link" href="#DataHub-Sync-Configs" title="Direct link to heading">​</a></h3><p>Configurations used by the Hudi to sync metadata to DataHub.</p><p><a href="#DataHub-Sync-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiedatasourcemetasyncenable">hoodie.datasource.meta.sync.enable</a></td><td>false</td><td>Enable Syncing the Hudi Table with an external meta store or data catalog.<br><code>Config Param: META_SYNC_ENABLED</code></td></tr></tbody></table><p><a href="#DataHub-Sync-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetasyncdatahubemitterserver">hoodie.meta.sync.datahub.emitter.server</a></td><td>(N/A)</td><td>Server URL of the DataHub instance.<br><code>Config Param: META_SYNC_DATAHUB_EMITTER_SERVER</code></td></tr><tr><td><a href="#hoodiemetasyncdatahubemittersupplierclass">hoodie.meta.sync.datahub.emitter.supplier.class</a></td><td>(N/A)</td><td>Pluggable class to supply a DataHub REST emitter to connect to the DataHub instance. This overwrites other emitter configs.<br><code>Config Param: META_SYNC_DATAHUB_EMITTER_SUPPLIER_CLASS</code></td></tr><tr><td><a href="#hoodiemetasyncdatahubemittertoken">hoodie.meta.sync.datahub.emitter.token</a></td><td>(N/A)</td><td>Auth token to connect to the DataHub instance.<br><code>Config Param: META_SYNC_DATAHUB_EMITTER_TOKEN</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncassume_date_partitioning">hoodie.datasource.hive_sync.assume_date_partitioning</a></td><td>false</td><td>Assume partitioning is yyyy/MM/dd<br><code>Config Param: META_SYNC_ASSUME_DATE_PARTITION</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncbase_file_format">hoodie.datasource.hive_sync.base_file_format</a></td><td>PARQUET</td><td>Base file format for the sync.<br><code>Config Param: META_SYNC_BASE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncdatabase">hoodie.datasource.hive_sync.database</a></td><td>default</td><td>The name of the destination database that we should sync the hudi table to.<br><code>Config Param: META_SYNC_DATABASE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_extractor_class">hoodie.datasource.hive_sync.partition_extractor_class</a></td><td>org.apache.hudi.hive.MultiPartKeysValueExtractor</td><td>Class which implements PartitionValueExtractor to extract the partition values, default &#x27;org.apache.hudi.hive.MultiPartKeysValueExtractor&#x27;.<br><code>Config Param: META_SYNC_PARTITION_EXTRACTOR_CLASS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_syncpartition_fields">hoodie.datasource.hive_sync.partition_fields</a></td><td></td><td>Field in the table to use for determining hive partition columns.<br><code>Config Param: META_SYNC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiedatasourcehive_synctable">hoodie.datasource.hive_sync.table</a></td><td>unknown</td><td>The name of the destination table that we should sync the hudi table to.<br><code>Config Param: META_SYNC_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiedatasourcemetasyncbasepath">hoodie.datasource.meta.sync.base.path</a></td><td></td><td>Base path of the hoodie table to sync<br><code>Config Param: META_SYNC_BASE_PATH</code></td></tr><tr><td><a href="#hoodiedatasourcemeta_syncconditionsync">hoodie.datasource.meta_sync.condition.sync</a></td><td>false</td><td>If true, only sync on conditions like schema change or partition change.<br><code>Config Param: META_SYNC_CONDITIONAL_SYNC</code></td></tr><tr><td><a href="#hoodiemetasyncdatahubdataplatformname">hoodie.meta.sync.datahub.dataplatform.name</a></td><td>hudi</td><td>String used to represent Hudi when creating its corresponding DataPlatform entity within Datahub<br><code>Config Param: META_SYNC_DATAHUB_DATAPLATFORM_NAME</code></td></tr><tr><td><a href="#hoodiemetasyncdatahubdatasetenv">hoodie.meta.sync.datahub.dataset.env</a></td><td>DEV</td><td>Environment to use when pushing entities to Datahub<br><code>Config Param: META_SYNC_DATAHUB_DATASET_ENV</code></td></tr><tr><td><a href="#hoodiemetasyncdatahubdatasetidentifierclass">hoodie.meta.sync.datahub.dataset.identifier.class</a></td><td>org.apache.hudi.sync.datahub.config.HoodieDataHubDatasetIdentifier</td><td>Pluggable class to help provide info to identify a DataHub Dataset.<br><code>Config Param: META_SYNC_DATAHUB_DATASET_IDENTIFIER_CLASS</code></td></tr><tr><td><a href="#hoodiemetasyncdecode_partition">hoodie.meta.sync.decode_partition</a></td><td>false</td><td>If true, meta sync will url-decode the partition path, as it is deemed as url-encoded. Default to false.<br><code>Config Param: META_SYNC_DECODE_PARTITION</code></td></tr><tr><td><a href="#hoodiemetasyncincremental">hoodie.meta.sync.incremental</a></td><td>true</td><td>Whether to incrementally sync the partitions to the metastore, i.e., only added, changed, and deleted partitions based on the commit metadata. If set to <code>false</code>, the meta sync executes a full partition sync operation when partitions are lost.<br><code>Config Param: META_SYNC_INCREMENTAL</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetasyncmetadata_file_listing">hoodie.meta.sync.metadata_file_listing</a></td><td>false</td><td>Enable the internal metadata table for file listing for syncing with metastores<br><code>Config Param: META_SYNC_USE_FILE_LISTING_FROM_METADATA</code></td></tr><tr><td><a href="#hoodiemetasyncsync_snapshot_with_table_name">hoodie.meta.sync.sync_snapshot_with_table_name</a></td><td>false</td><td>sync meta info to origin table if enable<br><code>Config Param: META_SYNC_SNAPSHOT_WITH_TABLE_NAME</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemeta_syncsparkversion">hoodie.meta_sync.spark.version</a></td><td></td><td>The spark version used when syncing with a metastore.<br><code>Config Param: META_SYNC_SPARK_VERSION</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="METRICS">Metrics Configs<a class="hash-link" href="#METRICS" title="Direct link to heading">​</a></h2><p>These set of configs are used to enable monitoring and reporting of key Hudi stats and metrics.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations-for-Amazon-CloudWatch">Metrics Configurations for Amazon CloudWatch<a class="hash-link" href="#Metrics-Configurations-for-Amazon-CloudWatch" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics using Amazon CloudWatch.  Hudi publishes metrics on every commit, clean, rollback etc.</p><p><a href="#Metrics-Configurations-for-Amazon-CloudWatch-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricscloudwatchmaxDatumsPerRequest">hoodie.metrics.cloudwatch.maxDatumsPerRequest</a></td><td>20</td><td>Max number of Datums per request<br><code>Config Param: MAX_DATUMS_PER_REQUEST</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiemetricscloudwatchmetricprefix">hoodie.metrics.cloudwatch.metric.prefix</a></td><td></td><td>Metric prefix of reporter<br><code>Config Param: METRIC_PREFIX</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiemetricscloudwatchnamespace">hoodie.metrics.cloudwatch.namespace</a></td><td>Hudi</td><td>Namespace of reporter<br><code>Config Param: METRIC_NAMESPACE</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodiemetricscloudwatchreportperiodseconds">hoodie.metrics.cloudwatch.report.period.seconds</a></td><td>60</td><td>Reporting interval in seconds<br><code>Config Param: REPORT_PERIOD_SECONDS</code><br><code>Since Version: 0.10.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations">Metrics Configurations<a class="hash-link" href="#Metrics-Configurations" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics. Hudi publishes metrics on every commit, clean, rollback etc. The following sections list the supported reporters.</p><p><a href="#Metrics-Configurations-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricson">hoodie.metrics.on</a></td><td>false</td><td>Turn on/off metrics reporting. off by default.<br><code>Config Param: TURN_METRICS_ON</code><br><code>Since Version: 0.5.0</code></td></tr><tr><td><a href="#hoodiemetricsreportertype">hoodie.metrics.reporter.type</a></td><td>GRAPHITE</td><td>Type of metrics reporter.<br><code>Config Param: METRICS_REPORTER_TYPE_VALUE</code><br><code>Since Version: 0.5.0</code></td></tr><tr><td><a href="#hoodiemetricscompactionlogblockson">hoodie.metricscompaction.log.blocks.on</a></td><td>false</td><td>Turn on/off metrics reporting for log blocks with compaction commit. off by default.<br><code>Config Param: TURN_METRICS_COMPACTION_LOG_BLOCKS_ON</code><br><code>Since Version: 0.14.0</code></td></tr></tbody></table><p><a href="#Metrics-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricsexecutorenable">hoodie.metrics.executor.enable</a></td><td>(N/A)</td><td><br><code>Config Param: EXECUTOR_METRICS_ENABLE</code><br><code>Since Version: 0.7.0</code></td></tr><tr><td><a href="#hoodiemetricsconfigsproperties">hoodie.metrics.configs.properties</a></td><td></td><td>Comma separated list of config file paths for metric exporter configs<br><code>Config Param: METRICS_REPORTER_FILE_BASED_CONFIGS_PATH</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetricslockenable">hoodie.metrics.lock.enable</a></td><td>false</td><td>Enable metrics for locking infra. Useful when operating in multiwriter mode<br><code>Config Param: LOCK_METRICS_ENABLE</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiemetricsreporterclass">hoodie.metrics.reporter.class</a></td><td></td><td><br><code>Config Param: METRICS_REPORTER_CLASS_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsreportermetricsnameprefix">hoodie.metrics.reporter.metricsname.prefix</a></td><td></td><td>The prefix given to the metrics names.<br><code>Config Param: METRICS_REPORTER_PREFIX</code><br><code>Since Version: 0.11.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations-for-Datadog-reporter">Metrics Configurations for Datadog reporter<a class="hash-link" href="#Metrics-Configurations-for-Datadog-reporter" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics using the Datadog reporter type. Hudi publishes metrics on every commit, clean, rollback etc.</p><p><a href="#Metrics-Configurations-for-Datadog-reporter-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricsdatadogapikey">hoodie.metrics.datadog.api.key</a></td><td>(N/A)</td><td>Datadog API key<br><code>Config Param: API_KEY</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogapikeysupplier">hoodie.metrics.datadog.api.key.supplier</a></td><td>(N/A)</td><td>Datadog API key supplier to supply the API key at runtime. This will take effect if hoodie.metrics.datadog.api.key is not set.<br><code>Config Param: API_KEY_SUPPLIER</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogapisite">hoodie.metrics.datadog.api.site</a></td><td>(N/A)</td><td>Datadog API site: EU or US<br><code>Config Param: API_SITE_VALUE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogmetrichost">hoodie.metrics.datadog.metric.host</a></td><td>(N/A)</td><td>Datadog metric host to be sent along with metrics data.<br><code>Config Param: METRIC_HOST_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogmetricprefix">hoodie.metrics.datadog.metric.prefix</a></td><td>(N/A)</td><td>Datadog metric prefix to be prepended to each metric name with a dot as delimiter. For example, if it is set to foo, foo. will be prepended.<br><code>Config Param: METRIC_PREFIX_VALUE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogmetrictags">hoodie.metrics.datadog.metric.tags</a></td><td>(N/A)</td><td>Datadog metric tags (comma-delimited) to be sent along with metrics data.<br><code>Config Param: METRIC_TAG_VALUES</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogapikeyskipvalidation">hoodie.metrics.datadog.api.key.skip.validation</a></td><td>false</td><td>Before sending metrics via Datadog API, whether to skip validating Datadog API key or not. Default to false.<br><code>Config Param: API_KEY_SKIP_VALIDATION</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogapitimeoutseconds">hoodie.metrics.datadog.api.timeout.seconds</a></td><td>3</td><td>Datadog API timeout in seconds. Default to 3.<br><code>Config Param: API_TIMEOUT_IN_SECONDS</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricsdatadogreportperiodseconds">hoodie.metrics.datadog.report.period.seconds</a></td><td>30</td><td>Datadog reporting period in seconds. Default to 30.<br><code>Config Param: REPORT_PERIOD_IN_SECONDS</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations-for-Graphite">Metrics Configurations for Graphite<a class="hash-link" href="#Metrics-Configurations-for-Graphite" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics using Graphite.  Hudi publishes metrics on every commit, clean, rollback etc.</p><p><a href="#Metrics-Configurations-for-Graphite-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricsgraphitemetricprefix">hoodie.metrics.graphite.metric.prefix</a></td><td>(N/A)</td><td>Standard prefix applied to all metrics. This helps to add datacenter, environment information for e.g<br><code>Config Param: GRAPHITE_METRIC_PREFIX_VALUE</code><br><code>Since Version: 0.5.1</code></td></tr><tr><td><a href="#hoodiemetricsgraphitehost">hoodie.metrics.graphite.host</a></td><td>localhost</td><td>Graphite host to connect to.<br><code>Config Param: GRAPHITE_SERVER_HOST_NAME</code><br><code>Since Version: 0.5.0</code></td></tr><tr><td><a href="#hoodiemetricsgraphiteport">hoodie.metrics.graphite.port</a></td><td>4756</td><td>Graphite port to connect to.<br><code>Config Param: GRAPHITE_SERVER_PORT_NUM</code><br><code>Since Version: 0.5.0</code></td></tr><tr><td><a href="#hoodiemetricsgraphitereportperiodseconds">hoodie.metrics.graphite.report.period.seconds</a></td><td>30</td><td>Graphite reporting period in seconds. Default to 30.<br><code>Config Param: GRAPHITE_REPORT_PERIOD_IN_SECONDS</code><br><code>Since Version: 0.10.0</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations-for-Jmx">Metrics Configurations for Jmx<a class="hash-link" href="#Metrics-Configurations-for-Jmx" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics using Jmx.  Hudi publishes metrics on every commit, clean, rollback etc.</p><p><a href="#Metrics-Configurations-for-Jmx-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricsjmxhost">hoodie.metrics.jmx.host</a></td><td>localhost</td><td>Jmx host to connect to<br><code>Config Param: JMX_HOST_NAME</code><br><code>Since Version: 0.5.1</code></td></tr><tr><td><a href="#hoodiemetricsjmxport">hoodie.metrics.jmx.port</a></td><td>9889</td><td>Jmx port to connect to<br><code>Config Param: JMX_PORT_NUM</code><br><code>Since Version: 0.5.1</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Metrics-Configurations-for-Prometheus">Metrics Configurations for Prometheus<a class="hash-link" href="#Metrics-Configurations-for-Prometheus" title="Direct link to heading">​</a></h3><p>Enables reporting on Hudi metrics using Prometheus.  Hudi publishes metrics on every commit, clean, rollback etc.</p><p><a href="#Metrics-Configurations-for-Prometheus-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiemetricsprometheusport">hoodie.metrics.prometheus.port</a></td><td>9090</td><td>Port for prometheus server.<br><code>Config Param: PROMETHEUS_PORT_NUM</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewaydeleteonshutdown">hoodie.metrics.pushgateway.delete.on.shutdown</a></td><td>true</td><td>Delete the pushgateway info or not when job shutdown, true by default.<br><code>Config Param: PUSHGATEWAY_DELETE_ON_SHUTDOWN_ENABLE</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayhost">hoodie.metrics.pushgateway.host</a></td><td>localhost</td><td>Hostname of the prometheus push gateway.<br><code>Config Param: PUSHGATEWAY_HOST_NAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayjobname">hoodie.metrics.pushgateway.job.name</a></td><td></td><td>Name of the push gateway job.<br><code>Config Param: PUSHGATEWAY_JOBNAME</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayport">hoodie.metrics.pushgateway.port</a></td><td>9091</td><td>Port for the push gateway.<br><code>Config Param: PUSHGATEWAY_PORT_NUM</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayrandomjobnamesuffix">hoodie.metrics.pushgateway.random.job.name.suffix</a></td><td>true</td><td>Whether the pushgateway name need a random suffix , default true.<br><code>Config Param: PUSHGATEWAY_RANDOM_JOBNAME_SUFFIX</code><br><code>Since Version: 0.6.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayreportlabels">hoodie.metrics.pushgateway.report.labels</a></td><td></td><td>Label for the metrics emitted to the Pushgateway. Labels can be specified with key:value pairs separated by commas<br><code>Config Param: PUSHGATEWAY_LABELS</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiemetricspushgatewayreportperiodseconds">hoodie.metrics.pushgateway.report.period.seconds</a></td><td>30</td><td>Reporting interval in seconds.<br><code>Config Param: PUSHGATEWAY_REPORT_PERIOD_IN_SECONDS</code><br><code>Since Version: 0.6.0</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="RECORD_PAYLOAD">Record Payload Config<a class="hash-link" href="#RECORD_PAYLOAD" title="Direct link to heading">​</a></h2><p>This is the lowest level of customization offered by Hudi. Record payloads define how to produce new values to upsert based on incoming new record and stored old record. Hudi provides default implementations such as OverwriteWithLatestAvroPayload which simply update table with the latest/last-written record. This can be overridden to a custom class extending HoodieRecordPayload class, on both datasource and WriteClient levels.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Payload-Configurations">Payload Configurations<a class="hash-link" href="#Payload-Configurations" title="Direct link to heading">​</a></h3><p>Payload related configs, that can be leveraged to control merges based on specific business fields in the data.</p><p><a href="#Payload-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiecompactionpayloadclass">hoodie.compaction.payload.class</a></td><td>org.apache.hudi.common.model.OverwriteWithLatestAvroPayload</td><td>This needs to be same as class used during insert/upserts. Just like writing, compaction also uses the record payload class to merge records in the log against each other, merge again with the base file and produce the final record to be written after compaction.<br><code>Config Param: PAYLOAD_CLASS_NAME</code></td></tr><tr><td><a href="#hoodiepayloadeventtimefield">hoodie.payload.event.time.field</a></td><td>ts</td><td>Table column/field name to derive timestamp associated with the records. This canbe useful for e.g, determining the freshness of the table.<br><code>Config Param: EVENT_TIME_FIELD</code></td></tr><tr><td><a href="#hoodiepayloadorderingfield">hoodie.payload.ordering.field</a></td><td>ts</td><td>Table column/field name to order records that have the same key, before merging and writing to storage.<br><code>Config Param: ORDERING_FIELD</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="KAFKA_CONNECT">Kafka Connect Configs<a class="hash-link" href="#KAFKA_CONNECT" title="Direct link to heading">​</a></h2><p>These set of configs are used for Kafka Connect Sink Connector for writing Hudi Tables</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Kafka-Sink-Connect-Configurations">Kafka Sink Connect Configurations<a class="hash-link" href="#Kafka-Sink-Connect-Configurations" title="Direct link to heading">​</a></h3><p>Configurations for Kafka Connect Sink Connector for Hudi.</p><p><a href="#Kafka-Sink-Connect-Configurations-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#bootstrapservers">bootstrap.servers</a></td><td>localhost:9092</td><td>The bootstrap servers for the Kafka Cluster.<br><code>Config Param: KAFKA_BOOTSTRAP_SERVERS</code></td></tr></tbody></table><p><a href="#Kafka-Sink-Connect-Configurations-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hadoopconfdir">hadoop.conf.dir</a></td><td>(N/A)</td><td>The Hadoop configuration directory.<br><code>Config Param: HADOOP_CONF_DIR</code></td></tr><tr><td><a href="#hadoophome">hadoop.home</a></td><td>(N/A)</td><td>The Hadoop home directory.<br><code>Config Param: HADOOP_HOME</code></td></tr><tr><td><a href="#hoodiekafkaallowcommitonerrors">hoodie.kafka.allow.commit.on.errors</a></td><td>true</td><td>Commit even when some records failed to be written<br><code>Config Param: ALLOW_COMMIT_ON_ERRORS</code></td></tr><tr><td><a href="#hoodiekafkacommitintervalsecs">hoodie.kafka.commit.interval.secs</a></td><td>60</td><td>The interval at which Hudi will commit the records written to the files, making them consumable on the read-side.<br><code>Config Param: COMMIT_INTERVAL_SECS</code></td></tr><tr><td><a href="#hoodiekafkacompactionasyncenable">hoodie.kafka.compaction.async.enable</a></td><td>true</td><td>Controls whether async compaction should be turned on for MOR table writing.<br><code>Config Param: ASYNC_COMPACT_ENABLE</code></td></tr><tr><td><a href="#hoodiekafkacontroltopic">hoodie.kafka.control.topic</a></td><td>hudi-control-topic</td><td>Kafka topic name used by the Hudi Sink Connector for sending and receiving control messages. Not used for data records.<br><code>Config Param: CONTROL_TOPIC_NAME</code></td></tr><tr><td><a href="#hoodiekafkacoordinatorwritetimeoutsecs">hoodie.kafka.coordinator.write.timeout.secs</a></td><td>300</td><td>The timeout after sending an END_COMMIT until when the coordinator will wait for the write statuses from all the partitionsto ignore the current commit and start a new commit.<br><code>Config Param: COORDINATOR_WRITE_TIMEOUT_SECS</code></td></tr><tr><td><a href="#hoodiemetasyncclasses">hoodie.meta.sync.classes</a></td><td>org.apache.hudi.hive.HiveSyncTool</td><td>Meta sync client tool, using comma to separate multi tools<br><code>Config Param: META_SYNC_CLASSES</code></td></tr><tr><td><a href="#hoodiemetasyncenable">hoodie.meta.sync.enable</a></td><td>false</td><td>Enable Meta Sync such as Hive<br><code>Config Param: META_SYNC_ENABLE</code></td></tr><tr><td><a href="#hoodieschemaproviderclass">hoodie.schemaprovider.class</a></td><td>org.apache.hudi.schema.FilebasedSchemaProvider</td><td>subclass of org.apache.hudi.schema.SchemaProvider to attach schemas to input <!-- -->&amp;<!-- --> target table data, built in options: org.apache.hudi.schema.FilebasedSchemaProvider.<br><code>Config Param: SCHEMA_PROVIDER_CLASS</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="AWS">Amazon Web Services Configs<a class="hash-link" href="#AWS" title="Direct link to heading">​</a></h2><p>Configurations specific to Amazon Web Services.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Amazon-Web-Services-Configs">Amazon Web Services Configs<a class="hash-link" href="#Amazon-Web-Services-Configs" title="Direct link to heading">​</a></h3><p>Amazon Web Services configurations to access resources like Amazon DynamoDB (for locks), Amazon CloudWatch (metrics).</p><p><a href="#Amazon-Web-Services-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodieawsaccesskey">hoodie.aws.access.key</a></td><td>(N/A)</td><td>AWS access key id<br><code>Config Param: AWS_ACCESS_KEY</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodieawssecretkey">hoodie.aws.secret.key</a></td><td>(N/A)</td><td>AWS secret key<br><code>Config Param: AWS_SECRET_KEY</code><br><code>Since Version: 0.10.0</code></td></tr><tr><td><a href="#hoodieawssessiontoken">hoodie.aws.session.token</a></td><td>(N/A)</td><td>AWS session token<br><code>Config Param: AWS_SESSION_TOKEN</code><br><code>Since Version: 0.10.0</code></td></tr></tbody></table><hr><h2 class="anchor anchorWithStickyNavbar_y2LR" id="HUDI_STREAMER">Hudi Streamer Configs<a class="hash-link" href="#HUDI_STREAMER" title="Direct link to heading">​</a></h2><p>These set of configs are used for Hudi Streamer utility which provides the way to ingest from different sources such as DFS or Kafka.</p><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Hudi-Streamer-Configs">Hudi Streamer Configs<a class="hash-link" href="#Hudi-Streamer-Configs" title="Direct link to heading">​</a></h3><p><a href="#Hudi-Streamer-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcekafkatopic">hoodie.streamer.source.kafka.topic</a></td><td>(N/A)</td><td>Kafka topic name. The config is specific to HoodieMultiTableStreamer<br><code>Config Param: KAFKA_TOPIC</code></td></tr></tbody></table><p><a href="#Hudi-Streamer-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamercheckpointproviderpath">hoodie.streamer.checkpoint.provider.path</a></td><td>(N/A)</td><td>The path for providing the checkpoints.<br><code>Config Param: CHECKPOINT_PROVIDER_PATH</code></td></tr><tr><td><a href="#hoodiestreameringestiontablesToBeIngested">hoodie.streamer.ingestion.tablesToBeIngested</a></td><td>(N/A)</td><td>Comma separated names of tables to be ingested in the format <!-- -->&lt;<!-- -->database<!-- -->&gt;<!-- -->.<!-- -->&lt;<!-- -->table<!-- -->&gt;<!-- -->, for example db1.table1,db1.table2<br><code>Config Param: TABLES_TO_BE_INGESTED</code></td></tr><tr><td><a href="#hoodiestreamertransformerclass">hoodie.streamer.transformer.class</a></td><td>(N/A)</td><td>Names of transformer classes to apply. The config is specific to HoodieMultiTableStreamer.<br><code>Config Param: TRANSFORMER_CLASS</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiestreamercheckpointforceskip">hoodie.streamer.checkpoint.force.skip</a></td><td>false</td><td>Config to force to skip saving checkpoint in the commit metadata.It is typically used in one-time backfill scenarios, where checkpoints are not to be persisted.<br><code>Config Param: CHECKPOINT_FORCE_SKIP</code></td></tr><tr><td><a href="#hoodiestreameringestiontargetBasePath">hoodie.streamer.ingestion.targetBasePath</a></td><td></td><td>The path to which a particular table is ingested. The config is specific to HoodieMultiTableStreamer and overrides path determined using option <code>--base-path-prefix</code> for a table. This config is ignored for a single table streamer<br><code>Config Param: TARGET_BASE_PATH</code></td></tr><tr><td><a href="#hoodiestreamersamplewritesenabled">hoodie.streamer.sample.writes.enabled</a></td><td>false</td><td>Set this to true to sample from the first batch of records and write to the auxiliary path, before writing to the table.The sampled records are used to calculate the average record size. The relevant write client will have <code>hoodie.copyonwrite.record.size.estimate</code> being overwritten by the calculated result.<br><code>Config Param: SAMPLE_WRITES_ENABLED</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiestreamersamplewritessize">hoodie.streamer.sample.writes.size</a></td><td>5000</td><td>Number of records to sample from the first write. To improve the estimation&#x27;s accuracy, for smaller or more compressable record size, set the sample size bigger. For bigger or less compressable record size, set smaller.<br><code>Config Param: SAMPLE_WRITES_SIZE</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkaappendoffsets">hoodie.streamer.source.kafka.append.offsets</a></td><td>false</td><td>When enabled, appends kafka offset info like source offset(_hoodie_kafka_source_offset), partition (_hoodie_kafka_source_partition) and timestamp (_hoodie_kafka_source_timestamp) to the records. By default its disabled and no kafka offsets are added<br><code>Config Param: KAFKA_APPEND_OFFSETS</code></td></tr><tr><td><a href="#hoodiestreamersourcesanitizeinvalidcharmask">hoodie.streamer.source.sanitize.invalid.char.mask</a></td><td>__</td><td>Defines the character sequence that replaces invalid characters in schema field names if hoodie.streamer.source.sanitize.invalid.schema.field.names is enabled.<br><code>Config Param: SCHEMA_FIELD_NAME_INVALID_CHAR_MASK</code></td></tr><tr><td><a href="#hoodiestreamersourcesanitizeinvalidschemafieldnames">hoodie.streamer.source.sanitize.invalid.schema.field.names</a></td><td>false</td><td>Sanitizes names of invalid schema fields both in the data read from source and also in the schema Replaces invalid characters with hoodie.streamer.source.sanitize.invalid.char.mask. Invalid characters are by goes by avro naming convention (<a href="https://avro.apache.org/docs/current/spec.html#names" target="_blank" rel="noopener noreferrer">https://avro.apache.org/docs/current/spec.html#names</a>).<br><code>Config Param: SANITIZE_SCHEMA_FIELD_NAMES</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="Hudi-Streamer-SQL-Transformer-Configs">Hudi Streamer SQL Transformer Configs<a class="hash-link" href="#Hudi-Streamer-SQL-Transformer-Configs" title="Direct link to heading">​</a></h3><p>Configurations controlling the behavior of SQL transformer in Hudi Streamer.</p><p><a href="#Hudi-Streamer-SQL-Transformer-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamertransformersql">hoodie.streamer.transformer.sql</a></td><td>(N/A)</td><td>SQL Query to be executed during write<br><code>Config Param: TRANSFORMER_SQL</code></td></tr><tr><td><a href="#hoodiestreamertransformersqlfile">hoodie.streamer.transformer.sql.file</a></td><td>(N/A)</td><td>File with a SQL script to be executed during write<br><code>Config Param: TRANSFORMER_SQL_FILE</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="DELTA_STREAMER_SOURCE">Hudi Streamer Source Configs<a class="hash-link" href="#DELTA_STREAMER_SOURCE" title="Direct link to heading">​</a></h3><p>Configurations controlling the behavior of reading source data.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Cloud-Source-Configs">Cloud Source Configs<a class="hash-link" href="#Cloud-Source-Configs" title="Direct link to heading">​</a></h4><p>Configs that are common during ingestion across different cloud stores</p><p><a href="#Cloud-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourceclouddatadatasourceoptions">hoodie.streamer.source.cloud.data.datasource.options</a></td><td>(N/A)</td><td>A JSON string passed to the Spark DataFrameReader while loading the dataset. Example: hoodie.streamer.gcp.spark.datasource.options={&quot;header&quot;:&quot;true&quot;,&quot;encoding&quot;:&quot;UTF-8&quot;} <br><code>Config Param: SPARK_DATASOURCE_OPTIONS</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddataignorerelpathprefix">hoodie.streamer.source.cloud.data.ignore.relpath.prefix</a></td><td>(N/A)</td><td>Ignore objects in the bucket whose relative path matches this prefix<br><code>Config Param: IGNORE_RELATIVE_PATH_PREFIX</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddataignorerelpathsubstring">hoodie.streamer.source.cloud.data.ignore.relpath.substring</a></td><td>(N/A)</td><td>Ignore objects in the bucket whose relative path contains this substring<br><code>Config Param: IGNORE_RELATIVE_PATH_SUBSTR</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddatapartitionfieldsfrompath">hoodie.streamer.source.cloud.data.partition.fields.from.path</a></td><td>(N/A)</td><td>A comma delimited list of path-based partition fields in the source file structure.<br><code>Config Param: PATH_BASED_PARTITION_FIELDS</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddataselectfileextension">hoodie.streamer.source.cloud.data.select.file.extension</a></td><td>(N/A)</td><td>Only match files with this extension. By default, this is the same as hoodie.streamer.source.hoodieincr.file.format<br><code>Config Param: CLOUD_DATAFILE_EXTENSION</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddataselectrelpathprefix">hoodie.streamer.source.cloud.data.select.relpath.prefix</a></td><td>(N/A)</td><td>Only selects objects in the bucket whose relative path matches this prefix<br><code>Config Param: SELECT_RELATIVE_PATH_PREFIX</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddatacheckfileexists">hoodie.streamer.source.cloud.data.check.file.exists</a></td><td>false</td><td>If true, checks whether file exists before attempting to pull it<br><code>Config Param: ENABLE_EXISTS_CHECK</code></td></tr><tr><td><a href="#hoodiestreamersourceclouddatadatafileformat">hoodie.streamer.source.cloud.data.datafile.format</a></td><td>parquet</td><td>Format of the data file. By default, this will be the same as hoodie.streamer.source.hoodieincr.file.format<br><code>Config Param: DATAFILE_FORMAT</code></td></tr><tr><td><a href="#hoodiestreamersourcecloudmetaack">hoodie.streamer.source.cloud.meta.ack</a></td><td>true</td><td>Whether to acknowledge Metadata messages during Cloud Ingestion or not. This is useful during dev and testing.  In Prod this should always be true. In case of Cloud Pubsub, not acknowledging means Pubsub will keep redelivering the same messages.<br><code>Config Param: ACK_MESSAGES</code></td></tr><tr><td><a href="#hoodiestreamersourcecloudmetabatchsize">hoodie.streamer.source.cloud.meta.batch.size</a></td><td>10</td><td>Number of metadata messages to pull at a time<br><code>Config Param: BATCH_SIZE_CONF</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="DFS-Path-Selector-Configs">DFS Path Selector Configs<a class="hash-link" href="#DFS-Path-Selector-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of path selector for DFS source in Hudi Streamer.</p><p><a href="#DFS-Path-Selector-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcedfsroot">hoodie.streamer.source.dfs.root</a></td><td>(N/A)</td><td>Root path of the source on DFS<br><code>Config Param: ROOT_INPUT_PATH</code></td></tr></tbody></table><p><a href="#DFS-Path-Selector-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourceinputselector">hoodie.streamer.source.input.selector</a></td><td>(N/A)</td><td>Source input selector<br><code>Config Param: SOURCE_INPUT_SELECTOR</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Date-Partition-Path-Selector-Configs">Date Partition Path Selector Configs<a class="hash-link" href="#Date-Partition-Path-Selector-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of date partition path selector for DFS source in Hudi Streamer.</p><p><a href="#Date-Partition-Path-Selector-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcedfsdatepartitionedselectorcurrentdate">hoodie.streamer.source.dfs.datepartitioned.selector.currentdate</a></td><td>(N/A)</td><td>Current date.<br><code>Config Param: CURRENT_DATE</code></td></tr><tr><td><a href="#hoodiestreamersourcedfsdatepartitioneddateformat">hoodie.streamer.source.dfs.datepartitioned.date.format</a></td><td>yyyy-MM-dd</td><td>Date format.<br><code>Config Param: DATE_FORMAT</code></td></tr><tr><td><a href="#hoodiestreamersourcedfsdatepartitionedselectordepth">hoodie.streamer.source.dfs.datepartitioned.selector.depth</a></td><td>0</td><td>Depth of the files to scan. 0 implies no (date) partition.<br><code>Config Param: DATE_PARTITION_DEPTH</code></td></tr><tr><td><a href="#hoodiestreamersourcedfsdatepartitionedselectorlookbackdays">hoodie.streamer.source.dfs.datepartitioned.selector.lookback.days</a></td><td>2</td><td>The maximum look-back days for scanning.<br><code>Config Param: LOOKBACK_DAYS</code></td></tr><tr><td><a href="#hoodiestreamersourcedfsdatepartitionedselectorparallelism">hoodie.streamer.source.dfs.datepartitioned.selector.parallelism</a></td><td>20</td><td>Parallelism for listing partitions.<br><code>Config Param: PARTITIONS_LIST_PARALLELISM</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="GCS-Events-Source-Configs">GCS Events Source Configs<a class="hash-link" href="#GCS-Events-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of GCS Events Source in Hudi Streamer.</p><p><a href="#GCS-Events-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcegcsprojectid">hoodie.streamer.source.gcs.project.id</a></td><td>(N/A)</td><td>The GCP Project Id where the Pubsub Subscription to ingest from resides. Needed to connect to the Pubsub subscription<br><code>Config Param: GOOGLE_PROJECT_ID</code></td></tr><tr><td><a href="#hoodiestreamersourcegcssubscriptionid">hoodie.streamer.source.gcs.subscription.id</a></td><td>(N/A)</td><td>The GCP Pubsub subscription id for the GCS Notifications. Needed to connect to the Pubsub subscription<br><code>Config Param: PUBSUB_SUBSCRIPTION_ID</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Hive-Incremental-Pulling-Source-Configs">Hive Incremental Pulling Source Configs<a class="hash-link" href="#Hive-Incremental-Pulling-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of incremental pulling from a Hive table as a source in Hudi Streamer.</p><p><a href="#Hive-Incremental-Pulling-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourceincrpullroot">hoodie.streamer.source.incrpull.root</a></td><td>(N/A)</td><td>The root path of Hive incremental pulling source.<br><code>Config Param: ROOT_INPUT_PATH</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Hudi-Incremental-Source-Configs">Hudi Incremental Source Configs<a class="hash-link" href="#Hudi-Incremental-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of incremental pulling from a Hudi table as a source in Hudi Streamer.</p><p><a href="#Hudi-Incremental-Source-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcehoodieincrpath">hoodie.streamer.source.hoodieincr.path</a></td><td>(N/A)</td><td>Base-path for the source Hudi table<br><code>Config Param: HOODIE_SRC_BASE_PATH</code></td></tr></tbody></table><p><a href="#Hudi-Incremental-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcehoodieincrmissingcheckpointstrategy">hoodie.streamer.source.hoodieincr.missing.checkpoint.strategy</a></td><td>(N/A)</td><td>Allows Hudi Streamer to decide the instant to consume from when checkpoint is not set.  Possible values: <!-- -->[READ_LATEST (Read from latest commit in hoodie source table), READ_UPTO_LATEST_COMMIT (Read everything upto latest commit)]<br><code>Config Param: MISSING_CHECKPOINT_STRATEGY</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrpartitionextractorclass">hoodie.streamer.source.hoodieincr.partition.extractor.class</a></td><td>(N/A)</td><td>PartitionValueExtractor class to extract partition fields from _hoodie_partition_path<br><code>Config Param: HOODIE_SRC_PARTITION_EXTRACTORCLASS</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrpartitionfields">hoodie.streamer.source.hoodieincr.partition.fields</a></td><td>(N/A)</td><td>Specifies partition fields that needs to be added to source table after parsing _hoodie_partition_path.<br><code>Config Param: HOODIE_SRC_PARTITION_FIELDS</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrdropallmetafieldsfromsource">hoodie.streamer.source.hoodieincr.drop.all.meta.fields.from.source</a></td><td>false</td><td>Drops all meta fields from the source hudi table while ingesting into sink hudi table.<br><code>Config Param: HOODIE_DROP_ALL_META_FIELDS_FROM_SOURCE</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrfileformat">hoodie.streamer.source.hoodieincr.file.format</a></td><td>parquet</td><td>This config is passed to the reader while loading dataset. Default value is parquet.<br><code>Config Param: SOURCE_FILE_FORMAT</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrnum_instants">hoodie.streamer.source.hoodieincr.num_instants</a></td><td>5</td><td>Max number of instants whose changes can be incrementally fetched<br><code>Config Param: NUM_INSTANTS_PER_FETCH</code></td></tr><tr><td><a href="#hoodiestreamersourcehoodieincrread_latest_on_missing_ckpt">hoodie.streamer.source.hoodieincr.read_latest_on_missing_ckpt</a></td><td>false</td><td>If true, allows Hudi Streamer to incrementally fetch from latest committed instant when checkpoint is not provided. This config is deprecated. Please refer to hoodie.streamer.source.hoodieincr.missing.checkpoint.strategy<br><code>Config Param: READ_LATEST_INSTANT_ON_MISSING_CKPT</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="JDBC-Source-Configs">JDBC Source Configs<a class="hash-link" href="#JDBC-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of JDBC source in Hudi Streamer.</p><p><a href="#JDBC-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerjdbcdriverclass">hoodie.streamer.jdbc.driver.class</a></td><td>(N/A)</td><td>Driver class used for JDBC connection<br><code>Config Param: DRIVER_CLASS</code></td></tr><tr><td><a href="#hoodiestreamerjdbcextraoptions">hoodie.streamer.jdbc.extra.options.</a></td><td>(N/A)</td><td>Used to set any extra options the user specifies for jdbc<br><code>Config Param: EXTRA_OPTIONS</code></td></tr><tr><td><a href="#hoodiestreamerjdbcincrfallbacktofullfetch">hoodie.streamer.jdbc.incr.fallback.to.full.fetch</a></td><td>(N/A)</td><td>If set true, makes incremental fetch to fallback to full fetch in case of any error<br><code>Config Param: FALLBACK_TO_FULL_FETCH</code></td></tr><tr><td><a href="#hoodiestreamerjdbcincrpull">hoodie.streamer.jdbc.incr.pull</a></td><td>(N/A)</td><td>Will the JDBC source do an incremental pull?<br><code>Config Param: IS_INCREMENTAL</code></td></tr><tr><td><a href="#hoodiestreamerjdbcpassword">hoodie.streamer.jdbc.password</a></td><td>(N/A)</td><td>Password used for JDBC connection<br><code>Config Param: PASSWORD</code></td></tr><tr><td><a href="#hoodiestreamerjdbcpasswordfile">hoodie.streamer.jdbc.password.file</a></td><td>(N/A)</td><td>Base-path for the JDBC password file.<br><code>Config Param: PASSWORD_FILE</code></td></tr><tr><td><a href="#hoodiestreamerjdbcstoragelevel">hoodie.streamer.jdbc.storage.level</a></td><td>(N/A)</td><td>Used to control the persistence level. Default value: MEMORY_AND_DISK_SER<br><code>Config Param: STORAGE_LEVEL</code></td></tr><tr><td><a href="#hoodiestreamerjdbctableincrcolumnname">hoodie.streamer.jdbc.table.incr.column.name</a></td><td>(N/A)</td><td>If run in incremental mode, this field is to pull new data incrementally<br><code>Config Param: INCREMENTAL_COLUMN</code></td></tr><tr><td><a href="#hoodiestreamerjdbctablename">hoodie.streamer.jdbc.table.name</a></td><td>(N/A)</td><td>RDBMS table to pull<br><code>Config Param: RDBMS_TABLE_NAME</code></td></tr><tr><td><a href="#hoodiestreamerjdbcurl">hoodie.streamer.jdbc.url</a></td><td>(N/A)</td><td>JDBC url for the Hoodie datasource.<br><code>Config Param: URL</code></td></tr><tr><td><a href="#hoodiestreamerjdbcuser">hoodie.streamer.jdbc.user</a></td><td>(N/A)</td><td>Username used for JDBC connection<br><code>Config Param: USER</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Json-Kafka-Post-Processor-Configs">Json Kafka Post Processor Configs<a class="hash-link" href="#Json-Kafka-Post-Processor-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the post processor of Json Kafka Source in Hudi Streamer.</p><p><a href="#Json-Kafka-Post-Processor-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcejsonkafkapostprocessormaxwelldatabaseregex">hoodie.streamer.source.json.kafka.post.processor.maxwell.database.regex</a></td><td>(N/A)</td><td>Database name regex<br><code>Config Param: DATABASE_NAME_REGEX</code></td></tr><tr><td><a href="#hoodiestreamersourcejsonkafkapostprocessormaxwelltableregex">hoodie.streamer.source.json.kafka.post.processor.maxwell.table.regex</a></td><td>(N/A)</td><td>Table name regex<br><code>Config Param: TABLE_NAME_REGEX</code></td></tr><tr><td><a href="#hoodiestreamersourcejsonkafkaprocessorclass">hoodie.streamer.source.json.kafka.processor.class</a></td><td>(N/A)</td><td>Json kafka source post processor class name, post process data after consuming fromsource and before giving it to Hudi Streamer.<br><code>Config Param: JSON_KAFKA_PROCESSOR_CLASS</code></td></tr><tr><td><a href="#hoodiestreamersourcejsonkafkapostprocessormaxwellprecombinefieldformat">hoodie.streamer.source.json.kafka.post.processor.maxwell.precombine.field.format</a></td><td>yyyy-MM-dd HH:mm:ss</td><td>When the preCombine filed is in DATE_STRING format, use should tell hoodiewhat format it is. &#x27;yyyy-MM-dd HH:mm:ss&#x27; by default<br><code>Config Param: PRECOMBINE_FIELD_FORMAT</code></td></tr><tr><td><a href="#hoodiestreamersourcejsonkafkapostprocessormaxwellprecombinefieldtype">hoodie.streamer.source.json.kafka.post.processor.maxwell.precombine.field.type</a></td><td>DATE_STRING</td><td>Data type of the preCombine field. could be NON_TIMESTAMP, DATE_STRING,UNIX_TIMESTAMP or EPOCHMILLISECONDS. DATE_STRING by default<br><code>Config Param: PRECOMBINE_FIELD_TYPE</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Kafka-Source-Configs">Kafka Source Configs<a class="hash-link" href="#Kafka-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of Kafka source in Hudi Streamer.</p><p><a href="#Kafka-Source-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcekafkatopic">hoodie.streamer.source.kafka.topic</a></td><td>(N/A)</td><td>Kafka topic name.<br><code>Config Param: KAFKA_TOPIC_NAME</code></td></tr></tbody></table><p><a href="#Kafka-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcekafkavaluedeserializerschema">hoodie.streamer.source.kafka.value.deserializer.schema</a></td><td>(N/A)</td><td>Schema to deserialize the records.<br><code>Config Param: KAFKA_VALUE_DESERIALIZER_SCHEMA</code></td></tr><tr><td><a href="#autooffsetreset">auto.offset.reset</a></td><td>LATEST</td><td>Kafka consumer strategy for reading data.<br><code>Config Param: KAFKA_AUTO_OFFSET_RESET</code></td></tr><tr><td><a href="#hoodiestreamerkafkasourcemaxEvents">hoodie.streamer.kafka.source.maxEvents</a></td><td>5000000</td><td>Maximum number of records obtained in each batch.<br><code>Config Param: MAX_EVENTS_FROM_KAFKA_SOURCE</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkacheckpointtype">hoodie.streamer.source.kafka.checkpoint.type</a></td><td>string</td><td>Kafka checkpoint type.<br><code>Config Param: KAFKA_CHECKPOINT_TYPE</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkaenablecommitoffset">hoodie.streamer.source.kafka.enable.commit.offset</a></td><td>false</td><td>Automatically submits offset to kafka.<br><code>Config Param: ENABLE_KAFKA_COMMIT_OFFSET</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkaenablefailOnDataLoss">hoodie.streamer.source.kafka.enable.failOnDataLoss</a></td><td>false</td><td>Fail when checkpoint goes out of bounds instead of seeking to earliest offsets.<br><code>Config Param: ENABLE_FAIL_ON_DATA_LOSS</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkafetch_partitiontimeout">hoodie.streamer.source.kafka.fetch_partition.time.out</a></td><td>300000</td><td>Time out for fetching partitions. 5min by default<br><code>Config Param: KAFKA_FETCH_PARTITION_TIME_OUT</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkaminPartitions">hoodie.streamer.source.kafka.minPartitions</a></td><td>0</td><td>Desired minimum number of partitions to read from Kafka. By default, Hudi has a 1-1 mapping of topicPartitions to Hudi partitions consuming from Kafka. If set this option to a value greater than topicPartitions, Hudi will divvy up large Kafka partitions to smaller pieces. Please note that this configuration is like a hint: the number of input tasks will be approximately minPartitions. It can be less or more depending on rounding errors or Kafka partitions that didn&#x27;t receive any new data.<br><code>Config Param: KAFKA_SOURCE_MIN_PARTITIONS</code><br><code>Since Version: 0.14.0</code></td></tr><tr><td><a href="#hoodiestreamersourcekafkavaluedeserializerclass">hoodie.streamer.source.kafka.value.deserializer.class</a></td><td>io.confluent.kafka.serializers.KafkaAvroDeserializer</td><td>This class is used by kafka client to deserialize the records.<br><code>Config Param: KAFKA_AVRO_VALUE_DESERIALIZER_CLASS</code><br><code>Since Version: 0.9.0</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Pulsar-Source-Configs">Pulsar Source Configs<a class="hash-link" href="#Pulsar-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of Pulsar source in Hudi Streamer.</p><p><a href="#Pulsar-Source-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcepulsartopic">hoodie.streamer.source.pulsar.topic</a></td><td>(N/A)</td><td>Name of the target Pulsar topic to source data from<br><code>Config Param: PULSAR_SOURCE_TOPIC_NAME</code></td></tr><tr><td><a href="#hoodiestreamersourcepulsarendpointadminurl">hoodie.streamer.source.pulsar.endpoint.admin.url</a></td><td>http://localhost:8080</td><td>URL of the target Pulsar endpoint (of the form &#x27;pulsar://host:port&#x27;<br><code>Config Param: PULSAR_SOURCE_ADMIN_ENDPOINT_URL</code></td></tr><tr><td><a href="#hoodiestreamersourcepulsarendpointserviceurl">hoodie.streamer.source.pulsar.endpoint.service.url</a></td><td>pulsar://localhost:6650</td><td>URL of the target Pulsar endpoint (of the form &#x27;pulsar://host:port&#x27;<br><code>Config Param: PULSAR_SOURCE_SERVICE_ENDPOINT_URL</code></td></tr></tbody></table><p><a href="#Pulsar-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcepulsarmaxRecords">hoodie.streamer.source.pulsar.maxRecords</a></td><td>5000000</td><td>Max number of records obtained in a single each batch<br><code>Config Param: PULSAR_SOURCE_MAX_RECORDS_PER_BATCH_THRESHOLD</code></td></tr><tr><td><a href="#hoodiestreamersourcepulsaroffsetautoResetStrategy">hoodie.streamer.source.pulsar.offset.autoResetStrategy</a></td><td>LATEST</td><td>Policy determining how offsets shall be automatically reset in case there&#x27;s no checkpoint information present<br><code>Config Param: PULSAR_SOURCE_OFFSET_AUTO_RESET_STRATEGY</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="S3-Event-based-Hudi-Incremental-Source-Configs">S3 Event-based Hudi Incremental Source Configs<a class="hash-link" href="#S3-Event-based-Hudi-Incremental-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of incremental pulling from S3 events meta information from Hudi table as a source in Hudi Streamer.</p><p><a href="#S3-Event-based-Hudi-Incremental-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersources3incrignorekeyprefix">hoodie.streamer.source.s3incr.ignore.key.prefix</a></td><td>(N/A)</td><td>Control whether to ignore the s3 objects starting with this prefix<br><code>Config Param: S3_IGNORE_KEY_PREFIX</code></td></tr><tr><td><a href="#hoodiestreamersources3incrignorekeysubstring">hoodie.streamer.source.s3incr.ignore.key.substring</a></td><td>(N/A)</td><td>Control whether to ignore the s3 objects with this substring<br><code>Config Param: S3_IGNORE_KEY_SUBSTRING</code></td></tr><tr><td><a href="#hoodiestreamersources3incrkeyprefix">hoodie.streamer.source.s3incr.key.prefix</a></td><td>(N/A)</td><td>Control whether to filter the s3 objects starting with this prefix<br><code>Config Param: S3_KEY_PREFIX</code></td></tr><tr><td><a href="#hoodiestreamersources3incrsparkdatasourceoptions">hoodie.streamer.source.s3incr.spark.datasource.options</a></td><td>(N/A)</td><td>Json string, passed to the reader while loading dataset. Example Hudi Streamer conf   --hoodie-conf hoodie.streamer.source.s3incr.spark.datasource.options={&quot;header&quot;:&quot;true&quot;,&quot;encoding&quot;:&quot;UTF-8&quot;}<br><code>Config Param: SPARK_DATASOURCE_OPTIONS</code></td></tr><tr><td><a href="#hoodiestreamersources3incrcheckfileexists">hoodie.streamer.source.s3incr.check.file.exists</a></td><td>false</td><td>Control whether we do existence check for files before consuming them<br><code>Config Param: S3_INCR_ENABLE_EXISTS_CHECK</code></td></tr><tr><td><a href="#hoodiestreamersources3incrfsprefix">hoodie.streamer.source.s3incr.fs.prefix</a></td><td>s3</td><td>The file system prefix.<br><code>Config Param: S3_FS_PREFIX</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="S3-Source-Configs">S3 Source Configs<a class="hash-link" href="#S3-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of S3 source in Hudi Streamer.</p><p><a href="#S3-Source-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamers3sourcequeueurl">hoodie.streamer.s3.source.queue.url</a></td><td>(N/A)</td><td>Queue url for cloud object events<br><code>Config Param: S3_SOURCE_QUEUE_URL</code></td></tr></tbody></table><p><a href="#S3-Source-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamers3sourcequeueregion">hoodie.streamer.s3.source.queue.region</a></td><td>(N/A)</td><td>Case-sensitive region name of the cloud provider for the queue. For example, &quot;us-east-1&quot;.<br><code>Config Param: S3_SOURCE_QUEUE_REGION</code></td></tr><tr><td><a href="#hoodiestreamers3sourcequeuefs">hoodie.streamer.s3.source.queue.fs</a></td><td>s3</td><td>File system corresponding to queue. For example, for AWS SQS it is s3/s3a.<br><code>Config Param: S3_SOURCE_QUEUE_FS</code></td></tr><tr><td><a href="#hoodiestreamers3sourcequeuelongpollwait">hoodie.streamer.s3.source.queue.long.poll.wait</a></td><td>20</td><td>Long poll wait time in seconds, If set as 0 then client will fetch on short poll basis.<br><code>Config Param: S3_QUEUE_LONG_POLL_WAIT</code></td></tr><tr><td><a href="#hoodiestreamers3sourcequeuemaxmessagesperbatch">hoodie.streamer.s3.source.queue.max.messages.per.batch</a></td><td>5</td><td>Max messages for each batch of Hudi Streamer run. Source will process these maximum number of message at a time.<br><code>Config Param: S3_SOURCE_QUEUE_MAX_MESSAGES_PER_BATCH</code></td></tr><tr><td><a href="#hoodiestreamers3sourcequeuemaxmessagesperrequest">hoodie.streamer.s3.source.queue.max.messages.per.request</a></td><td>10</td><td>Max messages for each request<br><code>Config Param: S3_SOURCE_QUEUE_MAX_MESSAGES_PER_REQUEST</code></td></tr><tr><td><a href="#hoodiestreamers3sourcequeuevisibilitytimeout">hoodie.streamer.s3.source.queue.visibility.timeout</a></td><td>30</td><td>Visibility timeout for messages in queue. After we consume the message, queue will move the consumed messages to in-flight state, these messages can&#x27;t be consumed again by source for this timeout period.<br><code>Config Param: S3_SOURCE_QUEUE_VISIBILITY_TIMEOUT</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="SQL-Source-Configs">SQL Source Configs<a class="hash-link" href="#SQL-Source-Configs" title="Direct link to heading">​</a></h4><p>Configurations controlling the behavior of SQL source in Hudi Streamer.</p><p><a href="#SQL-Source-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamersourcesqlsqlquery">hoodie.streamer.source.sql.sql.query</a></td><td>(N/A)</td><td>SQL query for fetching source data.<br><code>Config Param: SOURCE_SQL</code></td></tr></tbody></table><hr><h3 class="anchor anchorWithStickyNavbar_y2LR" id="SCHEMA_PROVIDER">Hudi Streamer Schema Provider Configs<a class="hash-link" href="#SCHEMA_PROVIDER" title="Direct link to heading">​</a></h3><p>Configurations that control the schema provider for Hudi Streamer.</p><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Hudi-Streamer-Schema-Provider-Configs">Hudi Streamer Schema Provider Configs<a class="hash-link" href="#Hudi-Streamer-Schema-Provider-Configs" title="Direct link to heading">​</a></h4><p><a href="#Hudi-Streamer-Schema-Provider-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaproviderregistrytargetUrl">hoodie.streamer.schemaprovider.registry.targetUrl</a></td><td>(N/A)</td><td>The schema of the target you are writing to e.g. https://foo:<a href="mailto:bar@schemaregistry.org" target="_blank" rel="noopener noreferrer">bar@schemaregistry.org</a><br><code>Config Param: TARGET_SCHEMA_REGISTRY_URL</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderregistryurl">hoodie.streamer.schemaprovider.registry.url</a></td><td>(N/A)</td><td>The schema of the source you are reading from e.g. https://foo:<a href="mailto:bar@schemaregistry.org" target="_blank" rel="noopener noreferrer">bar@schemaregistry.org</a><br><code>Config Param: SRC_SCHEMA_REGISTRY_URL</code></td></tr></tbody></table><p><a href="#Hudi-Streamer-Schema-Provider-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaproviderregistrybaseUrl">hoodie.streamer.schemaprovider.registry.baseUrl</a></td><td>(N/A)</td><td>The base URL of the schema registry.<br><code>Config Param: SCHEMA_REGISTRY_BASE_URL</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderregistryschemaconverter">hoodie.streamer.schemaprovider.registry.schemaconverter</a></td><td>(N/A)</td><td>The class name of the custom schema converter to use.<br><code>Config Param: SCHEMA_CONVERTER</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderregistrysourceUrlSuffix">hoodie.streamer.schemaprovider.registry.sourceUrlSuffix</a></td><td>(N/A)</td><td>The source URL suffix.<br><code>Config Param: SCHEMA_REGISTRY_SOURCE_URL_SUFFIX</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderregistrytargetUrlSuffix">hoodie.streamer.schemaprovider.registry.targetUrlSuffix</a></td><td>(N/A)</td><td>The target URL suffix.<br><code>Config Param: SCHEMA_REGISTRY_TARGET_URL_SUFFIX</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderregistryurlSuffix">hoodie.streamer.schemaprovider.registry.urlSuffix</a></td><td>(N/A)</td><td>The suffix of the URL for the schema registry.<br><code>Config Param: SCHEMA_REGISTRY_URL_SUFFIX</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderspark_avro_post_processorenable">hoodie.streamer.schemaprovider.spark_avro_post_processor.enable</a></td><td>true</td><td>Whether to enable Spark Avro post processor.<br><code>Config Param: SPARK_AVRO_POST_PROCESSOR_ENABLE</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="File-based-Schema-Provider-Configs">File-based Schema Provider Configs<a class="hash-link" href="#File-based-Schema-Provider-Configs" title="Direct link to heading">​</a></h4><p>Configurations for file-based schema provider.</p><p><a href="#File-based-Schema-Provider-Configs-basic-configs"><strong>Basic Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaprovidersourceschemafile">hoodie.streamer.schemaprovider.source.schema.file</a></td><td>(N/A)</td><td>The schema of the source you are reading from<br><code>Config Param: SOURCE_SCHEMA_FILE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidertargetschemafile">hoodie.streamer.schemaprovider.target.schema.file</a></td><td>(N/A)</td><td>The schema of the target you are writing to<br><code>Config Param: TARGET_SCHEMA_FILE</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Hive-Schema-Provider-Configs">Hive Schema Provider Configs<a class="hash-link" href="#Hive-Schema-Provider-Configs" title="Direct link to heading">​</a></h4><p>Configurations for Hive schema provider.</p><p><a href="#Hive-Schema-Provider-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaprovidersourceschemahivetable">hoodie.streamer.schemaprovider.source.schema.hive.table</a></td><td>(N/A)</td><td>Hive table from where source schema can be fetched<br><code>Config Param: SOURCE_SCHEMA_TABLE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidertargetschemahivetable">hoodie.streamer.schemaprovider.target.schema.hive.table</a></td><td>(N/A)</td><td>Hive table from where target schema can be fetched<br><code>Config Param: TARGET_SCHEMA_TABLE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemahivedatabase">hoodie.streamer.schemaprovider.source.schema.hive.database</a></td><td>default</td><td>Hive database from where source schema can be fetched<br><code>Config Param: SOURCE_SCHEMA_DATABASE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidertargetschemahivedatabase">hoodie.streamer.schemaprovider.target.schema.hive.database</a></td><td>default</td><td>Hive database from where target schema can be fetched<br><code>Config Param: TARGET_SCHEMA_DATABASE</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="JDBC-based-Schema-Provider-Configs">JDBC-based Schema Provider Configs<a class="hash-link" href="#JDBC-based-Schema-Provider-Configs" title="Direct link to heading">​</a></h4><p>Configurations for JDBC-based schema provider.</p><p><a href="#JDBC-based-Schema-Provider-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcconnectionurl">hoodie.streamer.schemaprovider.source.schema.jdbc.connection.url</a></td><td>(N/A)</td><td>The JDBC URL to connect to. The source-specific connection properties may be specified in the URL. e.g., jdbc:postgresql://localhost/test?user=fred<!-- -->&amp;<!-- -->password=secret<br><code>Config Param: SOURCE_SCHEMA_JDBC_CONNECTION_URL</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcdbtable">hoodie.streamer.schemaprovider.source.schema.jdbc.dbtable</a></td><td>(N/A)</td><td>The table with the schema to reference e.g. test_database.test1_table or test1_table<br><code>Config Param: SOURCE_SCHEMA_JDBC_DBTABLE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcdrivertype">hoodie.streamer.schemaprovider.source.schema.jdbc.driver.type</a></td><td>(N/A)</td><td>The class name of the JDBC driver to use to connect to this URL. e.g. org.h2.Driver<br><code>Config Param: SOURCE_SCHEMA_JDBC_DRIVER_TYPE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcnullable">hoodie.streamer.schemaprovider.source.schema.jdbc.nullable</a></td><td>(N/A)</td><td>If true, all the columns are nullable.<br><code>Config Param: SOURCE_SCHEMA_JDBC_NULLABLE</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcpassword">hoodie.streamer.schemaprovider.source.schema.jdbc.password</a></td><td>(N/A)</td><td>Password for the connection e.g. secret<br><code>Config Param: SOURCE_SCHEMA_JDBC_PASSWORD</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbctimeout">hoodie.streamer.schemaprovider.source.schema.jdbc.timeout</a></td><td>(N/A)</td><td>The number of seconds the driver will wait for a Statement object to execute. Zero means there is no limit. In the write path, this option depends on how JDBC drivers implement the API setQueryTimeout, e.g., the h2 JDBC driver checks the timeout of each query instead of an entire JDBC batch. It defaults to 0.<br><code>Config Param: SOURCE_SCHEMA_JDBC_TIMEOUT</code></td></tr><tr><td><a href="#hoodiestreamerschemaprovidersourceschemajdbcusername">hoodie.streamer.schemaprovider.source.schema.jdbc.username</a></td><td>(N/A)</td><td>Username for the connection e.g. fred<br><code>Config Param: SOURCE_SCHEMA_JDBC_USERNAME</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="JDBC-based-Schema-Provider-Configs">JDBC-based Schema Provider Configs<a class="hash-link" href="#JDBC-based-Schema-Provider-Configs" title="Direct link to heading">​</a></h4><p>Configurations for Proto schema provider.</p><p><a href="#JDBC-based-Schema-Provider-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaproviderprotoclassname">hoodie.streamer.schemaprovider.proto.class.name</a></td><td>(N/A)</td><td>The Protobuf Message class used as the source for the schema.<br><code>Config Param: PROTO_SCHEMA_CLASS_NAME</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderprotoflattenwrappers">hoodie.streamer.schemaprovider.proto.flatten.wrappers</a></td><td>false</td><td>When set to true wrapped primitives like Int64Value are translated to a record with a single &#x27;value&#x27; field. By default, the value is false and the wrapped primitives are treated as a nullable value<br><code>Config Param: PROTO_SCHEMA_WRAPPED_PRIMITIVES_AS_RECORDS</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderprotomaxrecursiondepth">hoodie.streamer.schemaprovider.proto.max.recursion.depth</a></td><td>5</td><td>The max depth to unravel the Proto schema when translating into an Avro schema. Setting this depth allows the user to convert a schema that is recursive in proto into something that can be represented in their lake format like Parquet. After a given class has been seen N times within a single branch, the schema provider will create a record with a byte array to hold the remaining proto data and a string to hold the message descriptor&#x27;s name for context.<br><code>Config Param: PROTO_SCHEMA_MAX_RECURSION_DEPTH</code><br><code>Since Version: 0.13.0</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderprototimestampsasrecords">hoodie.streamer.schemaprovider.proto.timestamps.as.records</a></td><td>false</td><td>When set to true Timestamp fields are translated to a record with a seconds and nanos field. By default, the value is false and the timestamp is converted to a long with the timestamp-micros logical type<br><code>Config Param: PROTO_SCHEMA_TIMESTAMPS_AS_RECORDS</code><br><code>Since Version: 0.13.0</code></td></tr></tbody></table><hr><h4 class="anchor anchorWithStickyNavbar_y2LR" id="Schema-Post-Processor-Config-Configs">Schema Post Processor Config Configs<a class="hash-link" href="#Schema-Post-Processor-Config-Configs" title="Direct link to heading">​</a></h4><p>Configurations for Schema Post Processor</p><p><a href="#Schema-Post-Processor-Config-Configs-advanced-configs"><strong>Advanced Configs</strong></a></p><table><thead><tr><th>Config Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processor">hoodie.streamer.schemaprovider.schema_post_processor</a></td><td>(N/A)</td><td>The class name of the schema post processor.<br><code>Config Param: SCHEMA_POST_PROCESSOR</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processoraddcolumndefault">hoodie.streamer.schemaprovider.schema_post_processor.add.column.default</a></td><td>(N/A)</td><td>New column&#x27;s default value<br><code>Config Param: SCHEMA_POST_PROCESSOR_ADD_COLUMN_DEFAULT_PROP</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processoraddcolumndoc">hoodie.streamer.schemaprovider.schema_post_processor.add.column.doc</a></td><td>(N/A)</td><td>Docs about new column<br><code>Config Param: SCHEMA_POST_PROCESSOR_ADD_COLUMN_DOC_PROP</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processoraddcolumnname">hoodie.streamer.schemaprovider.schema_post_processor.add.column.name</a></td><td>(N/A)</td><td>New column&#x27;s name<br><code>Config Param: SCHEMA_POST_PROCESSOR_ADD_COLUMN_NAME_PROP</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processoraddcolumntype">hoodie.streamer.schemaprovider.schema_post_processor.add.column.type</a></td><td>(N/A)</td><td>New column&#x27;s type<br><code>Config Param: SCHEMA_POST_PROCESSOR_ADD_COLUMN_TYPE_PROP</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processordeletecolumns">hoodie.streamer.schemaprovider.schema_post_processor.delete.columns</a></td><td>(N/A)</td><td>Columns to delete in the schema post processor.<br><code>Config Param: DELETE_COLUMN_POST_PROCESSOR_COLUMN</code></td></tr><tr><td><a href="#hoodiestreamerschemaproviderschema_post_processoraddcolumnnullable">hoodie.streamer.schemaprovider.schema_post_processor.add.column.nullable</a></td><td>true</td><td>New column&#x27;s nullable<br><code>Config Param: SCHEMA_POST_PROCESSOR_ADD_COLUMN_NULLABLE_PROP</code></td></tr></tbody></table><hr></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/apache/hudi/tree/asf-site/website/versioned_docs/version-0.14.0/configurations.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/basic_configurations"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Basic Configurations</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/performance"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Performance</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#externalized-config-file" class="table-of-contents__link toc-highlight">Externalized Config File</a></li><li><a href="#SPARK_DATASOURCE" class="table-of-contents__link toc-highlight">Spark Datasource Configs</a><ul><li><a href="#Read-Options" class="table-of-contents__link toc-highlight">Read Options</a></li><li><a href="#Write-Options" class="table-of-contents__link toc-highlight">Write Options</a></li><li><a href="#PreCommit-Validator-Configurations" class="table-of-contents__link toc-highlight">PreCommit Validator Configurations</a></li></ul></li><li><a href="#FLINK_SQL" class="table-of-contents__link toc-highlight">Flink Sql Configs</a><ul><li><a href="#Flink-Options" class="table-of-contents__link toc-highlight">Flink Options</a></li></ul></li><li><a href="#WRITE_CLIENT" class="table-of-contents__link toc-highlight">Write Client Configs</a><ul><li><a href="#Common-Configurations" class="table-of-contents__link toc-highlight">Common Configurations</a></li><li><a href="#Metadata-Configs" class="table-of-contents__link toc-highlight">Metadata Configs</a></li><li><a href="#Metaserver-Configs" class="table-of-contents__link toc-highlight">Metaserver Configs</a></li><li><a href="#Storage-Configs" class="table-of-contents__link toc-highlight">Storage Configs</a></li><li><a href="#Consistency-Guard-Configurations" class="table-of-contents__link toc-highlight">Consistency Guard Configurations</a></li><li><a href="#FileSystem-Guard-Configurations" class="table-of-contents__link toc-highlight">FileSystem Guard Configurations</a></li><li><a href="#File-System-View-Storage-Configurations" class="table-of-contents__link toc-highlight">File System View Storage Configurations</a></li><li><a href="#Archival-Configs" class="table-of-contents__link toc-highlight">Archival Configs</a></li><li><a href="#Bootstrap-Configs" class="table-of-contents__link toc-highlight">Bootstrap Configs</a></li><li><a href="#Clean-Configs" class="table-of-contents__link toc-highlight">Clean Configs</a></li><li><a href="#Clustering-Configs" class="table-of-contents__link toc-highlight">Clustering Configs</a></li><li><a href="#Compaction-Configs" class="table-of-contents__link toc-highlight">Compaction Configs</a></li><li><a href="#Layout-Configs" class="table-of-contents__link toc-highlight">Layout Configs</a></li><li><a href="#Memory-Configurations" class="table-of-contents__link toc-highlight">Memory Configurations</a></li><li><a href="#Write-Configurations" class="table-of-contents__link toc-highlight">Write Configurations</a></li><li><a href="#COMMIT_CALLBACK" class="table-of-contents__link toc-highlight">Commit Callback Configs</a><ul><li><a href="#Write-commit-callback-configs" class="table-of-contents__link toc-highlight">Write commit callback configs</a></li><li><a href="#Write-commit-Kafka-callback-configs" class="table-of-contents__link toc-highlight">Write commit Kafka callback configs</a></li><li><a href="#Write-commit-pulsar-callback-configs" class="table-of-contents__link toc-highlight">Write commit pulsar callback configs</a></li></ul></li><li><a href="#LOCK" class="table-of-contents__link toc-highlight">Lock Configs</a><ul><li><a href="#Common-Lock-Configurations" class="table-of-contents__link toc-highlight">Common Lock Configurations</a></li><li><a href="#DynamoDB-based-Locks-Configurations" class="table-of-contents__link toc-highlight">DynamoDB based Locks Configurations</a></li></ul></li><li><a href="#KEY_GENERATOR" class="table-of-contents__link toc-highlight">Key Generator Configs</a><ul><li><a href="#Key-Generator-Options" class="table-of-contents__link toc-highlight">Key Generator Options</a></li></ul></li><li><a href="#INDEX" class="table-of-contents__link toc-highlight">Index Configs</a><ul><li><a href="#Common-Index-Configs" class="table-of-contents__link toc-highlight">Common Index Configs</a></li><li><a href="#HBase-Index-Configs" class="table-of-contents__link toc-highlight">HBase Index Configs</a></li></ul></li></ul></li><li><a href="#META_SYNC" class="table-of-contents__link toc-highlight">Metastore and Catalog Sync Configs</a><ul><li><a href="#Common-Metadata-Sync-Configs" class="table-of-contents__link toc-highlight">Common Metadata Sync Configs</a></li><li><a href="#Glue-catalog-sync-based-client-Configurations" class="table-of-contents__link toc-highlight">Glue catalog sync based client Configurations</a></li><li><a href="#BigQuery-Sync-Configs" class="table-of-contents__link toc-highlight">BigQuery Sync Configs</a></li><li><a href="#Hive-Sync-Configs" class="table-of-contents__link toc-highlight">Hive Sync Configs</a></li><li><a href="#Global-Hive-Sync-Configs" class="table-of-contents__link toc-highlight">Global Hive Sync Configs</a></li><li><a href="#DataHub-Sync-Configs" class="table-of-contents__link toc-highlight">DataHub Sync Configs</a></li></ul></li><li><a href="#METRICS" class="table-of-contents__link toc-highlight">Metrics Configs</a><ul><li><a href="#Metrics-Configurations-for-Amazon-CloudWatch" class="table-of-contents__link toc-highlight">Metrics Configurations for Amazon CloudWatch</a></li><li><a href="#Metrics-Configurations" class="table-of-contents__link toc-highlight">Metrics Configurations</a></li><li><a href="#Metrics-Configurations-for-Datadog-reporter" class="table-of-contents__link toc-highlight">Metrics Configurations for Datadog reporter</a></li><li><a href="#Metrics-Configurations-for-Graphite" class="table-of-contents__link toc-highlight">Metrics Configurations for Graphite</a></li><li><a href="#Metrics-Configurations-for-Jmx" class="table-of-contents__link toc-highlight">Metrics Configurations for Jmx</a></li><li><a href="#Metrics-Configurations-for-Prometheus" class="table-of-contents__link toc-highlight">Metrics Configurations for Prometheus</a></li></ul></li><li><a href="#RECORD_PAYLOAD" class="table-of-contents__link toc-highlight">Record Payload Config</a><ul><li><a href="#Payload-Configurations" class="table-of-contents__link toc-highlight">Payload Configurations</a></li></ul></li><li><a href="#KAFKA_CONNECT" class="table-of-contents__link toc-highlight">Kafka Connect Configs</a><ul><li><a href="#Kafka-Sink-Connect-Configurations" class="table-of-contents__link toc-highlight">Kafka Sink Connect Configurations</a></li></ul></li><li><a href="#AWS" class="table-of-contents__link toc-highlight">Amazon Web Services Configs</a><ul><li><a href="#Amazon-Web-Services-Configs" class="table-of-contents__link toc-highlight">Amazon Web Services Configs</a></li></ul></li><li><a href="#HUDI_STREAMER" class="table-of-contents__link toc-highlight">Hudi Streamer Configs</a><ul><li><a href="#Hudi-Streamer-Configs" class="table-of-contents__link toc-highlight">Hudi Streamer Configs</a></li><li><a href="#Hudi-Streamer-SQL-Transformer-Configs" class="table-of-contents__link toc-highlight">Hudi Streamer SQL Transformer Configs</a></li><li><a href="#DELTA_STREAMER_SOURCE" class="table-of-contents__link toc-highlight">Hudi Streamer Source Configs</a><ul><li><a href="#Cloud-Source-Configs" class="table-of-contents__link toc-highlight">Cloud Source Configs</a></li><li><a href="#DFS-Path-Selector-Configs" class="table-of-contents__link toc-highlight">DFS Path Selector Configs</a></li><li><a href="#Date-Partition-Path-Selector-Configs" class="table-of-contents__link toc-highlight">Date Partition Path Selector Configs</a></li><li><a href="#GCS-Events-Source-Configs" class="table-of-contents__link toc-highlight">GCS Events Source Configs</a></li><li><a href="#Hive-Incremental-Pulling-Source-Configs" class="table-of-contents__link toc-highlight">Hive Incremental Pulling Source Configs</a></li><li><a href="#Hudi-Incremental-Source-Configs" class="table-of-contents__link toc-highlight">Hudi Incremental Source Configs</a></li><li><a href="#JDBC-Source-Configs" class="table-of-contents__link toc-highlight">JDBC Source Configs</a></li><li><a href="#Json-Kafka-Post-Processor-Configs" class="table-of-contents__link toc-highlight">Json Kafka Post Processor Configs</a></li><li><a href="#Kafka-Source-Configs" class="table-of-contents__link toc-highlight">Kafka Source Configs</a></li><li><a href="#Pulsar-Source-Configs" class="table-of-contents__link toc-highlight">Pulsar Source Configs</a></li><li><a href="#S3-Event-based-Hudi-Incremental-Source-Configs" class="table-of-contents__link toc-highlight">S3 Event-based Hudi Incremental Source Configs</a></li><li><a href="#S3-Source-Configs" class="table-of-contents__link toc-highlight">S3 Source Configs</a></li><li><a href="#SQL-Source-Configs" class="table-of-contents__link toc-highlight">SQL Source Configs</a></li></ul></li><li><a href="#SCHEMA_PROVIDER" class="table-of-contents__link toc-highlight">Hudi Streamer Schema Provider Configs</a><ul><li><a href="#Hudi-Streamer-Schema-Provider-Configs" class="table-of-contents__link toc-highlight">Hudi Streamer Schema Provider Configs</a></li><li><a href="#File-based-Schema-Provider-Configs" class="table-of-contents__link toc-highlight">File-based Schema Provider Configs</a></li><li><a href="#Hive-Schema-Provider-Configs" class="table-of-contents__link toc-highlight">Hive Schema Provider Configs</a></li><li><a href="#JDBC-based-Schema-Provider-Configs" class="table-of-contents__link toc-highlight">JDBC-based Schema Provider Configs</a></li><li><a href="#JDBC-based-Schema-Provider-Configs" class="table-of-contents__link toc-highlight">JDBC-based Schema Provider Configs</a></li><li><a href="#Schema-Post-Processor-Config-Configs" class="table-of-contents__link toc-highlight">Schema Post Processor Config Configs</a></li></ul></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">About</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog/2021/07/21/streaming-data-lake-platform">Our Vision</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/concepts">Concepts</a></li><li class="footer__item"><a class="footer__link-item" href="/community/team">Team</a></li><li class="footer__item"><a class="footer__link-item" href="/releases/release-0.14.0">Releases</a></li><li class="footer__item"><a class="footer__link-item" href="/releases/download">Download</a></li><li class="footer__item"><a class="footer__link-item" href="/powered-by">Who&#x27;s Using</a></li></ul></div><div class="col footer__col"><div class="footer__title">Learn</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/quick-start-guide">Quick Start</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/docker_demo">Docker Demo</a></li><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/talks">Talks</a></li><li class="footer__item"><a class="footer__link-item" href="/videos">Video Guides</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQ</a></li><li class="footer__item"><a href="https://cwiki.apache.org/confluence/display/HUDI" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Technical Wiki<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">Hudi On Cloud</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/s3_hoodie">AWS</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/gcs_hoodie">Google Cloud</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/oss_hoodie">Alibaba Cloud</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/azure_hoodie">Microsoft Azure</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/cos_hoodie">Tencent Cloud</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/ibm_cos_hoodie">IBM Cloud</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/community/get-involved">Get Involved</a></li><li class="footer__item"><a href="https://join.slack.com/t/apache-hudi/shared_invite/zt-20r833rxh-627NWYDUyR8jRtMa2mZ~gg" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Slack<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://github.com/apache/hudi" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/ApacheHudi" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.youtube.com/channel/UCs7AhE0BWaEPZSChrBR-Muw" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>YouTube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://www.linkedin.com/company/apache-hudi/?viewAsMember=true" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Linkedin<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="mailto:dev-subscribe@hudi.apache.org?Subject=SubscribeToHudi" target="_blank" rel="noopener noreferrer" class="footer__link-item">Mailing List</a></li></ul></div><div class="col footer__col"><div class="footer__title">Apache</div><ul class="footer__items"><li class="footer__item"><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="footer__link-item">Events</a></li><li class="footer__item"><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">Thanks</a></li><li class="footer__item"><a href="https://www.apache.org/licenses" target="_blank" rel="noopener noreferrer" class="footer__link-item">License</a></li><li class="footer__item"><a href="https://www.apache.org/security" target="_blank" rel="noopener noreferrer" class="footer__link-item">Security</a></li><li class="footer__item"><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="footer__link-item">Sponsorship</a></li><li class="footer__item"><a href="https://www.apache.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">Foundation</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://hudi.apache.org/" target="_blank" rel="noopener noreferrer" class="footerLogoLink_SRtH"><img src="/assets/images/logo-big.png" alt="Apache Hudi™" class="themedImage_TMUO themedImage--light_4Vu1 footer__logo"><img src="/assets/images/logo-big.png" alt="Apache Hudi™" class="themedImage_TMUO themedImage--dark_uzRr footer__logo"></a></div><div class="footer__copyright">Copyright © 2021 <a href="https://apache.org">The Apache Software Foundation</a>, Licensed under the <a href="https://www.apache.org/licenses/LICENSE-2.0"> Apache License, Version 2.0</a>. <br>Hudi, Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.072d1a07.js"></script>
<script src="/assets/js/main.4a28cd57.js"></script>
</body>
</html>