name: Publish Hudi-Internal Daily Changelog Release

on:
  schedule:
    - cron: '0 16 * * *' # 4pm PST daily
  workflow_call:
  workflow_dispatch:
    inputs:
      releaseVersion:
        description: "Example: 1.49.0"
        required: true
        type: string
        default: "auto-detect"
      auditNumber:
        description: "[AUDIT-XXXX]"
        required: false
        type: string
        default: "[AUDIT-1071]"

permissions:
  pull-requests: write
  contents: write
  actions: read

jobs:
  update-tags:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_DAILY_DATAPLANE_RELEASE }}

      - name: Install GitHub CLI
        run: sudo apt-get install -y gh

      - name: Determine most recent HUDI release version
        id: determine-hudi-release-version
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_DAILY_DATAPLANE_RELEASE }}
        run: |
          gh auth setup-git

          # Store branches in a variable
          branches=$(gh run list --repo onehouseinc/hudi-internal \
          --workflow "release.yml" \
          --limit 5 --json headBranch -q '.[].headBranch')

          # Extract the matching pattern "1.XXX.X" from the branches
          highest=$(echo "$branches" | grep -Eo '1\.[0-9]+\.[0-9]+' | sed -E 's/^1\.([0-9]+)\.[0-9]+$/\1/' | sort -nr | head -n 1)

          new_minor_version=$((highest + 1))
          echo "CALCULATED_MINOR_VERSION=$new_minor_version" >> $GITHUB_OUTPUT
      
      - name: Extract last release version, build release, and push changelog PR
        id: extract-last-release
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_DAILY_DATAPLANE_RELEASE }}
        run: |
          # Detect the previous X.XXX.0 release version from the CHANGELOG file using grep/sed magic
          # VERY IMPORTANT!! This will skip patch releases (anything with X.XXX.[1-9])
          FILE="CHANGELOG"
          DETECTED_PREV_RELEASE_VERSION=$(grep -- '--- *\[.*\] *\[.*release-v[0-9]\{1,\}\.[0-9]\{1,\}\.0\{1,\}.*\] *---' "$FILE" \
              | tail -n 1 \
              | sed -E 's/.*release-v([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          
          echo "Detected previous release version: $DETECTED_PREV_RELEASE_VERSION"

          # If the next release version is not provided, auto-detect it:
          if [ "${{ inputs.releaseVersion }}" == "auto-detect" ]; then
              # Use this to bump the major version.
              RELEASE_MAJOR_VERSION="1"
              RELEASE_MINOR_VERSION="${{ steps.determine-hudi-release-version.outputs.CALCULATED_MINOR_VERSION }}"
              RELEASE_PATCH_VERSION="0"

              # Construct the final release version
              RELEASE_VERSION="${RELEASE_MAJOR_VERSION}.${RELEASE_MINOR_VERSION}.${RELEASE_PATCH_VERSION}"
          else
              RELEASE_VERSION="${{ inputs.releaseVersion }}"
          fi

          # Check if the release version is greater than the previous release version
          # Not sure if this is necessary, but it's a good check to have.
          if [ "$(echo -e "$RELEASE_VERSION\n$DETECTED_PREV_RELEASE_VERSION" | sort -V | head -n 1)" == "$RELEASE_VERSION" ]; then
              echo "Error: The release version ($RELEASE_VERSION) must be greater than the previous release version ($DETECTED_PREV_RELEASE_VERSION)."
              exit 1
          fi

          # Print the calculated release version
          echo "Releasing from this version: $RELEASE_VERSION"

          # Construct the release branch name
          RELEASE_BRANCH_NAME="release-v${RELEASE_VERSION}"

          # Check if the branch already exists
          if git ls-remote --exit-code origin "$RELEASE_BRANCH_NAME" &>/dev/null; then
            echo "Branch $RELEASE_BRANCH_NAME already exists on the remote."
            echo "CI builds will fail, please try again with a new branch/version."
            exit 1
          fi

          # Adapted from: https://app.clickup.com/18029943/v/dc/h67bq-25107/h67bq-532657

          # Now get the SHA from the previous release branch:
          # Couple of pitfalls here:
            # 1. The previous release branch might not be found.
            # 2. The previous release branch might be a hotfix, in which case
            #    the changelog may end up being super long, ex: https://github.com/onehouseinc/hudi-internal/pull/1038/files
          # Fetch all branches matching release-* and master in one step
          git fetch origin '+refs/heads/release-*:refs/remotes/origin/release-*' master

          # Ensure you're on the latest master
          git switch master
          git pull
          PREVIOUS_RELEASE_BRANCH="release-v${DETECTED_PREV_RELEASE_VERSION}"
          PREVIOUS_RELEASE_SHA=$(git rev-parse "origin/${PREVIOUS_RELEASE_BRANCH}")

          echo "Previous release branch: $PREVIOUS_RELEASE_BRANCH"
          echo "Previous release SHA: $PREVIOUS_RELEASE_SHA"

          # Checkout the release branch locally.
          git checkout -b "$RELEASE_BRANCH_NAME"

          # Adapted from ./release.sh
          echo "" >> CHANGELOG
          echo "--- [$(date '+%Y-%m-%d %H:%M:%S')] [$(git branch --show-current)] ---" >> CHANGELOG

          # Get all commit messages in the range
          COMMIT_MESSAGES=$(git log ${PREVIOUS_RELEASE_SHA}..HEAD --pretty=format:"%s")

          echo "Commit messages: $COMMIT_MESSAGES"

          # If there are no commits, exit 0
          if [ -z "$COMMIT_MESSAGES" ]; then
            echo "No commits found. Exiting workflow."
            exit 0
          fi

          # Check if all commit messages start with "[AUDIT-]" (for some reason grep did not work in ubuntu/gh actions)
          NON_AUDIT_COMMITS=$(echo "$COMMIT_MESSAGES" | awk '!/^\[AUDIT-/')

          # Check if there are any non-audit commits
          if [ -n "$(echo "$NON_AUDIT_COMMITS" | xargs)" ]; then
            echo "There are non-audit commits: $NON_AUDIT_COMMITS"
          else
            echo "All commit messages start with [AUDIT-]. Exiting workflow."
            exit 0
          fi

          # Append commit log to CHANGELOG if conditions are not met
          echo "$COMMIT_MESSAGES" >> CHANGELOG

          # Once we push the release branch, we have locked in a release version,
          # this means we have to be sure we want to release this version.

          # Push the release branch to the repository using the PAT_DAILY_DATAPLANE_RELEASE token
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git remote set-url origin https://x-access-token:${{ secrets.PAT_DAILY_DATAPLANE_RELEASE }}@github.com/${{ github.repository }}.git

          # Use for debugging if push access fails
          # git config --list
          git push -u origin "$RELEASE_BRANCH_NAME" # --verbose

          # Commit the changelog to the release branch locally (but don't push).
          git add CHANGELOG
          git commit -m "${{ inputs.auditNumber }}: Changelog for $RELEASE_BRANCH_NAME"
          CHANGELOG_COMMIT_ID=$(git log -1 --format=%H)

          # Now checkout the master branch (this behavior is a bit wonky,
          # but it ensures we get a fresh copy of the changelog when doing this locally).
          # Keeping this here for now for consistency.
          git checkout master

          # Now checkout the changelog branch.
          CHANGELOG_BRANCH_NAME="changelog-${RELEASE_BRANCH_NAME}"
          git checkout -b "$CHANGELOG_BRANCH_NAME"
          git cherry-pick $CHANGELOG_COMMIT_ID

          # Check if the branch already exists on remote (if this fails we have a problem).
          if git ls-remote --exit-code origin "$CHANGELOG_BRANCH_NAME" &>/dev/null; then
            echo "Branch $CHANGELOG_BRANCH_NAME already exists on the remote."
            echo "CI builds will fail, please try again with a new branch/version."
            exit 1
          fi

          # Push changelog branch to the repository.
          git push -u origin "$CHANGELOG_BRANCH_NAME"

          # Create the PR
          gh pr create \
            --base master \
            --head "$CHANGELOG_BRANCH_NAME" \
            --title "${{ inputs.auditNumber }}: Changelog for $RELEASE_BRANCH_NAME" \
            --body "Auto-created PR to update the changelog for release $RELEASE_VERSION." \
          
          # Set auto-merge only if the release version is auto-detected. If someone is running this manually,
          # we should not auto-merge the PR.
          if [ "${{ inputs.releaseVersion }}" == "auto-detect" ]; then
            PR_NUMBER=$(gh pr view --json number -q ".number")
            gh pr merge $PR_NUMBER --auto --delete-branch --squash
          fi
          